-- AIO_Umbrella.lua
-- Author: foo0oo
-- Modifications by MrSpenk

local AIO_Umbrella = {}

-- Menu Items
	-- general Menu
	
AIO_Umbrella.optionEnable = Menu.AddOptionBool({ "All In One" }, "1. Overall enabled {{overall}}", false)
AIO_Umbrella.optionComboKey = Menu.AddKeyOption({ "All In One" }, "1.1 overall combo key", Enum.ButtonCode.KEY_SPACE)
AIO_Umbrella.optionTargetStyle = Menu.AddOptionCombo({ "All In One", "1.2 Target selector" }, "0. Targeting style {{overall targeting}}", { 'locked target', 'free target' }, 0, 1, 1)
AIO_Umbrella.optionTargetRange = Menu.AddOptionSlider({ "All In One", "1.2 Target selector" }, "1. Target acquisition range {{overall targeting}}", 200, 1000, 50)
AIO_Umbrella.optionMoveToCursor = Menu.AddOptionBool({ "All In One", "1.2 Target selector" }, "2. Move to Cursor Pos {{overall targeting}}", false)
AIO_Umbrella.optionLockTargetIndicator = Menu.AddOptionBool({ "All In One", "1.2 Target selector" }, "3.1 Draw target indicator {{overall targeting}}", false)
AIO_Umbrella.optionLockTargetParticle = Menu.AddOptionCombo({ "All In One", "1.2 Target selector" }, "3.2 Indicator style {{overall targeting}}", { 'blinding light', 'blood bath', 'tower aggro' }, 0, 2, 1)
AIO_Umbrella.optionTargetCheckAM = Menu.AddOptionBool({ "All In One", "1.2 Target selector", "4. Target exclusions" }, "Exclude AM with agha {{targetselect}}", false)
AIO_Umbrella.optionTargetCheckLotus = Menu.AddOptionBool({ "All In One", "1.2 Target selector", "4. Target exclusions" }, "Exclude active lotus orb {{targetselect}}", false)
AIO_Umbrella.optionTargetCheckBlademail = Menu.AddOptionBool({ "All In One", "1.2 Target selector", "4. Target exclusions" }, "Exclude blademail {{targetselect}}", false)
AIO_Umbrella.optionTargetCheckNyx = Menu.AddOptionBool({ "All In One", "1.2 Target selector", "4. Target exclusions" }, "Exclude spiked carapace {{targetselect}}", false)
AIO_Umbrella.optionTargetCheckUrsa = Menu.AddOptionBool({ "All In One", "1.2 Target selector", "4. Target exclusions" }, "Exclude enraged ursa {{targetselect}}", false)
AIO_Umbrella.optionTargetCheckAbbadon = Menu.AddOptionBool({ "All In One", "1.2 Target selector", "4. Target exclusions" }, "Exclude abaddon ult {{targetselect}}", false)
AIO_Umbrella.optionTargetCheckDazzle = Menu.AddOptionBool({ "All In One", "1.2 Target selector", "4. Target exclusions" }, "Exclude shallow grave {{targetselect}}", false)
AIO_Umbrella.optionWardAwareness = Menu.AddOptionBool({ "All In One", "1.3 Ward awareness" }, "1. Draw indicator for enemy wards {{overall}}", false)
AIO_Umbrella.optionWardAwarenessRemove = Menu.AddOptionBool({ "All In One", "1.3 Ward awareness" }, "2. Auto remove indicator {{overall}}", false)
AIO_Umbrella.optionWardAwarenessClickRemove = Menu.AddOptionBool({ "All In One", "1.3 Ward awareness" }, "3. Click remove indicator {{overall}}", false)
AIO_Umbrella.optionOrbwalkEnable = Menu.AddOptionBool({ "All In One", "4. Orbwalker" }, "0. Enabled {{orbwalker}}", false)
AIO_Umbrella.optionOrbwalkOffset = Menu.AddOptionSlider({ "All In One", "4. Orbwalker" }, "1. Orbwalker offset", 0, 50, 5)
AIO_Umbrella.optionOrbwalkStyle = Menu.AddOptionCombo({ "All In One", "4. Orbwalker" }, "2. Orbwalker style {{orbwalker}}", { 'orbwalk to enemy', 'orbwalk to mouse' }, 0, 1, 1)
AIO_Umbrella.optionOrbwalkDistance = Menu.AddOptionSlider({ "All In One", "4. Orbwalker", "3. Orbwalk to enemy options" }, "1. Minimum distance {{orbwalker enemy}}", 30, 80, 10)
AIO_Umbrella.optionOrbwalkKiting = Menu.AddOptionBool({ "All In One", "4. Orbwalker", "3. Orbwalk to enemy options" }, "2. kiting {{orbwalker}}", false)
AIO_Umbrella.optionOrbwalkDistanceMouse = Menu.AddOptionSlider({ "All In One", "4. Orbwalker", "4. Orbwalk to mouse options" }, "2. Min. distance for ranged heroes {{orbwalker mouse}}", 20, 80, 10)
AIO_Umbrella.optionOrbwalkMouseStyle = Menu.AddOptionCombo({ "All In One", "4. Orbwalker", "4. Orbwalk to mouse options" }, "1. Mouse orbwalk {{orbwalker mouse}}", { 'only with ranged heroes', 'with any hero' }, 0, 1, 1)
AIO_Umbrella.optionOrbwalkMouseHold = Menu.AddOptionSlider({ "All In One", "4. Orbwalker", "4. Orbwalk to mouse options" }, "3. Hold distance {{orbwalker mouse}}", 50, 250, 25)
AIO_Umbrella.optionWorldToMinimapOffsetX = Menu.AddOptionSlider({ "All In One", "6. WorldToMinimap" }, "X-Offset {{minimap}}", -30, 30, 1)
AIO_Umbrella.optionWorldToMinimapOffsetY = Menu.AddOptionSlider({ "All In One", "6. WorldToMinimap" }, "Y-Offset {{minimap}}", -30, 30, 1)
AIO_Umbrella.optionDodgeItEnable = Menu.AddOptionBool({ "All In One", "98. <BETA> DodgeIt" }, "0. Enable {{dodgeit}}", false)
AIO_Umbrella.optionLastHitEnable = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter" }, "0. Enable {{lasthit}}", false)
AIO_Umbrella.optionLastHitKey = Menu.AddKeyOption({ "All In One", "97. <BETA> Last Hitter" }, "1. Activation key {{lasthit}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionLastHitStyle = Menu.AddOptionCombo({ "All In One", "97. <BETA> Last Hitter" }, "2. Targeting style {{lasthit}}", { 'last hit + deny', 'only last hit', 'only deny' }, 0, 2, 1)
AIO_Umbrella.optionLastHitOffset = Menu.AddOptionCombo({ "All In One", "97. <BETA> Last Hitter" }, "3.1 Offset {{lasthit}}", { '0.00s', '0.05s', '0.10s', '0.15s', '0.20s', '0.25s' }, 0, 5, 1)
AIO_Umbrella.optionLastHitPredict = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter" }, "3.2 Use avg damage for prediction {{lasthit}}", false)
AIO_Umbrella.optionLastHitDrawCreepEnable = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter", "4. Drawings" }, "1. Enable creep drawings {{lasthit}}", false)
AIO_Umbrella.optionLastHitDrawRange = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter", "4. Drawings" }, "0. Draw attack range {{lasthit}}", false)
AIO_Umbrella.optionLastHitDrawStyle = Menu.AddOptionCombo({ "All In One", "97. <BETA> Last Hitter", "4. Drawings" }, "1. creep info style {{lasthit}}", { 'enemy+ally creeps', 'enemy creeps only' }, 0, 1, 1)
AIO_Umbrella.optionLastHitDrawCreepTimer = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter", "4. Drawings" }, "2. Draw last hit indicator {{lasthit}}", false)
AIO_Umbrella.optionLastHitAutoModeMove = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter", "5. Auto mode options" }, "1. Move to cursor {{lasthit}}", false)
AIO_Umbrella.optionLastHitAutoModeMoveRange = Menu.AddOptionSlider({ "All In One", "97. <BETA> Last Hitter", "5. Auto mode options" }, "2. Min. move range {{lasthit}}", 10, 400, 10)
AIO_Umbrella.optionLastHitAutoModeEnemy = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter", "5. Auto mode options" }, "3. Harass enemy {{lasthit}}", false)
AIO_Umbrella.optionLastHitAutoModeEnemySave = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter", "5. Auto mode options" }, "4. Save harass {{lasthit}}", false)
AIO_Umbrella.optionLastHitOrb = Menu.AddOptionBool({ "All In One", "97. <BETA> Last Hitter", "6. Use orb attacks" }, "1. Enable {{lasthit orbs}}", false)
AIO_Umbrella.optionLastHitOrbMana = Menu.AddOptionSlider({ "All In One", "97. <BETA> Last Hitter", "6. Use orb attacks" }, "2. Mana treshold {{lasthit orbs}}", 5, 75, 5)

-- killsteal Menu
AIO_Umbrella.optionKillStealEnable = Menu.AddOptionBool({ "All In One", "5. Auto Kill Steal" }, "Enabled {{killsteal}}", false)
AIO_Umbrella.optionKillStealInvoker = Menu.AddOptionBool({ "All In One", "5. Auto Kill Steal", "Invoker" }, "1. Auto Sunstrike KillSteal", false)
AIO_Umbrella.optionKillStealInvokerTurn = Menu.AddOptionSlider({ "All In One", "5. Auto Kill Steal", "Invoker" }, "5.2 Turn check adjustment", 10, 60, 5)
AIO_Umbrella.optionKillStealAutoInvoke = Menu.AddOptionBool({ "All In One", "5. Auto Kill Steal", "Invoker" }, "5.1 Auto Invoke Sunstrike", false)
AIO_Umbrella.optionKillStealInvokerTPpartice = Menu.AddOptionBool({ "All In One", "5. Auto Kill Steal", "Invoker" }, "3. Killsteal on TPing enemies", false)
AIO_Umbrella.optionKillStealInvokerImmobil = Menu.AddOptionBool({ "All In One", "5. Auto Kill Steal", "Invoker" }, "2. Killsteal on immobilized enemies", false)
AIO_Umbrella.optionKillStealInvokerTreshold = Menu.AddOptionSlider({ "All In One", "5. Auto Kill Steal", "Invoker" }, "5.3 HP Treshold adjust {{KS invo}}", 0, 25, 5)
AIO_Umbrella.optionKillStealInvokerRunning = Menu.AddOptionBool({ "All In One", "5. Auto Kill Steal", "Invoker" }, "4. Killsteal on moving targets", false)
AIO_Umbrella.optionHeroInvokerCataKS = Menu.AddOptionBool({ "All In One", "5. Auto Kill Steal", "Invoker" }, "6. Killsteal with cataclysm", false)
AIO_Umbrella.optionHeroInvokerCataKSCount = Menu.AddOptionSlider({ "All In One", "5. Auto Kill Steal", "Invoker" }, "6.1 Cataclysm target count", 1, 5, 1)

-- ItemsMenu
AIO_Umbrella.optionItemEnable = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items" }, "0. Enabled {{off items}}", false)
AIO_Umbrella.optionItemStyle = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage" }, "Choose activation style", { 'max speed', 'ordered', 'smart ordered' }, 0, 2, 1)
AIO_Umbrella.optionItemStack = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage" }, "Stack hex and silence", false)
AIO_Umbrella.optionItemSoulring = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Soulring", false)
AIO_Umbrella.optionItemVeil = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Veil Of Discord", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemHex = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Scythe Of Vyse", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemBlood = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Bloodthorn ", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemeBlade = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Ethereal Blade", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemOrchid = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Orchid Malevolence", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemAtos = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Rod Of Atos", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemAbyssal = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Abyssal Blade", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemHalberd = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Heavens Halbert", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemShivas = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Shivas Guard", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemDagon = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Dagon", { 'OFF', 'only if killable', 'ON' }, -1, 18, 1)
AIO_Umbrella.optionItemUrn = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Urn of shadows", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemManta = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Manta Style", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemMjollnir = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Mjollnir", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemMedallion = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Medallion of Courage", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemCrest = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Solar Crest", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemSpirit = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Spirit Vessel", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemNull = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Nullifier", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemDiffusal = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "1. Combo usage", "Items" }, "Use Item Diffusal Blade", { 'OFF', 'ON' }, 0, 18, 1)
AIO_Umbrella.optionItemArmlet = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Armlet" }, "0. Enable {{armlet}}", false)
AIO_Umbrella.optionItemArmletHPTreshold = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Armlet" }, "1. HP threshold {{armlet}}", 100, 500, 50)
AIO_Umbrella.optionItemArmletCombo = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Armlet" }, "2. Combo usage {{armlet}}", false)
AIO_Umbrella.optionItemArmletRightClick = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Armlet" }, "3. Right click activation {{armlet}}", false)
AIO_Umbrella.optionItemArmletRightClickStyle = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Armlet" }, "3.1 Right click style {{armlet}}", { 'single click', 'double click' }, 0, 1, 1)
AIO_Umbrella.optionItemArmletIllusion = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Armlet" }, "4. Illusion activation {{armlet}}", false)
AIO_Umbrella.optionItemArmletManuallyOverride = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Armlet" }, "5. Manual override {{armlet}}", false)
AIO_Umbrella.optionItemHurricane = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Hurricane Pike" }, "0. Enable {{hurricane}}", false)
AIO_Umbrella.optionItemHurricaneHP = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Hurricane Pike" }, "1. HP treshold {{hurricane}}", 5 ,75, 5)
AIO_Umbrella.optionItemBlademail = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "2. Auto Usage", "Blade Mail" }, "0. Enable {{blade mail}}", false)
AIO_Umbrella.optionItemSoulringManual = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "3. OnUnitOrder Usage" }, "Soulring {{onunitorder}}", false)
AIO_Umbrella.optionItemVeilManual = Menu.AddOptionBool({ "All In One", "2. Item Usage", "1. Offensive items", "3. OnUnitOrder Usage" }, "Veil of Discord {{onunitorder}}", false)

-- Linkens Menu
AIO_Umbrella.optionLinkensEnable = Menu.AddOptionBool({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "0. Enabled {{linkens}}", false)
AIO_Umbrella.optionLinkensManual = Menu.AddOptionBool({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "1. Pop linkens when manually casting", false)
AIO_Umbrella.optionLinkensForce = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Force Staff", { 'OFF' }, 0, 8, 1)
AIO_Umbrella.optionLinkensEul = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Eul", { 'OFF' }, 0, 8, 1)
AIO_Umbrella.optionLinkensHalberd = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Halberd", { 'OFF' }, 0, 8, 1)
AIO_Umbrella.optionLinkensHex = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Hex", { 'OFF' }, 0, 8, 1)
AIO_Umbrella.optionLinkensBlood = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Bloodthorn", { 'OFF' }, 0, 8, 1)
AIO_Umbrella.optionLinkensOrchid = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Orchid", { 'OFF' }, 0, 8, 1)
AIO_Umbrella.optionLinkensPike = Menu.AddOptionCombo({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Pike", { 'OFF' }, 0, 8, 1)
AIO_Umbrella.optionLinkensDiffusal = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "4. Linkens breaker" }, "Use Diffusal", 0, 8, 1)

-- Utility Items Menu
AIO_Umbrella.optionUtilityEnable = Menu.AddOptionBool({ "All In One", "2. Item Usage", "3. Utility Items" }, "0. Enable auto usage {{util}}", false)
AIO_Umbrella.optionUtilityMidas = Menu.AddOptionBool({ "All In One", "2. Item Usage", "3. Utility Items" }, "Auto Use Midas", false)
AIO_Umbrella.optionUtilityStick = Menu.AddOptionBool({ "All In One", "2. Item Usage", "3. Utility Items" }, "Auto Use Stick/Wand/Cheese/Faerie", false)
AIO_Umbrella.optionUtilityHealth = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "3. Utility Items" }, "1. Treshold Hero Health", 5, 75, 5)
AIO_Umbrella.optionUtilityMek = Menu.AddOptionBool({ "All In One", "2. Item Usage", "3. Utility Items" }, "Auto Use Mekansm", false)
AIO_Umbrella.optionUtilityGreaves = Menu.AddOptionBool({ "All In One", "2. Item Usage", "3. Utility Items" }, "Auto Use Greaves", false)
AIO_Umbrella.optionUtilityArcane = Menu.AddOptionBool({ "All In One", "2. Item Usage", "3. Utility Items" }, "Auto Use Arcane Boots", false)
AIO_Umbrella.optionUtilityBottle = Menu.AddOptionBool({ "All In One", "2. Item Usage", "3. Utility Items" }, "Auto Use Bottle", false)

-- Defensive Items Menu
AIO_Umbrella.optionDefensiveItems = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "0. Enable auto usage {{deff}}", false)
AIO_Umbrella.optionDefensiveItemsGlimmer = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "2. Glimmer Cape", false)
AIO_Umbrella.optionDefensiveItemslotusOrb = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "3. Lotus Orb", false)
AIO_Umbrella.optionDefensiveItemsCrimson = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "4. Crimson Guard", false)
AIO_Umbrella.optionDefensiveItemsCrest = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "5. Solar Crest", false)
AIO_Umbrella.optionDefensiveItemsPipe = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "6. Pipe", false)
AIO_Umbrella.optionDefensiveItemsBKB = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items", "1. BKB" }, "0. Enabled {{bkb}}", false)
AIO_Umbrella.optionDefensiveItemsBKBEnemies = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "2. Defensive Items", "1. BKB" }, "1. Min. enemies around", 1, 5, 1)
AIO_Umbrella.optionDefensiveItemsBKBRadius = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "2. Defensive Items", "1. BKB" }, "2. Search radius", 500, 1000, 100)
AIO_Umbrella.optionDefensiveItemsSatanic = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "7. Satanic", false)
AIO_Umbrella.optionDefensiveItemsThreshold = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "2. Defensive Items" }, "0.1 HP Threshold {{deff}}", 10, 50, 5)
AIO_Umbrella.optionDefensiveItemsThresholdDisable = Menu.AddOptionSlider({ "All In One", "2. Item Usage", "2. Defensive Items" }, "0.2 HP Threshold if disabled {{deff}}", 35, 100, 5)
AIO_Umbrella.optionDefensiveItemsMedallion = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "8. Medallion of Courage", false)
AIO_Umbrella.optionDefensiveItemsGhost = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "9. Ghost scepter", false)
AIO_Umbrella.optionDefensiveItemsAlly = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "0.3 Cast defensive items on allies {{deff}}", false)
AIO_Umbrella.optionDefensiveItemsSaver = Menu.AddOptionBool({ "All In One", "2. Item Usage", "2. Defensive Items" }, "0.4 Advanced lotus/glimmer ally saving {{deff}}", false)

-- Hero Menu
	-- STR
AIO_Umbrella.optionHeroAxe = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Axe" }, "Axe Combo", false)
AIO_Umbrella.optionHeroAxeCulling = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Axe" }, "Auto culling blade", false)
AIO_Umbrella.optionHeroAxeJump = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Axe" }, "Axe Jump Style", { 'blink target', 'blink best position' }, 0, 1, 1)
AIO_Umbrella.optionHeroAxeForceBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Axe" }, "Force blink", false)
AIO_Umbrella.optionHeroAxeForceBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Axe" }, "Force Blink Check Range", 150, 750, 50)
AIO_Umbrella.optionHeroCentaur = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Centaur" }, "0. Centaur combo", false)
AIO_Umbrella.optionHeroCentaurJump = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Centaur" }, "1. Centaur jump style", { 'blink target', 'blink best position' }, 0, 1, 1)
AIO_Umbrella.optionHeroCentaurForceBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Centaur" }, "2. Force blink {{centaur}}", false)
AIO_Umbrella.optionHeroCentaurForceBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Centaur" }, "2.1 Force blink check range {{centaur}}", 150, 750, 50)
AIO_Umbrella.optionHeroMagnus = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0. Magnus combo", false)
AIO_Umbrella.optionHeroMagnusAutoUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur", "1. Auto reverse polarity" }, "0. Enable {{magnus polarity}}", false)
AIO_Umbrella.optionHeroMagnusAutoUltSkewer = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur", "1. Auto reverse polarity" }, "1. Use skewer to initiate {{magnus polarity}}", false)
AIO_Umbrella.optionHeroMagnusAutoUltCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur", "1. Auto reverse polarity" }, "2. Min. enemies to hit {{magnus polarity}}", 1, 5, 1)
AIO_Umbrella.optionHeroMagnusAutoUltRefresher = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur", "1. Auto reverse polarity" }, "3. Use refresher {{magnus polarity}}", false)
AIO_Umbrella.optionHeroMagnusAutoEmpower = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "2. Auto empower", false)
AIO_Umbrella.optionHeroMagnusSkewerCombo = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur", "3. Skewer combo" }, "0. Enable {{magnus skewer combo}}", false)
AIO_Umbrella.optionHeroMagnusSkewerComboKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur", "3. Skewer combo" }, "1. Skewer combo key {{magnus skewer combo}}", Enum.ButtonCode.KEY_P) AIO_Umbrella.optionHeroMagnusJump = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.1 Jump style {{magnus combo}}", { 'blink target', 'blink best position' }, 0, 1, 1)
AIO_Umbrella.optionHeroMagnusInitiateSkewer = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.2 Initiate with skewer {{magnus combo}}", false)
AIO_Umbrella.optionHeroMagnusSkewerInCombo = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.3 Use skewer in full RP combo {{magnus combo}}", false)
AIO_Umbrella.optionHeroMagnusReturn = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.4 Skewer direction {{magnus combo}}", { 'origin', 'cursor' }, 0, 1, 1)
AIO_Umbrella.optionHeroMagnusShockwaveInCombo = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.5 Use shockwave in combo {{magnus combo}}", false)
AIO_Umbrella.optionHeroMagnusComboRefresher = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.6 Use refresher in RP combo {{magnus combo}}", false)
AIO_Umbrella.optionHeroMagnuscomboKeyAltSkewer = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.7 Alt key for skewer combo {{magnus combo}}", Enum.ButtonCode.KEY_LALT)
AIO_Umbrella.optionHeroMagnuscomboKeyAltRP = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Magnataur" }, "0.8 Alt key for full RP combo {{magnus combo}}", Enum.ButtonCode.KEY_LCONTROL)
AIO_Umbrella.optionHeroClock = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Clockwerk" }, "0. Clockwerk combo", false)
AIO_Umbrella.optionHeroClockDrawIndicator = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Clockwerk" }, "1. Draw hookshot indicator", false)
AIO_Umbrella.optionHeroHuskar = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Huskar" }, "0. Huskar Combo", false)
AIO_Umbrella.optionHeroHuskarHarassKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Huskar" }, "0.1 harass key {{huskar}}", Enum.ButtonCode.KEY_P) AIO_Umbrella.optionHeroHuskarInnerVit = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Huskar" }, "1. Inner vitality usage", { 'Off', 'always in combo', 'below hp treshold' }, 0, 2, 1)
AIO_Umbrella.optionHeroHuskarUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Huskar" }, "2. Use life break in combo", false)
AIO_Umbrella.optionHeroHuskarAutoVit = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Huskar" }, "3. Auto inner vitality", false)
AIO_Umbrella.optionHeroHuskarAutoVitAlly = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Huskar" }, "3.1 Inner vitality on allies", false)
AIO_Umbrella.optionHeroHuskarHPThreshold = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Huskar" }, "3.2 Inner vitality hp treshold", 10, 70, 5)
AIO_Umbrella.optionHeroTiny = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", }, "Tiny", false)
AIO_Umbrella.optionHeroTimber = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "0. Enable {{timber}}", false)
AIO_Umbrella.optionHeroTimberPredict = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "1. Use prediction for timberchain", false)
AIO_Umbrella.optionHeroTimberWhirling = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "2. Auto use whirling death", { 'Off', 'only in combo', 'always' }, 0, 2, 1)
AIO_Umbrella.optionHeroTimberUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "3. Use chakram", false)
AIO_Umbrella.optionHeroTimberUltTiming = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "3.1 Chakram callback timing", { '0.5 sec', '1.0 sec', '1.5 sec', '2.0 sec', '2.5 sec', '3.0 sec', '3.5 sec', '4.0 sec', '4.5 sec', '5.0 sec' }, 1, 10, 1)
AIO_Umbrella.optionHeroTimberBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "4. Use blink {{timber}}", false)
AIO_Umbrella.optionHeroTimberPanicKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "5. Panic Key {{timber}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroTimberPanicDir = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "6. panic direction {{timber}}", { 'fountain', 'furthest away', 'cursor' }, 0, 2, 1)
AIO_Umbrella.optionHeroTimberFastMoveKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Timbersaw" }, "7. Fast Move Key", Enum.ButtonCode.KEY_I)
AIO_Umbrella.optionHeroUrsa = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Ursa" }, "0. Ursa Combo", false)
AIO_Umbrella.optionHeroUrsaEnrageCombo = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Ursa" }, "1. Use ult in combo {{ursa}}", false)
AIO_Umbrella.optionHeroUrsaEnrage = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Ursa" }, "2. Auto use enrage", false)
AIO_Umbrella.optionHeroUrsaEnrageHP = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Ursa" }, "2.1 Enrage hp treshold", 5, 75, 5)
AIO_Umbrella.optionHeroUrsaEnrageEnemies = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Ursa" }, "2.2 Min. enemies around", 1, 5, 1)
AIO_Umbrella.optionHeroLegion = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Legion Commander" }, "0. Legion Commander combo", false)
AIO_Umbrella.optionHeroLegionAutoSave = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Legion Commander" }, "1. Auto save allies {{legion}}", false)
AIO_Umbrella.optionHeroLegionBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Legion Commander" }, "2. Min. blink range {{legion}}", 150, 500, 25)
AIO_Umbrella.optionHeroSlardar = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Slardar" }, "Slardar Combo", false)
AIO_Umbrella.optionHeroSlardarStyle = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Slardar" }, "Slardar Jump Style", { 'blink target', 'blink best position' }, 0, 1, 1)
AIO_Umbrella.optionHeroSven = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", }, "Sven", false)
AIO_Umbrella.optionHeroNS = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Nightstalker" }, "1. NS Combo", false)
AIO_Umbrella.optionHeroNSBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Nightstalker" }, "2. Use blink in combo {{NS}}", false)
AIO_Umbrella.optionHeroCK = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Chaos Knight" }, "1. CK Combo", false)
AIO_Umbrella.optionHeroCKBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Chaos Knight" }, "2. Use blink in combo {{CK}}", false)
AIO_Umbrella.optionHeroCKUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Chaos Knight" }, "3. Use ult in combo {{CK}}", false)
AIO_Umbrella.optionHeroCKUltTrigger = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Chaos Knight" }, "3.1 Min. range to enemy to trigger ult {{CK}}", 200, 1500, 100)
AIO_Umbrella.optionHeroKunkkaShip = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Kunkka Ghostship Helper" }, "1. Ghostship combo", false)
AIO_Umbrella.optionHeroKunkkaShipKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Kunkka Ghostship Helper" }, "2. Kunkka ghost ship key {{kunkka}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroUndying = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Undying" }, "1. Undying Combo", false)
AIO_Umbrella.optionHeroUndyingBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Undying" }, "2. Use blink in combo {{Undying}}", false)
AIO_Umbrella.optionHeroUndyingSoulTreshold = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Undying" }, "3.1 Soulrip heal treshold", 10, 65, 5)
AIO_Umbrella.optionHeroUndyingSoulCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Undying" }, "3.2 Min. soulrip units around", 1, 10, 1)
AIO_Umbrella.optionHeroUndyingUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Undying" }, "4.1 Use ult in combo {{Undying}}", false)
AIO_Umbrella.optionHeroUndyingUltCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Undying" }, "4.2 Min. enemy heroes around {{Undying}}", 1, 5, 1)
AIO_Umbrella.optionHeroUndyingSoulKS = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Undying" }, "5. Use soulrip for kill stealing {{Undying}}", false)
AIO_Umbrella.optionHeroPudge = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge" }, "1. Pudge Combo", false)
AIO_Umbrella.optionHeroPudgeBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge" }, "2. Use blink for initiation {{pudge}}", false)
AIO_Umbrella.optionHeroPudgeBlinkMinRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge" }, "2.1 Blink min. range {{pudge}}", 250, 1000, 50)
AIO_Umbrella.optionHeroPudgeStaff = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge" }, "3. Use force staff for initiation {{pudge}}", false)
AIO_Umbrella.optionHeroPudgeHookCombo = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge" }, "4. Use hook in combo {{pudge}}", false)
AIO_Umbrella.optionHeroPudgeHookComboMaxRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge" }, "4.1 Max hook range in combo {{pudge}}", 250, 1000, 50)
AIO_Umbrella.optionHeroPudgeHook = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "1. Enable hook helper {{pudge hook}}", false)
AIO_Umbrella.optionHeroPudgeHookKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "1.1 Hook helper key {{pudge hook}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroPudgeHookAcquiRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "1.2 Target acquisition range {{pudge hook}}", 250, 1000, 50)
AIO_Umbrella.optionHeroPudgeHookAllies = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "2.1 Also target allies {{pudge hook}}", false)
AIO_Umbrella.optionHeroPudgeHookStaff = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "2.2 Use force staff to avoid collision {{pudge hook}}", false)
AIO_Umbrella.optionHeroPudgeHookUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "3. Use dismember {{pudge hook}}", false)
AIO_Umbrella.optionHeroPudgeHookRot = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "4. Use rot {{pudge hook}}", false)
AIO_Umbrella.optionHeroPudgeHookItems = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "5. Use offensive items {{pudge hook}}", false)
AIO_Umbrella.optionHeroPudgeHookJuke = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "5. Hook helper" }, "6. Anti-juke-offset {{pudge hook}}", 0, 12, 2)
AIO_Umbrella.optionHeroPudgeFarm = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "6. Misc" }, "1. Rot farm {{pudge misc}}", false)
AIO_Umbrella.optionHeroPudgeFarmHP = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "6. Misc" }, "1.1 Rot farm HP treshold {{pudge misc}}", 5, 75, 5)
AIO_Umbrella.optionHeroPudgeSuicide = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "1. Strength heroes", "Pudge", "6. Misc" }, "2. Auto suicide {{pudge misc}}", false)

-- AGI
AIO_Umbrella.optionHeroEmber = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Ember" }, "Ember Combo", false)
AIO_Umbrella.optionHeroEmberUlt = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Ember" }, "Ember Ult Usage in Combo", { 'use all charges', 'use one charge' }, 0, 1, 1)
AIO_Umbrella.optionHeroTA = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Templar Assassin" }, "0. TA Combo", false)
AIO_Umbrella.optionHeroTABlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Templar Assassin" }, "1. Use blink in Combo {{TA}}", false)
AIO_Umbrella.optionHeroTAHarassKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Templar Assassin" }, "4. psi blades harass key {{TA}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroTAHarass = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Templar Assassin" }, "2. Harass with psi blades {{TA}}", false)
AIO_Umbrella.optionHeroTAHarassRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Templar Assassin" }, "3. Harass search range {{TA}}",50,500,50)
AIO_Umbrella.optionHeroClinkz = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Clinkz" }, "0. Clinkz Combo", false)
AIO_Umbrella.optionHeroClinkzUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Clinkz" }, "1. Auto Ultimate  {{clinkz}}", false)
AIO_Umbrella.optionHeroClinkzHarass = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Clinkz" }, "2. Harass with searing", false)
AIO_Umbrella.optionHeroClinkzHarassKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Clinkz" }, "2.1 Harass key {{clinkz}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroArcWarden = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "1.0 Arc Warden Combo", false)
AIO_Umbrella.optionHeroArcWardenMagnetic = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "1.1 Use magnetic field", false)
AIO_Umbrella.optionHeroArcWardenSpark = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "1.2 Use spark", false)
AIO_Umbrella.optionHeroArcWardenFlux = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "1.3 Use flux", false)
AIO_Umbrella.optionArcWardenComboUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "1.4 Cast ult in combo {{arc warden}}", false)
AIO_Umbrella.optionArcWardenTempestParticle = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "1.5 Draw particle on locked enemy", false)
AIO_Umbrella.optionArcWardenTempestKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "2.1 Clone combo key", Enum.ButtonCode.KEY_O)
AIO_Umbrella.optionArcWardenPushKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "2.2 Clone push key", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionArcWardenPushTPRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden" }, "2.3 Min. TP range", 500, 3500, 250)
AIO_Umbrella.optionHeroArcWardenPanelKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden", "4. Drawings" }, "Toggle key {{arc panel}}", Enum.ButtonCode.KEY_0)
AIO_Umbrella.optionHeroArcWardenPanelMove = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden", "4. Drawings" }, "Panel moveable {{arc panel}}", false)
AIO_Umbrella.optionArcWardenMainBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden", "3. Main hero blink usage" }, "1. Use blink on main {{arc warden blink}}", false)
AIO_Umbrella.optionArcWardenBlinkTrigger = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden", "3. Main hero blink usage" }, "2. Blink trigger range {{arc warden blink}}", 100, 800, 50)
AIO_Umbrella.optionArcWardenBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Arc Warden", "3. Main hero blink usage" }, "3. Blink jump distance {{arc warden blink}}", 100, 600, 50)
AIO_Umbrella.optionHeroMorphling = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling" }, "0. Morphling Combo", false)
AIO_Umbrella.optionHeroMorphlingKill = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling" }, "1. Draw kill indicator {{morph}}", false)
AIO_Umbrella.optionHeroMorphHPBalance = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling" }, "2. Balance HP {{morph}}", false)
AIO_Umbrella.optionHeroMorphHPBalanceDeviation = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling" }, "2.1 Balance deviation {{morph}}", 50, 250, 25)
AIO_Umbrella.optionHeroMorphDrawBoard = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling", "3. Balance Board" }, "0. Draw balace board {{morph}}", false)
AIO_Umbrella.optionHeroMorphBoardToggleKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling", "3. Balance Board" }, "1. Toggle Key for balance board", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroMorphDrawBoardXPos = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling", "3. Balance Board" }, "2. X-Pos adjustment {{morph}}", -500, 500, 10)
AIO_Umbrella.optionHeroMorphDrawBoardYPos = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling", "3. Balance Board" }, "3. Y-Pos adjustment {{morph}}", -500, 500, 10)
AIO_Umbrella.optionHeroMorphReplicate = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling" }, "4. Replicate combo", false)
AIO_Umbrella.optionHeroMorphReplicateBack = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling" }, "4.1 Auto replicate back", false)
AIO_Umbrella.optionHeroMorphReplicateBackHP = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Morphling" }, "4.2 Replicate back HP treshold", 5, 50, 5)
AIO_Umbrella.optionHeroAntiMage = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Anti-Mage" }, "1. Anti-Mage Combo", false)
AIO_Umbrella.optionHeroAntiMageBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Anti-Mage" }, "2. Use Anti-Mage blink in combo", false)
AIO_Umbrella.optionHeroAntiMageVoid = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Anti-Mage" }, "3. Auto use mana void if target killable", false)
AIO_Umbrella.optionHeroPA = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Phantom Assassin" }, "1. PA Combo", false)
AIO_Umbrella.optionHeroPADagger = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Phantom Assassin", "2. Auto dagger" }, "1. Auto use dagger", false)
AIO_Umbrella.optionHeroPADaggerThreshold = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Phantom Assassin", "2. Auto dagger" }, "4. Mana treshold {{PA}}", 20, 80, 10)
AIO_Umbrella.optionHeroPADaggerToggleKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Phantom Assassin", "2. Auto dagger" }, "2. Toggle Key {{PA}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroPADaggerDraw = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Phantom Assassin", "2. Auto dagger" }, "3. draw toggle state {{PA}}", false)
AIO_Umbrella.optionHeroNyx = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Nyx Assassin" }, "1. Nyx Combo", false)
AIO_Umbrella.optionHeroNyxBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Nyx Assassin" }, "2. Use blink in combo {{Nyx}}", false)
AIO_Umbrella.optionHeroSF = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Shadow Fiend" }, "0. Enable {{SF}}", false)
AIO_Umbrella.optionHeroSFEulCombo = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Shadow Fiend" }, "1. Eul-Requiem-Combo key {{SF}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroSFDrawReqDMG = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Shadow Fiend" }, "1.1 Draw ult damage {{SF}}", false)
AIO_Umbrella.optionHeroSFBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Shadow Fiend" }, "2. Use blink in combo {{SF}}", false)
AIO_Umbrella.optionHeroSFBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Shadow Fiend" }, "2.1 Blink range to enemy {{SF}}", 200, 600, 50)
AIO_Umbrella.optionHeroSFComboRaze = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Shadow Fiend" }, "4. Use raze in combo {{SF}}", false)
AIO_Umbrella.optionHeroSFDrawRazeCircle = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Shadow Fiend" }, "5. Draw raze AoEs {{SF}}", false)
AIO_Umbrella.optionHeroViper = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "1. Viper Combo", false)
AIO_Umbrella.optionHeroViperBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "2. Use blink in combo {{viper}}", false)
AIO_Umbrella.optionHeroViperBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "2.1 Blink range to enemy {{viper}}", 100, 550, 50)
AIO_Umbrella.optionHeroViperHarass = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "3. Orb harass {{viper}}", false)
AIO_Umbrella.optionHeroViperHarassKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "3.1 Orb harass key {{viper}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroViperFarm = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "4. Nethertoxin farm helper {{viper}}", false)
AIO_Umbrella.optionHeroViperFarmMana = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "4.1 Nethertoxin mana threshold {{viper}}", 10, 80, 10)
AIO_Umbrella.optionHeroViperFarmCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "4.2 Nethertoxin creep count {{viper}}", 1, 5, 1)
AIO_Umbrella.optionHeroViperForceUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Viper" }, "1.1 Force movement to ult range", false)
AIO_Umbrella.optionHeroVS = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Vengeful Spirit" }, "1. Vengeful Combo", false)
AIO_Umbrella.optionHeroVSBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Vengeful Spirit" }, "2. Use blink in combo {{vengeful}}", false)
AIO_Umbrella.optionHeroVSBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Vengeful Spirit" }, "2.1 Blink range to enemy {{vengeful}}", 100, 400, 50)
AIO_Umbrella.optionHeroVSStun = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "2. Agility heroes", "Vengeful Spirit" }, "3. Force stun first", false)

-- INT
AIO_Umbrella.optionHeroSky = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Skywrath Mage" }, "0. Enable {{sky}}", false)
AIO_Umbrella.optionHeroSkyBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Skywrath Mage" }, "0.1 Use blink in combo {{sky}}", false)
AIO_Umbrella.optionHeroSkyBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Skywrath Mage" }, "0.2 blink distance to enemy {{sky}}", 200, 750, 50)
AIO_Umbrella.optionHeroSkyDrawDMG = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Skywrath Mage" }, "1. draw dmg indicators {{sky}}", false)
AIO_Umbrella.optionHeroSkyHarass = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Skywrath Mage" }, "2. use bolt to harass {{sky}}", false)
AIO_Umbrella.optionHeroSkyHarassKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Skywrath Mage" }, "2.1 harass key {{sky}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroSkyStyle = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Skywrath Mage" }, "3. combo style {{sky}}", { 'max damage', 'mana saving' }, 0, 1, 1)
AIO_Umbrella.optionHeroNecro = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos" }, "0. Enable {{necro}}", false)
AIO_Umbrella.optionHeroNecroComboScythe = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos" }, "0.1 use ult in combo {{necro}}", { 'Off', 'always w/o HP check', 'only if killable' }, 0, 2, 1)
AIO_Umbrella.optionHeroNecroBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos" }, "0.2 use blink in combo {{necro}}", false)
AIO_Umbrella.optionHeroNecroBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos" }, "0.3 blink distance to enemy {{necro}}", 200, 600, 50)
AIO_Umbrella.optionHeroNecroDrawDMG = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos" }, "1. draw dmg indicators {{necro}}", false)
AIO_Umbrella.optionHeroNecroScythe = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos" }, "2. auto scythe {{necro}}", false)
AIO_Umbrella.optionHeroNecroPulse = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse" }, "0. enabled {{pulse}}", false)
AIO_Umbrella.optionHeroNecroPulseCreeps = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "1. pulse farm" }, "1. enabled {{pulse}}", false)
AIO_Umbrella.optionHeroNecroPulseCreepsMana = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "1. pulse farm" }, "1.1 mana treshold {{pulse}}", 10, 90, 5)
AIO_Umbrella.optionHeroNecroPulseCreepsCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "1. pulse farm" }, "1.2 creep count {{pulse}}", 1, 5, 1)
AIO_Umbrella.optionHeroNecroShroudFarm = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "1. pulse farm" }, "2. auto shroud regen {{pulse}}", false)
AIO_Umbrella.optionHeroNecroShroudFarmCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "1. pulse farm" }, "2.1 stack count {{pulse}}", 1, 15, 1)
AIO_Umbrella.optionHeroNecroShroudFarmSave = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "1. pulse farm" }, "2.2 save activation {{pulse}}", false)
AIO_Umbrella.optionHeroNecroShroudFarmTreshold = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "1. pulse farm" }, "2.3 treshold {{pulse}}", 5, 75, 5)
AIO_Umbrella.optionHeroNecroPulseHeroes = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "2. pulse harass" }, "1. enabled {{pulse harass}}", false)
AIO_Umbrella.optionHeroNecroPulseHeroesMana = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "3. auto pulse", "2. pulse harass" }, "2. mana treshold {{pulse harass}}", 5, 85, 5)
AIO_Umbrella.optionHeroNecroShroudPanic = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "4. panic mode" }, "0. enabled {{necro panic}}", false)
AIO_Umbrella.optionHeroNecroShroudPanicHP = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Necrophos", "4. panic mode" }, "1. HP treshold {{necro panic}}", 5, 75, 5)
AIO_Umbrella.optionHeroOD = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer" }, "0. Enable {{OD}}", false)
AIO_Umbrella.optionHeroODBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer" }, "1. Use blink in combo {{OD}}", false)
AIO_Umbrella.optionHeroODBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer" }, "1.1 Blink range to enemy {{OD}}", 200, 600, 50)
AIO_Umbrella.optionHeroODKillsteal = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "2. Kill steal" }, "0. Enable {{OD kill}}", false)
AIO_Umbrella.optionHeroODKillstealOrb = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "2. Kill steal" }, "1. Use arcane orb to KS {{OD kill}}", false)
AIO_Umbrella.optionHeroODKillstealPrison = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "2. Kill steal" }, "2. Use astral prison to KS {{OD kill}}", false)
AIO_Umbrella.optionHeroODKillstealEclipse = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "2. Kill steal" }, "3. Use sanitys eclipse to KS {{OD kill}}", false)
AIO_Umbrella.optionHeroODKillstealEclipseHittable = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "2. Kill steal" }, "3.1 Min. enemies to hit {{OD kill}}", 1, 5, 1)
AIO_Umbrella.optionHeroODKillstealEclipseKillable = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "2. Kill steal" }, "3.2 Min. enemies to kill {{OD kill}}", 1, 5, 1)
AIO_Umbrella.optionHeroODAutoPrisonDefend = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer" }, "3. Auto disable with prison {{OD}}", false)
AIO_Umbrella.optionHeroODAutoPrisonSave = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "5. Auto save with prison" }, "0. enable {{OD prison save}}", false)
AIO_Umbrella.optionHeroODAutoPrisonSaveSelf = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "5. Auto save with prison" }, "1. Self save {{OD prison save}}", false)
AIO_Umbrella.optionHeroODAutoPrisonSaveAlly = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "5. Auto save with prison" }, "2. Ally save {{OD prison save}}", false)
AIO_Umbrella.optionHeroODAutoPrisonHP = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Outworld Devourer", "5. Auto save with prison" }, "3. HP treshold {{OD prison save}}", 5, 30, 5)
AIO_Umbrella.optionHeroSilencer = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Silencer" }, "0. Enable {{Silencer}}", false)
AIO_Umbrella.optionHeroSilencerBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Silencer" }, "1. Use blink in combo {{Silencer}}", false)
AIO_Umbrella.optionHeroSilencerBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Silencer" }, "1.1 Blink range to enemy {{Silencer}}", 200, 600, 50)
AIO_Umbrella.optionHeroSilencerHarass = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Silencer" }, "3. use glaives to harass {{Silencer}}", false)
AIO_Umbrella.optionHeroSilencerHarassKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Silencer" }, "3.1 harass key {{Silencer}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroSilencerGlobal = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Silencer" }, "4. auto interrupt with global {{Silencer}}", false)
AIO_Umbrella.optionHeroDazzle = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle" }, "0. Enable {{dazzle}}", false)
AIO_Umbrella.optionHeroDazzleAutoGrave = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle", "1. Auto grave" }, "0. Auto use grave {{dazzle}}", false)
AIO_Umbrella.optionHeroDazzleHP = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle", "1. Auto grave" }, "1. HP treshold {{dazzle}}", 5, 50, 5)
AIO_Umbrella.optionHeroDazzleAutoWeave = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle", "2. Auto weave" }, "0. Auto use weave {{dazzle}}", false)
AIO_Umbrella.optionHeroDazzleAutoWeaveCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle", "2. Auto weave" }, "1. Min. enemies to hit {{dazzle}}", 1, 5, 1)
AIO_Umbrella.optionHeroDazzleAutoHeal = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle", "3. Auto heal" }, "0. Auto use heal {{dazzle}}", false)
AIO_Umbrella.optionHeroDazzleAutoHealHP = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle", "3. Auto heal" }, "1. HP threshold {{dazzle}}", 5, 75, 5)
AIO_Umbrella.optionHeroDazzleHealKS = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dazzle" }, "4. Shadow wave kill steal {{dazzle}}", false)
AIO_Umbrella.optionHeroWindrunner = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Windrunner" }, "0. Enable {{windrunner}}", false)
AIO_Umbrella.optionHeroWindrunnerPredict = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Windrunner" }, "1. Use prediction for shackleshot", false)
AIO_Umbrella.optionHeroWindrunnerUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Windrunner" }, "3. Auto use ultimate {{windrunner}}", false)
AIO_Umbrella.optionHeroWindrunnerWind = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Windrunner" }, "4. Auto use windrun", { 'Off' }, 0, 5, 1)
AIO_Umbrella.optionHeroWindrunnerBlinkShackle = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Windrunner" }, "2. Use Blink dagger {{windrunner}}", false)
AIO_Umbrella.optionWindrunnerDrawIndicator = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Windrunner" }, "5. Draw shackle indicator {{windrunner}}", false)
AIO_Umbrella.optionHeroWindrunnerBranchShackle = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Windrunner" }, "6. Branch-blink-shackle {{windrunner}}", false)
AIO_Umbrella.optionHeroQoP = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Queen of Pain" }, "Queen of Pain Combo", false)
AIO_Umbrella.optionHeroQoPblink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Queen of Pain" }, "Use blink in combo {{QoP}}", false)
AIO_Umbrella.optionHeroQoPAutoUlt = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Queen of Pain" }, "Auto Cast Ult {{QoP}}", { 'OFF', 'only with aghanims', 'ALWAYS' }, 0, 2, 1)
AIO_Umbrella.optionHeroVisage = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Visage" }, "0. Visage Combo", false)
AIO_Umbrella.optionHeroVisageDMGStacks = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Visage" }, "1. Familiar attacks before stun", 1, 10, 1)
AIO_Umbrella.optionHeroVisageInstStunKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Visage" }, "2. Instant stun key", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroVisageKS = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Visage" }, "3. Soul assumption kill steal", false)
AIO_Umbrella.optionHeroVisageFamiliarSave = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Visage" }, "4. Auto save familiars", false)
AIO_Umbrella.optionHeroVisageFamiliarCancel = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Visage" }, "5. Auto cancel channelling", false)
AIO_Umbrella.optionHeroVisagePanicKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Visage" }, "6. Panic key", Enum.ButtonCode.KEY_O)
AIO_Umbrella.optionHeroPuck = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "1. Puck Combo", false)
AIO_Umbrella.optionHeroPuckJump = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "1.1 Puck Jump Style", { 'blink target', 'blink best position' }, 0, 1, 1)
AIO_Umbrella.optionHeroPuckPanic = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "2. Puck Panic", false)
AIO_Umbrella.optionHeroPuckPanicKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "2.3 Puck Panic Key", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroPuckPanicDirection = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "2.1 Puck Panic Direction", { 'fountain', 'cursor' }, 0, 1, 1)
AIO_Umbrella.optionHeroPuckComboAltKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "1.3 Puck Alt Key", Enum.ButtonCode.KEY_LCONTROL)
AIO_Umbrella.optionHeroPuckDefend = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "2.2 Auto defend {{puck}}", false)
AIO_Umbrella.optionHeroPuckOrbInit = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Puck" }, "1.2 Orb Initiation {{puck}}", false)
AIO_Umbrella.optionHeroProphet = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Natures Prophet" }, "Prophet Helper", false)
AIO_Umbrella.optionHeroProphetToggleKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Natures Prophet" }, "Toggle Key {{prophet}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionProphetDrawToggle = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Natures Prophet", "Drawings" }, "1. Draw Toggle Notification {{prophet}}", false)
AIO_Umbrella.optionProphetDrawKS = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Natures Prophet", "Drawings" }, "2. Draw KS Notification {{prophet}}", false)
AIO_Umbrella.optionProphetDrawKSminimap = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Natures Prophet", "Drawings" }, "3. Draw KS Target on Minimap {{prophet}}", false)
AIO_Umbrella.optionHeroInvoker = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1. Invoker Combo", false)
AIO_Umbrella.optionHeroInvokerBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.0 Use blink in combo", false)
AIO_Umbrella.optionHeroInvokerSwitch = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.2 Auto switch dynamic mode", false)
AIO_Umbrella.optionHeroInvokerForceDynamic = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.3 Force dynamic mode", false)
AIO_Umbrella.optionHeroInvokerAltKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.6 Invoker Alt Key", Enum.ButtonCode.KEY_LCONTROL)
AIO_Umbrella.optionHeroInvokerCustom1Key = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.7 Select custom combo 1", Enum.ButtonCode.KEY_8)
AIO_Umbrella.optionHeroInvokerCustom2Key = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.8 Select custom combo 2", Enum.ButtonCode.KEY_9)
AIO_Umbrella.optionHeroInvokerCustom3Key = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.9 Select custom combo 3", Enum.ButtonCode.KEY_0)
AIO_Umbrella.optionHeroInvokerToggleKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel" }, "Panel toggle key {{invoker}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroInvokerSkillshotStyle = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.1 Skillshot Style {{invoker}}", { 'prediction', 'cursor' }, 0, 1, 1)
AIO_Umbrella.optionHeroInvokerTornadoItems = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.4 Activate items before tornado", false)
AIO_Umbrella.optionHeroInvokerDisableBuildIn = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "1. General" }, "1.5 Disable hake build-in invo features", false)
AIO_Umbrella.optionHeroInvokerDisableBuildInGetOption = Menu.GetOption({ "Hero Specific", "Invoker" }, "Euls/Tornado Combo Helper")
AIO_Umbrella.optionHeroInvokerAutoInvoke = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel" }, "4. Auto Invoke", false)
AIO_Umbrella.optionHeroInvokerPanelCD = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel" }, "3. Show skill cooldowns {{invoker}}", { 'dont show', 'only longest', 'all cooldowns' }, 0, 2, 1)
AIO_Umbrella.optionHeroInvokerPanelXPos = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel" }, "1. X-position {{invoker}}", -200, 500, 10)
AIO_Umbrella.optionHeroInvokerPanelYPos = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel" }, "2. Y-position {{invoker}}", -500, 500, 10)
AIO_Umbrella.invokerPanelSizeOption = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel" }, "0. Panel Size {{invoker}}", 20, 40, 2)
AIO_Umbrella.optionHeroInvokerPanelShort = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel", "5. Custom indicator" }, "Enable {{invoker custom}}", false)
AIO_Umbrella.optionHeroInvokerPanelShortXPos = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel", "5. Custom indicator" }, "X-position short {{invoker custom}}", -700, 700, 20)
AIO_Umbrella.optionHeroInvokerPanelShortYPos = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "2. Panel", "5. Custom indicator" }, "Y-position short {{invoker custom}}", -700, 700, 20)
AIO_Umbrella.optionHeroInvokerIcewallEnable = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "3. Fast Skills" }, "Fast ice wall {{invoker ice}}", false)
AIO_Umbrella.optionHeroInvokerIcewallKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "3. Fast Skills" }, "Fast ice wall key {{invoker ice}}", Enum.ButtonCode.KEY_O)
AIO_Umbrella.optionHeroInvokerAlacrityEnable = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "3. Fast Skills" }, "Fast alacrity {{invoker ala}}", false)
AIO_Umbrella.optionHeroInvokerAlacrityKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "3. Fast Skills" }, "Fast alacrity key {{invoker ala}}", Enum.ButtonCode.KEY_I)
AIO_Umbrella.optionHeroInvokerTornadoEnable = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "3. Fast Skills" }, "Fast tornado {{invoker nado}}", false)
AIO_Umbrella.optionHeroInvokerTornadoKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "3. Fast Skills" }, "Fast tornado key {{invoker nado}}", Enum.ButtonCode.KEY_J)
AIO_Umbrella.optionHeroInvokerTornadoStyle = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "3. Fast Skills" }, "Fast tornado style {{invoker nado}}", { 'enemy prediction', 'mouse cursor' }, 0, 1, 1)
AIO_Umbrella.optionHeroInvokerCancelEnable = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "4. Cancel Channelling abilities" }, "0. Enable {{invoker chanel}}", false)
AIO_Umbrella.optionHeroInvokerCancelTPFog = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "4. Cancel Channelling abilities" }, "2. Auto cancel TP in Fog", false)
AIO_Umbrella.optionHeroInvokerCancelBara = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "4. Cancel Channelling abilities" }, "3. Auto cancel bara charge", false)
AIO_Umbrella.optionHeroInvokerCancelChannelling = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "4. Cancel Channelling abilities" }, "1. Auto cancel channelling spells", false)
AIO_Umbrella.optionHeroInvokerInstanceHelper = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "5. Instance helper" }, "auto instance switch", false)
AIO_Umbrella.optionHeroInvokerInstanceDelay = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "5. Instance helper" }, "delay between instance switch", { '0.25', '0.50', '0.75', '1.00', '1.25', '1.50', '1.75', '2.00', '2.25', '2.50', '2.75', '3.00' }, 1, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo1Skill1 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 1" }, "C1 Skill 1", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo1Skill2 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 1" }, "C1 Skill 2", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo1Skill3 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 1" }, "C1 Skill 3", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo1Skill4 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 1" }, "C1 Skill 4", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo1Skill5 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 1" }, "C1 Skill 5", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo1Skill6 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 1" }, "C1 Skill 6", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo2Skill1 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 2" }, "C2 Skill 1", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo2Skill2 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 2" }, "C2 Skill 2", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo2Skill3 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 2" }, "C2 Skill 3", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo2Skill4 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 2" }, "C2 Skill 4", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo2Skill5 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 2" }, "C2 Skill 5", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo2Skill6 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 2" }, "C2 Skill 6", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo3Skill1 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 3" }, "C3 Skill 1", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo3Skill2 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 3" }, "C3 Skill 2", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo3Skill3 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 3" }, "C3 Skill 3", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos' }, 0, 11, 1)
AIO_Umbrella.optionHeroInvokerCombo3Skill4 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 3" }, "C3 Skill 4", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo3Skill5 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 3" }, "C3 Skill 5", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerCombo3Skill6 = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "6. Custom Combo", "Combo 3" }, "C3 Skill 6", { 'none', 'tornado', 'emp', 'chaos_meteor', 'deafening_blast', 'sun_strike', 'ice_wall', 'cold_snap', 'forge_spirit', 'alacrity', 'euls', 'atos', 'refresher' }, 0, 12, 1)
AIO_Umbrella.optionHeroInvokerDynCS = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "1. invoker_cold_snap {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynFS = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "2. invoker_forge_spirit {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynAL = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "3. invoker_alacrity {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynIW = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "4. invoker_ice_wall {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynTO = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "5. invoker_tornado {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynEMP = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "6. invoker_emp {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynSS = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "7. invoker_sun_strike {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynCM = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "8. invoker_chaos_meteor {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynDB = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "9. invoker_deafening_blast {{invoker dyn}}", { 'will not be invoked' }, 0, 9, 1)
AIO_Umbrella.optionHeroInvokerDynOrder = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "7. Dynamic Combo", }, "0. USE CUSTOM PRIORITIES {{invoker dyn}}", false)
AIO_Umbrella.invokerDisplayOption = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "8. Invoker Spell Panel" }, "Enable {{invoker spell panel}}", false)
AIO_Umbrella.invokerDisplaySizeOption = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "8. Invoker Spell Panel" }, "Cooldown Display Size", 21, 200, 5)
AIO_Umbrella.invokerDisplayY = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "8. Invoker Spell Panel" }, "Y position", -500, 500, 10)
AIO_Umbrella.invokerDisplayX = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "8. Invoker Spell Panel" }, "X position", -200, 200, 10)
AIO_Umbrella.invokerDisplaySortAbilitiesOption = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Invoker", "8. Invoker Spell Panel" }, "Sort Abilities by Name {{invoker spell panel}}", false)
AIO_Umbrella.optionHeroZuus = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "1. Zuus Combo", false)
AIO_Umbrella.optionHeroZuusFarmKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "2. arc farm key", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroZuusHarassKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "3. arc harass key", Enum.ButtonCode.KEY_O)
AIO_Umbrella.optionHeroZuusHarassMana = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "3.1 harass arc mana threshold", 10, 90, 10)
AIO_Umbrella.optionHeroZuusKillsteal = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "4. killsteal", false)
AIO_Umbrella.optionHeroZuusUltCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "4.1 wrath kill count", 1, 5, 1)
AIO_Umbrella.optionHeroZuusUltCountRefresher = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "4.2 refresher wrath kill count", 1, 5, 1)
AIO_Umbrella.optionHeroZuusBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "5. use blink in combo {{zuus}}", false)
AIO_Umbrella.optionHeroZuusRightClick = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Zuus" }, "6. use right click attacks in combo {{zuus}}", false)
AIO_Umbrella.optionHeroWillow = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dark Willow" }, "1. Dark Willow Combo", false)
AIO_Umbrella.optionHeroWillowBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dark Willow" }, "2. Use blink in combo {{Willow}}", false)
AIO_Umbrella.optionHeroWillowBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Dark Willow" }, "2.1 Blink range to enemy {{Willow}}", 100, 450, 50)
AIO_Umbrella.optionHeroOgre = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Ogre Magi" }, "1. Ogre Combo", false)
AIO_Umbrella.optionHeroOgreBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Ogre Magi" }, "2. Use blink in combo {{ogre}}", false)
AIO_Umbrella.optionHeroAA = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Ancient Apparition" }, "1. AA Combo", false)
AIO_Umbrella.optionHeroAABlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Ancient Apparition" }, "2. Use blink in combo {{AA}}", false)
AIO_Umbrella.optionHeroAABlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Ancient Apparition" }, "3. Blink distance {{AA}}", 100, 600, 50)
AIO_Umbrella.optionHeroWD = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Witch Doctor" }, "1. WD Combo", false)
AIO_Umbrella.optionHeroWDBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Witch Doctor" }, "2. Use blink in combo {{WD}}", false)
AIO_Umbrella.optionHeroWDBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Witch Doctor" }, "3. Blink distance {{WD}}", 100, 500, 50)
AIO_Umbrella.optionHeroSS = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Shadow Shaman" }, "1. Shaman Combo", false)
AIO_Umbrella.optionHeroSSBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Shadow Shaman" }, "2. Use blink in combo {{SS}}", false)
AIO_Umbrella.optionHeroSSBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Shadow Shaman" }, "3. Blink distance {{SS}}", 100, 350, 50)
AIO_Umbrella.optionHeroDP = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Death prophet" }, "1. Death Prophet Combo", false)
AIO_Umbrella.optionHeroDPBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Death prophet" }, "2. Use blink in combo {{DP}}", false)
AIO_Umbrella.optionHeroDPBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Death prophet" }, "3. Blink distance {{DP}}", 100, 550, 50)
AIO_Umbrella.optionHeroCM = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Crystal maiden" }, "1. Crystal Maiden Combo", false)
AIO_Umbrella.optionHeroCMBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Crystal maiden" }, "2. Use blink in combo {{CM}}", false)
AIO_Umbrella.optionHeroCMBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Crystal maiden" }, "3. Blink distance {{CM}}", 100, 550, 50)
AIO_Umbrella.optionHeroCMUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Crystal maiden" }, "4.0 Ult combo {{CM}}", false)
AIO_Umbrella.optionHeroCMUltMin = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Crystal maiden" }, "4.1 Min. enemies to hit with ult {{CM}}", 1, 5, 1)
AIO_Umbrella.optionHeroCMUltKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Crystal maiden" }, "4.2 Ult combo key {{CM}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroLion = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Lion" }, "1. Lion Combo", false)
AIO_Umbrella.optionHeroLionBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Lion" }, "2. Use blink in combo {{Lion}}", false)
AIO_Umbrella.optionHeroLionBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Lion" }, "3. Blink distance {{Lion}}", 100, 550, 50)
AIO_Umbrella.optionHeroPugna = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Pugna" }, "1. Pugna Combo", false)
AIO_Umbrella.optionHeroPugnaBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Pugna" }, "2. Use blink in combo {{Pugna}}", false)
AIO_Umbrella.optionHeroPugnaBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Pugna" }, "3. Blink distance {{Pugna}}", 100, 600, 50)
AIO_Umbrella.optionHeroPugnaWard = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Pugna" }, "4.0 Use ward in combo", false)
AIO_Umbrella.optionHeroPugnaWardCount = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Pugna" }, "4.1 Min. heroes in ward range", 1, 5, 1)
AIO_Umbrella.optionHeroPugnaInvis = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Pugna" }, "5. Use invis while life draining {{Pugna}}", false)
AIO_Umbrella.optionHeroTinker = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker" }, "1. Tinker Combo", false)
AIO_Umbrella.optionHeroTinkerBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker" }, "2. Use blink in combo {{tinker}}", false)
AIO_Umbrella.optionHeroTinkerBlinkRange = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker" }, "2.1 Blink distance {{tinker}}", 100, 600, 50)
AIO_Umbrella.optionHeroTinkerPushMode = Menu.AddOptionCombo({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "3. Push mode" }, "1. Tinker push mode", { 'toggle', 'pressed' }, 0, 1, 1)
AIO_Umbrella.optionHeroTinkerPushKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "3. Push mode" }, "2. Tinker push key {{tinker}}", Enum.ButtonCode.KEY_P)
AIO_Umbrella.optionHeroTinkerPushReset = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "3. Push mode" }, "3. Reset with move command", false)
AIO_Umbrella.optionHeroTinkerPushMarch = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "3. Push mode" }, "4. Max. march casts per wave", 1, 3, 1)
AIO_Umbrella.optionHeroTinkerRocket = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "4. Rocket spam" }, "1. Enable rocket spam mode {{tinker}}", false)
AIO_Umbrella.optionHeroTinkerRocketKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "4. Rocket spam" }, "2. Tinker rocket key {{tinker}}", Enum.ButtonCode.KEY_O)
AIO_Umbrella.optionHeroTinkerRocketMove = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "4. Rocket spam" }, "3. Move to cursor {{tinker rocket}}", false)
AIO_Umbrella.optionHeroTinkerRocketBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "4. Rocket spam" }, "4. Blink to cursor {{tinker rocket}}", false)
AIO_Umbrella.optionHeroTinkerRocketBlinkMin = Menu.AddOptionSlider({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "4. Rocket spam" }, "4.1 Blink minimum range {{tinker rocket}}", 200, 1000, 100)
AIO_Umbrella.optionHeroTinkerPanelKey = Menu.AddKeyOption({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "5. Tinker panel" }, "1. Panel toggle key {{tinker panel}}", Enum.ButtonCode.KEY_I)
AIO_Umbrella.optionHeroTinkerPanelMove = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "5. Tinker panel" }, "2. moveable panel", false)
AIO_Umbrella.optionHeroTinkerMiscFailUlt = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "6. Misc options" }, "1. Failswitch ult {{tinker misc}}", false)
AIO_Umbrella.optionHeroTinkerMiscFailRockets = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "6. Misc options" }, "2. Failswitch rockets", false)
AIO_Umbrella.optionHeroTinkerMiscGlimmer = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "6. Misc options" }, "3. Auto glimmer {{tinker misc}}", false)
AIO_Umbrella.optionHeroTinkerMiscBlink = Menu.AddOptionBool({ "All In One", "3. Hero Scripts", "3. Intelligence heroes", "Tinker", "6. Misc options" }, "4. Auto blink after rearm {{tinker misc}}", false)

	-- global Variables
AIO_Umbrella.IconPath = "resource/flash3/images/small_boost_icons/"
AIO_Umbrella.font = Renderer.LoadFont("Tahoma", 22, Enum.FontWeight.EXTRABOLD)
AIO_Umbrella.invokerDisplayspellIconPath = "resource/flash3/images/spellicons/"
AIO_Umbrella.skywrathFont = Renderer.LoadFont("Tahoma", 12, Enum.FontWeight.EXTRABOLD)
AIO_Umbrella.arcWardenfont = Renderer.LoadFont("Arial", 18, Enum.FontWeight.EXTRABOLD)
AIO_Umbrella.heroIconPath = "resource/flash3/images/heroes/"
AIO_Umbrella.itemIconPath = "resource/flash3/images/items/"

AIO_Umbrella.LockedTarget = nil
AIO_Umbrella.myUnitName = nil
AIO_Umbrella.lastCastTime = 0
AIO_Umbrella.lastCastTime2 = 0
AIO_Umbrella.lastCastTime3 = 0
AIO_Umbrella.lastTick = 0
AIO_Umbrella.delay = 0
AIO_Umbrella.itemDelay = 0
AIO_Umbrella.lastItemCast = 0
AIO_Umbrella.lastDefItemPop = 0
AIO_Umbrella.lastItemTick = 0
AIO_Umbrella.ItemCastStop = false
AIO_Umbrella.isArmletManuallyToggled = false
AIO_Umbrella.isArmletManuallyToggledTime = 0
AIO_Umbrella.armletDelayer = 0
AIO_Umbrella.ControlledUnitCastTime = 0
AIO_Umbrella.ControlledUnitPauseTime = 0
AIO_Umbrella.lastAttackTime = 0
AIO_Umbrella.lastAttackTime2 = 0
AIO_Umbrella.LastTarget = nil
AIO_Umbrella.LastTickManta1 = 0
AIO_Umbrella.LastTickManta2 = 0
AIO_Umbrella.ArcWardenEntity = nil
AIO_Umbrella.ArcWardenEntityAnimationStart = 0
AIO_Umbrella.ArcWardenEntityAnimationEnd = 0
AIO_Umbrella.arcWardenPanelX = 0
AIO_Umbrella.arcWardenPanelY = 0
AIO_Umbrella.ArcTempestLockedTarget = nil
AIO_Umbrella.ArcTempestLockedTargetParticle = 0
AIO_Umbrella.ArcTempestLockedTargetParticleHero = nil
AIO_Umbrella.arcWardenMagneticCastTime = 0
AIO_Umbrella.arcWardenPushMode = false
AIO_Umbrella.arcWardenPusher = false
AIO_Umbrella.arcWardenPushModeLine = false
AIO_Umbrella.arcWardenStatus = 0
AIO_Umbrella.ArcTempestLockedTargetPos = Vector()
AIO_Umbrella.ArcTempestLockedTargetPosTimer = 0
AIO_Umbrella.TempestInAttackBackswing = false
AIO_Umbrella.TempestOrbwalkerDelay = 0
AIO_Umbrella.ArcWardenEntityProjectileCreate = 0
AIO_Umbrella.GenericUpValue = false
AIO_Umbrella.lastPosition = Vector(0, 0, 0)
AIO_Umbrella.PuckOrbCastTime = 0
AIO_Umbrella.Toggler = false
AIO_Umbrella.TogglerTime = 0
AIO_Umbrella.PreInvoke = false
AIO_Umbrella.InvokerComboSelector = 0
AIO_Umbrella.InvokerLastCastedSkill = nil
AIO_Umbrella.InvokerLastCastedSkillTime = 0
AIO_Umbrella.InvokerLastChangedInstance = 0
AIO_Umbrella.InvokerCaptureManualInstances = 0
AIO_Umbrella.getInvokerGhostWalkKey = nil
AIO_Umbrella.invokerChannellingKillstealTimer = 0
AIO_Umbrella.invokerCaptureGhostwalkActivation = 0
AIO_Umbrella.invokerDisplayNeedsInit = true
AIO_Umbrella.invokerPanelNeedsInit = true
AIO_Umbrella.InvokerCanComboStart = false
AIO_Umbrella.getInvokerSettings = nil
AIO_Umbrella.AttackProjectileCreate = 0
AIO_Umbrella.AttackAnimationCreate = 0
AIO_Umbrella.AttackParticleCreate = 0
AIO_Umbrella.InAttackBackswing = false
AIO_Umbrella.OrbwalkerDelay = 0
AIO_Umbrella.TPParticleIndex = nil
AIO_Umbrella.TPParticleTime = 0
AIO_Umbrella.TPParticleUnit = nil
AIO_Umbrella.TPParticlePosition = Vector()
AIO_Umbrella.GlimpseParticleIndex = nil
AIO_Umbrella.GlimpseParticleTime = 0
AIO_Umbrella.GlimpseParticleUnit = nil
AIO_Umbrella.GlimpseParticlePosition = Vector()
AIO_Umbrella.GlimpseParticleIndexStart = nil
AIO_Umbrella.GlimpseParticlePositionStart = Vector()
AIO_Umbrella.particleNextTime = 0
AIO_Umbrella.currentParticle = 0
AIO_Umbrella.currentParticleTarget = nil
AIO_Umbrella.skywrathDMGwithoutUlt = 0
AIO_Umbrella.skywrathDMGwithUlt = 0
AIO_Umbrella.skywrathComboSelect = false
AIO_Umbrella.clockwerkHookUpValue = false
AIO_Umbrella.enemyCanBeShackled = false
AIO_Umbrella.dodgeTiming = 0
AIO_Umbrella.dodgerProjectileAdjustmentTick = 0
AIO_Umbrella.saverTiming = 0
AIO_Umbrella.VisageInstStunLockTarget = nil
AIO_Umbrella.VisagePanicTarget = nil
AIO_Umbrella.morphlingComboSelect = false
AIO_Umbrella.morphlingTotalDMG = 0
AIO_Umbrella.morphlingTotalDMGwoWave = 0
AIO_Umbrella.MorphBalanceTimer = 0
AIO_Umbrella.MorphBalanceSelectedHP = 0
AIO_Umbrella.MorphBalanceSelected = 0
AIO_Umbrella.MorphBalanceToggler = true
AIO_Umbrella.SFParticleUpdateTime = 0
AIO_Umbrella.wardCaptureTiming = 0
AIO_Umbrella.sentryImageHandle = nil
AIO_Umbrella.obsImageHandle = nil
AIO_Umbrella.wardDrawingRemove = 0
AIO_Umbrella.necroDMGwithoutUlt = 0
AIO_Umbrella.necroDMGwithUlt = 0
AIO_Umbrella.necroComboSelect = false
AIO_Umbrella.magnusLastPos = Vector()
AIO_Umbrella.SFcurrentParticle1 = 0
AIO_Umbrella.SFcurrentParticle2 = 0
AIO_Umbrella.SFcurrentParticle3 = 0
AIO_Umbrella.armletRightClickToggle = false
AIO_Umbrella.armletRightClickToggleTimer = 0
AIO_Umbrella.armletRightClickDoubleClick = 0
AIO_Umbrella.isArmletActive = false
AIO_Umbrella.armletCurrentHPGain = 0
AIO_Umbrella.armletToggleTime = 0
AIO_Umbrella.armletToggleTimePingAdjuster = 0
AIO_Umbrella.armletProjectileAdjustmentTick = 0
AIO_Umbrella.armletDamageInstanceTable = {}
AIO_Umbrella.lastHitterDelay = 0
AIO_Umbrella.lastHitterKillableImage = nil
AIO_Umbrella.lastHitterOrbSkill = nil
AIO_Umbrella.lastHitterOrbSkillEnemy = nil
AIO_Umbrella.kunkkaXMarkPosition = Vector()
AIO_Umbrella.kunkkaGhostshipTimer = 0
AIO_Umbrella.kunkkaXMarkCastTime = 0
AIO_Umbrella.TinkerStatus = 0
AIO_Umbrella.TinkerPusher = false
AIO_Umbrella.TinkerPorted = false
AIO_Umbrella.TinkerJungle = false
AIO_Umbrella.TinkerMarched = 0
AIO_Umbrella.TinkerGlimmerCastTime = 0
AIO_Umbrella.TinkerPanicRearmBlink = 0
AIO_Umbrella.TinkerPanelX = 0
AIO_Umbrella.TinkerPanelY = 0
AIO_Umbrella.TinkerPushMode = false
AIO_Umbrella.TinkerPushCreeps = 3
AIO_Umbrella.TinkerPushEnemies = 0
AIO_Umbrella.TinkerPushAllies = 0
AIO_Umbrella.TinkerPushJungle = true
AIO_Umbrella.TinkerPushSave = true
AIO_Umbrella.TinkerPushDefend = true
AIO_Umbrella.PudgeRotComboActivation = false
AIO_Umbrella.PudgeRotComboDeactivation = 0
AIO_Umbrella.PudgeHookStartTimer = 0
AIO_Umbrella.PudgeHookDelayer = 0
AIO_Umbrella.PudgeHookRotDelayer = 0
AIO_Umbrella.PudgeHookTarget = nil
AIO_Umbrella.PudgeHookTargetedPos = nil
AIO_Umbrella.PudgeHookHit = false
AIO_Umbrella.PudgecurrentParticle = 0
AIO_Umbrella.PudgecurrentParticleTarget = nil
AIO_Umbrella.PudgeRotFarmToggled = false
AIO_Umbrella.PudgeRotFarmToggledTime = 0

	-- global Tables
AIO_Umbrella.LinkensBreakerItemOrder = {}
AIO_Umbrella.ItemCastOrder = {}
AIO_Umbrella.rotationTable = {}
AIO_Umbrella.PuckOrbHitSim = {}
AIO_Umbrella.enemyHeroTable = {}
AIO_Umbrella.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
AIO_Umbrella.PreInvokeSkills = {}
AIO_Umbrella.preemptiveBKB = {}
AIO_Umbrella.invokerCachedIcons = {}
AIO_Umbrella.dodgeItTable = {}
AIO_Umbrella.dodgeItReadyTable = {}
AIO_Umbrella.dodgeItSkillReady = {}
AIO_Umbrella.wardDispenserCount = {}
AIO_Umbrella.wardProcessingTable = {}
AIO_Umbrella.lastHitCreepHPPrediction = {}
AIO_Umbrella.lastHitCreepHPPredictionTime = {}
AIO_Umbrella.creepAttackPointData = {}
AIO_Umbrella.VisageFamiliarAttackCounter = {}
AIO_Umbrella.heroIconHandler = {}
AIO_Umbrella.itemIconHandler = {}
AIO_Umbrella.ControllableEntityTable = {}
AIO_Umbrella.ControllableAttackTiming = {}
AIO_Umbrella.TinkerJungleFarmPos = {}
AIO_Umbrella.JungleTrackTable = {}
AIO_Umbrella.ShrinePositionTable = {}

AIO_Umbrella.heroList = { 
	"npc_dota_hero_axe",
	"npc_dota_hero_rattletrap", 
	"npc_dota_hero_skywrath_mage",
	"npc_dota_hero_tiny",
	"npc_dota_hero_windrunner",
	"npc_dota_hero_ember_spirit",
	"npc_dota_hero_ursa",
	"npc_dota_hero_templar_assassin",
	"npc_dota_hero_legion_commander",
	"npc_dota_hero_shredder",
	"npc_dota_hero_slardar",
	"npc_dota_hero_clinkz",
	"npc_dota_hero_queenofpain",
	"npc_dota_hero_sven",
	"npc_dota_hero_visage",
	"npc_dota_hero_morphling",
	"npc_dota_hero_puck",
	"npc_dota_hero_invoker",
	"npc_dota_hero_arc_warden",
	"npc_dota_hero_furion",
	"npc_dota_hero_antimage",
	"npc_dota_hero_phantom_assassin",
	"npc_dota_hero_zuus",
	"npc_dota_hero_huskar",
	"npc_dota_hero_necrolyte",
	"npc_dota_hero_obsidian_destroyer",
	"npc_dota_hero_silencer",
	"npc_dota_hero_nevermore",
	"npc_dota_hero_dazzle",
	"npc_dota_hero_dark_willow",
	"npc_dota_hero_centaur",
	"npc_dota_hero_magnataur",
	"npc_dota_hero_ogre_magi",
	"npc_dota_hero_ancient_apparition",
	"npc_dota_hero_nyx_assassin",
	"npc_dota_hero_night_stalker",
	"npc_dota_hero_chaos_knight",
	"npc_dota_hero_witch_doctor",
	"npc_dota_hero_shadow_shaman",
	"npc_dota_hero_death_prophet",
	"npc_dota_hero_crystal_maiden",
	"npc_dota_hero_lion",
	"npc_dota_hero_pugna",
	"npc_dota_hero_undying",
	"npc_dota_hero_viper",
	"npc_dota_hero_pudge",
	"npc_dota_hero_vengefulspirit"
		}

AIO_Umbrella.dodgeItItems = { 
	{"item_manta", 1, "no target", 0.1}, 
	{"item_blink", 0, "position", 0.1}, 
	{"item_cyclone", 0, "target", 0.1},
	{"item_lotus_orb", 1, "target", 0.1},
	{"item_black_king_bar", 2, "no target", 0.1},
	{"item_blade_mail", 0, "no target", 0.1},
	{"item_glimmer_cape", 0, "target", 0.1}
		}

AIO_Umbrella.dodgeItSkills = {
	{"storm_spirit_ball_lightning", 0, "position", 0.4},
	{"puck_phase_shift", 0, "no target", 0.1},
	{"phantom_lancer_doppelwalk", 0, "position", 0.2},
	{"juggernaut_blade_fury", 2, "no target", 0.1},
	{"omniknight_repel", 2, "no target", 0.45},
	{"nyx_assassin_spiked_carapace", 0, "no target", 0.1},
	{"slark_dark_pact", 0, "no target", 0.1},
	{"morphling_waveform", 0, "position", 0.4},
	{"shadow_demon_disruption", 0, "target", 0.4},
	{"obsidian_destroyer_astral_imprisonment", 0, "target", 0.35},
	{"abaddon_aphotic_shield", 1, "target", 0.5},
	{"life_stealer_rage", 2, "no target", 0.1},
	{"sandking_sand_storm", 1, "no target", 0.1},
	{"faceless_void_time_walk", 0, "position", 0.4},
	{"ember_spirit_sleight_of_fist", 1, "position", 0.1},
	{"templar_assassin_refraction", 1, "no target", 0.1},
	{"templar_assassin_meld", 1, "no target", 0.1},
	{"riki_tricks_of_the_trade", 0, "no target", 0.35}
		}

AIO_Umbrella.preemptiveBKBtable = {
	"alchemist_unstable_concoction_throw",
	"beastmaster_primal_roar",
	"centaur_hoof_stomp",
	"chaos_knight_chaos_bolt",
	"crystal_maiden_frostbite",
	"death_prophet_silence",
	"dragon_knight_dragon_tail",
	"drow_ranger_wave_of_silence",
	"earth_spirit_boulder_smash",
	"earthshaker_fissure",
	"ember_spirit_searing_chains",
	"invoker_tornado",
	"jakiro_ice_path",
	"lion_impale",
	"lion_voodoo",
	"naga_siren_ensnare",
	"nyx_assassin_impale",
	"puck_dream_coil",
	"rubick_telekinesis",
	"sandking_burrowstrike",
	"shadow_shaman_shackles",
	"shadow_shaman_voodoo",
	"skeleton_king_hellfire_blast",
	"slardar_slithereen_crush",
	"storm_spirit_electric_vortex",
	"sven_storm_bolt",
	"tidehunter_ravage",
	"tiny_avalanche",
	"vengefulspirit_magic_missile",
	"warlock_rain_of_chaos",
	"windrunner_shackleshot",
	"slark_pounce",
	"ogre_magi_fireblast",
	"meepo_poof" }

AIO_Umbrella.dodgeEnemySkillsTable = {
	"antimage_mana_void",
	"alchemist_unstable_concoction_throw",
	"axe_berserkers_call",
	"bane_fiends_grip",
	"batrider_flaming_lasso",
	"bloodseeker_rupture",
	"centaur_hoof_stomp",
	"chaos_knight_chaos_bolt",
	"crystal_maiden_frostbite",
	"death_prophet_silence",
	"doom_bringer_doom",
	"drow_ranger_wave_of_silence",
	"earthshaker_fissure",
	"earthshaker_enchant_totem",
	"enigma_black_hole",
	"faceless_void_chronosphere",
	"juggernaut_omni_slash",
	"legion_commander_duel",
	"lich_chain_frost",
	"lina_laguna_blade",
	"lion_impale",
	"lion_finger_of_death",
	"luna_lucent_beam",
	"magnataur_reverse_polarity",
	"necrolyte_reapers_scythe",
	"night_stalker_crippling_fear",
	"nyx_assassin_impale",
	"ogre_magi_fireblast",
	"obsidian_destroyer_astral_imprisonment",
	"obsidian_destroyer_sanity_eclipse",
	"puck_waning_rift",
	"pudge_dismember",
	"queenofpain_sonic_wave",
	"rubick_telekinesis",
	"sandking_burrowstrike",
	"shadow_demon_disruption",
	"shadow_shaman_shackles",
	"silencer_global_silence",
	"skywrath_mage_ancient_seal",
	"slardar_slithereen_crush",
	"sniper_assassinate",
	"storm_spirit_electric_vortex",
	"sven_storm_bolt",
	"terrorblade_sunder",
	"tidehunter_ravage",
	"tinker_laser",
	"vengefulspirit_magic_missile",
	"warlock_rain_of_chaos",
	"windrunner_shackleshot",
	"skeleton_king_hellfire_blast",
	"zuus_lightning_bolt",
	"zuus_thundergods_wrath"
		}

AIO_Umbrella.JunglePositionTable = {
	{ Vector(-1845, -4214, 0), "radiant", "bot", "hard" },
	{ Vector(4591, -4354, 0), "radiant", "bot", "hard" },
	{ Vector(-416, -3345, 0), "radiant", "bot", "medium" },
	{ Vector(381, -4680, 0), "radiant", "bot", "medium" },
	{ Vector(2889, -4558, 0), "radiant", "bot", "small" },
	{ Vector(-4862, -477, 0), "radiant", "top", "hard" },
	{ Vector(-3707, 878, 0), "radiant", "top", "medium" },
	{ Vector(1349, 3317, 0), "dire", "top", "hard" },
	{ Vector(-4283, 3474, 0), "dire", "top", "hard" },
	{ Vector(-227, 3396, 0), "dire", "top", "medium" },
	{ Vector(-2000, 4275, 0), "dire", "top", "medium" },
	{ Vector(-2677, 4593, 0), "dire", "top", "small" },
	{ Vector(4411, 847, 0), "dire", "bot", "hard" },
	{ Vector(2554, 81, 0), "dire", "bot", "medium" } 
		}

AIO_Umbrella.invokerInvokeOrder = {
	invoker_sun_strike = { 2, 2, 2 },
	invoker_emp = { 1, 1, 1 },
	invoker_tornado = { 0, 1, 1 },
	invoker_alacrity = { 1, 1, 2 },
	invoker_ghost_walk = { 0, 0, 1 },
	invoker_deafening_blast = { 0, 1, 2 },
	invoker_chaos_meteor = { 1, 2, 2 },
	invoker_cold_snap = { 0, 0, 0 },
	invoker_ice_wall = { 0, 0, 2 },
	invoker_forge_spirit = { 0, 2, 2 } }

AIO_Umbrella.invokerTornadoLiftDuration = { 0.8, 1.1, 1.4, 1.7, 2.0, 2.3, 2.6, 2.9 }

AIO_Umbrella.orbAttackTable = {
	npc_dota_hero_clinkz = "clinkz_searing_arrows",
	npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
	npc_dota_hero_enchantress = "enchantress_impetus",
	npc_dota_hero_huskar = "huskar_burning_spear",
	npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
	npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
	npc_dota_hero_viper = "viper_poison_attack"
			}

AIO_Umbrella.attackPointTable = {
	npc_dota_hero_abaddon = { 0.56, 0.41, 0 },
	npc_dota_hero_alchemist = { 0.35, 0.65, 0 },
	npc_dota_hero_ancient_apparition = { 0.45, 0.3, 1250 },
	npc_dota_hero_antimage = { 0.3, 0.6, 0 },
	npc_dota_hero_arc_warden = { 0.3, 0.7, 800 },
	npc_dota_hero_axe = { 0.5, 0.5, 0 },
	npc_dota_hero_bane = { 0.3, 0.7, 900 },
	npc_dota_hero_batrider = { 0.3, 0.54, 900 },
	npc_dota_hero_beastmaster = { 0.3, 0.7, 0 },
	npc_dota_hero_bloodseeker = { 0.43, 0.74, 0 },
	npc_dota_hero_bounty_hunter = { 0.59, 0.59, 0 },
	npc_dota_hero_brewmaster = { 0.35, 0.65, 0 },
	npc_dota_hero_bristleback = { 0.3, 0.3, 0 },
	npc_dota_hero_broodmother = { 0.4, 0.5, 0 },
	npc_dota_hero_centaur = { 0.3, 0.3, 0 },
	npc_dota_hero_chaos_knight = { 0.5, 0.5, 0 },
	npc_dota_hero_chen = { 0.5, 0.5, 1100 },
	npc_dota_hero_clinkz = { 0.7, 0.3, 900 },
	npc_dota_hero_rattletrap = { 0.33, 0.64, 0 },
	npc_dota_hero_crystal_maiden = { 0.55, 0, 900 },
	npc_dota_hero_dark_seer = { 0.59, 0.58, 0 },
	npc_dota_hero_dazzle = { 0.3, 0.3, 1200 },
	npc_dota_hero_death_prophet = { 0.56, 0.51, 1000 },
	npc_dota_hero_disruptor = { 0.4, 0.5, 1200 },
	npc_dota_hero_doom_bringer = { 0.5, 0.7, 0 },
	npc_dota_hero_dragon_knight = { 0.5, 0.5, 900 },
	npc_dota_hero_drow_ranger = { 0.7, 0.3, 1250 },
	npc_dota_hero_earth_spirit = { 0.35, 0.65, 0 },
	npc_dota_hero_earthshaker = { 0.467, 0.863, 0 },
	npc_dota_hero_elder_titan = { 0.35, 0.97, 0 },
	npc_dota_hero_ember_spirit = { 0.4, 0.3, 0 },
	npc_dota_hero_enchantress = { 0.3, 0.7, 900 },
	npc_dota_hero_enigma = { 0.4, 0.77, 900 },
	npc_dota_hero_faceless_void = { 0.5, 0.56, 0 },
	npc_dota_hero_gyrocopter = { 0.2, 0.97, 3000 },
	npc_dota_hero_huskar = { 0.4, 0.5, 1400 },
	npc_dota_hero_invoker = { 0.4, 0.7, 900 },
	npc_dota_hero_wisp = { 0.15, 0.4, 1200 },
	npc_dota_hero_jakiro = { 0.4, 0.5, 1100 },
	npc_dota_hero_juggernaut = { 0.33, 0.84, 0 },
	npc_dota_hero_keeper_of_the_light = { 0.3, 0.85, 900 },
	npc_dota_hero_kunkka = { 0.4, 0.3, 0 },
	npc_dota_hero_legion_commander = { 0.46, 0.64, 0 },
	npc_dota_hero_leshrac = { 0.4, 0.77, 900 },
	npc_dota_hero_lich = { 0.46, 0.54, 900 },
	npc_dota_hero_life_stealer = { 0.39, 0.44, 0 },
	npc_dota_hero_lina = { 0.75, 0.78, 1000 },
	npc_dota_hero_lion = { 0.43, 0.74, 1000 },
	npc_dota_hero_lone_druid = { 0.33, 0.53, 900 },
	npc_dota_hero_luna = { 0.46, 0.54, 900 },
	npc_dota_hero_lycan = { 0.55, 0.55, 0 },
	npc_dota_hero_magnataur = { 0.5, 0.84, 0 },
	npc_dota_hero_medusa = { 0.5, 0.6, 1200 },
	npc_dota_hero_meepo = { 0.38, 0.6, 0 },
	npc_dota_hero_mirana = { 0.3, 0.7, 900 },
	npc_dota_hero_morphling = { 0.45, 0.2, 0 },
	npc_dota_hero_monkey_king = { 0.5, 0.5, 1300 },
	npc_dota_hero_naga_siren = { 0.5, 0.5, 0 },
	npc_dota_hero_furion = { 0.4, 0.77, 1125 },
	npc_dota_hero_necrolyte = { 0.53, 0.47, 900 },
	npc_dota_hero_night_stalker = { 0.55, 0.55, 0 },
	npc_dota_hero_nyx_assassin = { 0.46, 0.54, 0 },
	npc_dota_hero_ogre_magi = { 0.3, 0.3, 0 },
	npc_dota_hero_omniknight = { 0.433, 0.567, 0 },
	npc_dota_hero_oracle = { 0.3, 0.7, 900 },
	npc_dota_hero_obsidian_destroyer = { 0.46, 0.54, 900 },
	npc_dota_hero_phantom_assassin = { 0.3, 0.7, 0 },
	npc_dota_hero_phantom_lancer = { 0.5, 0.5, 0 },
	npc_dota_hero_phoenix = { 0.35, 0.633, 1100 },
	npc_dota_hero_puck = { 0.5, 0.8, 900 },
	npc_dota_hero_pudge = { 0.5, 1.17, 0 },
	npc_dota_hero_pugna = { 0.5, 0.5, 900 },
	npc_dota_hero_queenofpain = { 0.56, 0.41, 1500 },
	npc_dota_hero_razor = { 0.3, 0.7, 2000 },
	npc_dota_hero_riki = { 0.3, 0.3, 0 },
	npc_dota_hero_rubick = { 0.4, 0.77, 1125 },
	npc_dota_hero_sand_king = { 0.53, 0.47, 0 },
	npc_dota_hero_shadow_demon = { 0.35, 0.5, 900 },
	npc_dota_hero_nevermore = { 0.5, 0.54, 1200 },
	npc_dota_hero_shadow_shaman = { 0.3, 0.5, 900 },
	npc_dota_hero_silencer = { 0.5, 0.5, 1000 },
	npc_dota_hero_skywrath_mage = { 0.4, 0.78, 1000 },
	npc_dota_hero_slardar = { 0.36, 0.64, 0 },
	npc_dota_hero_slark = { 0.5, 0.3, 0 },
	npc_dota_hero_sniper = { 0.17, 0.7, 3000 },
	npc_dota_hero_spectre = { 0.3, 0.7, 0 },
	npc_dota_hero_spirit_breaker = { 0.6, 0.3, 0 },
	npc_dota_hero_storm_spirit = { 0.5, 0.3, 1100 },
	npc_dota_hero_sven = { 0.4, 0.3, 0 },
	npc_dota_hero_techies = { 0.5, 0.5, 900 },
	npc_dota_hero_templar_assassin = { 0.3, 0.5, 900 },
	npc_dota_hero_terrorblade = { 0.3, 0.6, 0 },
	npc_dota_hero_tidehunter = { 0.6, 0.56, 0 },
	npc_dota_hero_shredder = { 0.36, 0.64, 0 },
	npc_dota_hero_tinker = { 0.35, 0.65, 900 },
	npc_dota_hero_tiny = { 0.49, 1, 0 },
	npc_dota_hero_treant = { 0.6, 0.4, 0 },
	npc_dota_hero_troll_warlord = { 0.3, 0.3, 1200 },
	npc_dota_hero_tusk = { 0.36, 0.64, 0 },
	npc_dota_hero_abyssal_underlord = { 0.45, 0.7, 0 },
	npc_dota_hero_undying = { 0.3, 0.3, 0 },
	npc_dota_hero_ursa = { 0.3, 0.3, 0 },
	npc_dota_hero_vengefulspirit = { 0.33, 0.64, 1500 },
	npc_dota_hero_venomancer = { 0.3, 0.7, 900 },
	npc_dota_hero_viper = { 0.33, 1, 1200 },
	npc_dota_hero_visage = { 0.46, 0.54, 900 },
	npc_dota_hero_warlock = { 0.3, 0.3, 1200 },
	npc_dota_hero_weaver = { 0.64, 0.36, 900 },
	npc_dota_hero_windrunner = { 0.4, 0.3, 1250 },
	npc_dota_hero_winter_wyvern = { 0.25, 0.8, 700 },
	npc_dota_hero_witch_doctor = { 0.4, 0.5, 1200 },
	npc_dota_hero_skeleton_king = { 0.56, 0.44, 0 },
	npc_dota_hero_zuus = { 0.633, 0.366, 1100 },
	npc_dota_hero_dark_willow = { 0.3, 0.7, 1200 },
	npc_dota_hero_pangolier = { 0.33, 0.67, 0 } }

AIO_Umbrella.AbilityList = {
	{ "npc_dota_hero_abaddon", "abaddon_death_coil", "nuke", "target" , "target_damage" },
	{ "npc_dota_hero_abaddon", "abaddon_frostmourne", "utility", "0" , "0" },
	{ "npc_dota_hero_abaddon", "abaddon_aphotic_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_abaddon", "abaddon_borrowed_time", "utility", "0" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_pit_of_malice", "disable", "position" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_firestorm", "nuke", "position" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_atrophy_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_dark_rift", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_unstable_concoction", "disable", "target" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_unstable_concoction_throw", "disable", "target" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_acid_spray", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_chemical_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_goblins_greed", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_blast", "nuke", "position" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_blast_release", "nuke", "position" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_chilling_touch", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_cold_feet", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_vortex", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_mana_void"    , "nuke", "target" , "0" },
	{ "npc_dota_hero_antimage", "antimage_blink", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_mana_break", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_spell_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_flux", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_magnetic_field", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_spark_wraith", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_tempest_double", "utility", "0" , "0" },
	{ "npc_dota_hero_axe", "axe_berserkers_call", "disable", "no target" , "0" },
	{ "npc_dota_hero_axe", "axe_culling_blade", "nuke", "target" , "damage" },
	{ "npc_dota_hero_axe", "axe_battle_hunger", "utility", "0" , "0" },
	{ "npc_dota_hero_axe", "axe_counter_helix", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_brain_sap", "pure", "target" , "brain_sap_damage" },
	{ "npc_dota_hero_bane", "bane_fiends_grip", "nuke", "target" , "0" },
	{ "npc_dota_hero_bane", "bane_enfeeble", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_nightmare", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_nightmare_end", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_firefly", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_flamebreak", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_flaming_lasso", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_sticky_napalm", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_wild_axes", "nuke", "position" , "axe_damage" },
	{ "npc_dota_hero_beastmaster", "beastmaster_primal_roar", "disable", "no target" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_boar_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_call_of_the_wild", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_call_of_the_wild_boar", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_greater_boar_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_hawk_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_inner_beast", "utility", "0" , "0" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_blood_bath", "nuke", "position" , "damage" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_rupture", "utility", "0" , "0" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_thirst", "utility", "0" , "0" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_shuriken_toss", "nuke", "target" , "bonus_damage" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_jinada", "utility", "0" , "0" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_track", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_thunder_clap", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_hurl_boulder", "disable", "target" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_drunken_brawler", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_drunken_haze", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_pulverize", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_spell_immunity", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_fire_permanent_immolation", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_primal_split", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_cyclone", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_dispel_magic", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_wind_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_quill_spray", "nuke", "no target" , "quill_base_damage" },
	{ "npc_dota_hero_bristleback", "bristleback_bristleback", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_viscous_nasal_goo", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_warpath", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spawn_spiderlings", "nuke", "target" , "damage" },
	{ "npc_dota_hero_broodmother", "broodmother_incapacitating_bite", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_insatiable_hunger", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_poison_sting", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spawn_spiderite", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spin_web", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spin_web_destroy"  , "utility", "0" , "0" },
	{ "npc_dota_hero_centaur", "centaur_double_edge", "nuke", "no target" , "edge_damage" },
	{ "npc_dota_hero_centaur", "centaur_hoof_stomp", "disable", "no target" , "0" },
	{ "npc_dota_hero_centaur", "centaur_return", "utility", "0" , "0" },
	{ "npc_dota_hero_centaur", "centaur_stampede", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_chaos_bolt", "disable", "target" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_chaos_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_phantasm", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_reality_rift", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_test_of_faith", "pure", "target" , "damage_min" },
	{ "npc_dota_hero_chen", "chen_hand_of_god", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_holy_persuasion", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_penitence", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_test_of_faith_teleport", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_death_pact", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_searing_arrows", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_strafe", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_wind_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_crystal_nova", "nuke", "position" , "nova_damage" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_frostbite", "disable", "target" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_freezing_field", "nuke", "no target" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_brilliance_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_ion_shell", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_surge", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_vacuum", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_wall_of_replica", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_poison_touch", "nuke", "target" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_shadow_wave", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_shallow_grave", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_weave", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_carrion_swarm", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_exorcism", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_spirit_siphon", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_witchcraft", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_thunder_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_glimpse", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_kinetic_field", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_static_storm", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_devour", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_doom", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_infernal_blade", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_scorched_earth", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_dragon_tail", "disable", "target" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_breathe_fire", "nuke", "position" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_dragon_blood", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_elder_dragon_form", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_frost_breath", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_wave_of_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_frost_arrows", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_marksmanship", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_trueshot", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_boulder_smash", "disable", "position" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_geomagnetic_grip", "disable", "position" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_magnetize", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_petrify", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_rolling_boulder", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_stone_caller", "utility", "0" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_aftershock", "disable", "no target" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_fissure", "disable", "position" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_echo_slam", "nuke", "no target" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_enchant_totem", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_ancestral_spirit", "nuke", "position" , "pass_damage" },
	{ "npc_dota_hero_elder_titan", "elder_titan_echo_stomp_spirit", "disable", "no target" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_earth_splitter", "nuke", "position" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_natural_order", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_echo_stomp", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_natural_order_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_return_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_searing_chains", "disable", "no target" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_activate_fire_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_fire_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_flame_guard", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_sleight_of_fist", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_impetus", "nuke", "target" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_enchant", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_natures_attendants", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_untouchable", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_black_hole", "disable", "position" , "0" },
	{ "npc_dota_hero_enigma", "enigma_demonic_conversion", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_malefice", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_midnight_pulse", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_chronosphere", "disable", "position" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_backtrack", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_dilation", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_lock", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_force_of_nature", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_sprout", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_teleportation", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_wrath_of_nature", "utility", "0" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_call_down", "nuke", "position" , "damage_first" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_homing_missile", "disable", "target" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_rocket_barrage", "nuke", "no target" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_flak_cannon", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_berserkers_blood", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_burning_spear", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_inner_vitality", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_life_break", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_cold_snap", "disable", "no target" , "0" },
	{ "npc_dota_hero_invoker", "invoker_tornado", "disable", "position" , "0" },
	{ "npc_dota_hero_invoker", "invoker_alacrity", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_attribute_bonus", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_chaos_meteor", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_deafening_blast", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_emp", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_exort", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_forge_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_ghost_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_ice_wall", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_invoke", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_quas", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_sun_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_wex", "utility", "0" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_ice_path", "disable", "position" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_macropyre", "nuke", "position" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_dual_breath", "utility", "0" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_liquid_fire", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_omni_slash", "nuke", "target" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_blade_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_blade_fury", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_healing_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_blinding_light", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_chakra_magic", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_illuminate", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_illuminate_end", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_mana_leak", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_recall", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form_illuminate", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form_illuminate_end", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_ghostship", "nuke", "position" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_torrent", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_return", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_tidebringer", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_x_marks_the_spot", "utility", "0" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_overwhelming_odds", "nuke", "position" , "damage" },
	{ "npc_dota_hero_legion_commander", "legion_commander_duel", "disable", "target" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_moment_of_courage", "utility", "0" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_press_the_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_split_earth", "disable", "position" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_lightning_storm", "nuke", "target" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_pulse_nova", "utility", "0" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_diabolic_edict", "utility", "0" , "0" },
	{ "npc_dota_hero_lich", "lich_chain_frost", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lich", "lich_frost_nova", "nuke", "position" , "aoe_damage" },
	{ "npc_dota_hero_lich", "lich_dark_ritual", "utility", "0" , "0" },
	{ "npc_dota_hero_lich", "lich_frost_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_assimilate", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_assimilate_eject", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_consume", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_control", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_1", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_2", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_3", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_4", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_feast", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_infest", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_open_wounds", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_lina", "lina_laguna_blade", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lina", "lina_light_strike_array", "disable", "position" , "0" },
	{ "npc_dota_hero_lina", "lina_dragon_slave", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_lina", "lina_fiery_soul", "utility", "0" , "0" },
	{ "npc_dota_hero_lion", "lion_finger_of_death", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lion", "lion_impale", "disable", "position" , "0" },
	{ "npc_dota_hero_lion", "lion_voodoo", "disable", "target" , "0" },
	{ "npc_dota_hero_lion", "lion_mana_drain", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_rabid", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_savage_roar", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_savage_roar_bear", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_demolish", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_entangle", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_return", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form_battle_cry", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form_druid", "utility", "0" , "0" },
	{ "npc_dota_hero_luna", "luna_lucent_beam", "nuke", "target" , "beam_damage" },
	{ "npc_dota_hero_luna", "luna_eclipse", "nuke", "no target" , "0" },
	{ "npc_dota_hero_luna", "luna_lunar_blessing", "utility", "0" , "0" },
	{ "npc_dota_hero_luna", "luna_moon_glaive", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_feral_impulse", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_howl", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_shapeshift", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves_critical_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_shockwave", "nuke", "skillshot" , "shock_damage" },
	{ "npc_dota_hero_magnataur", "magnataur_reverse_polarity", "disable", "no target" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_empower", "utility", "0" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_skewer", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_mystic_snake", "pure", "target" , "snake_damage" },
	{ "npc_dota_hero_medusa", "medusa_mana_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_split_shot", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_stone_gaze", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_earthbind", "disable", "position" , "0" },
	{ "npc_dota_hero_meepo", "meepo_poof", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_divided_we_stand", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_geostrike", "utility", "0" , "0" },
	{ "npc_dota_hero_mirana", "mirana_arrow", "disable", "position" , "0" },
	{ "npc_dota_hero_mirana", "mirana_starfall", "nuke", "no target" , "0" },
	{ "npc_dota_hero_mirana", "mirana_invis", "utility", "0" , "0" },
	{ "npc_dota_hero_mirana", "mirana_leap", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_primal_spring", "disable", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_primal_spring_early", "disable", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_boundless_strike", "nuke", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_jingu_mastery", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_mischief", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_tree_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_untransform", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_wukongs_command", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_adaptive_strike_agi", "nuke", "target" , "damage_base" },
	{ "npc_dota_hero_morphling", "morphling_waveform", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_hybrid", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_agi", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_replicate", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_str", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_replicate", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_ensnare", "disable", "target" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_rip_tide", "nuke", "no target" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_mirror_image", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_song_of_the_siren", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_song_of_the_siren_cancel", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_reapers_scythe", "disable", "target" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_death_pulse", "nuke", "no target" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_heartstopper_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_sadist", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_sadist_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_dark_lord", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_necromastery", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_requiem", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze1", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze2", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze3", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_night_stalker", "night_stalker_void", "nuke", "target" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_crippling_fear", "utility", "0" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_darkness", "utility", "0" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_hunter_in_the_night", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_impale", "disable", "position" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_mana_burn", "nuke", "special" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_burrow", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_spiked_carapace", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_unburrow", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_vendetta", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_astral_imprisonment", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_sanity_eclipse", "nuke", "position" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_arcane_orb", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_essence_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_mind_over_matter", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_fireblast", "nuke", "target" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_unrefined_fireblast", "nuke", "target" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_bloodlust", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_ignite", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_multicast", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_degen_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_guardian_angel", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_purification", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_repel", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_fortunes_end", "disable", "target" , "0" },
	{ "npc_dota_hero_oracle", "oracle_false_promise", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_fates_edict", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_purifying_flames", "nuke", "target" , "damage" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_stifling_dagger", "nuke", "target" , "base_damage" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_blur", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_coup_de_grace", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_phantom_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_spirit_lance", "nuke", "target" , "lance_damage" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_doppelwalk", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_juxtapose", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_phantom_edge", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_fire_spirits", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_icarus_dive", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_icarus_dive_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_launch_fire_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_toggle_move", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_toggle_move_empty", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_supernova", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_dream_coil", "disable", "position" , "0" },
	{ "npc_dota_hero_puck", "puck_waning_rift", "disable", "no target" , "damage" },
	{ "npc_dota_hero_puck", "puck_ethereal_jaunt", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_illusory_orb", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_phase_shift", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_dismember", "disable", "target" , "0" },
	{ "npc_dota_hero_pudge", "pudge_flesh_heap", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_meat_hook", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_rot", "utility", "0" , "0" },
	{ "npc_dota_hero_pugna", "pugna_nether_blast", "nuke", "skillshot" , "blast_damage" },
	{ "npc_dota_hero_pugna", "pugna_life_drain", "nuke", "target" , "0" },
	{ "npc_dota_hero_pugna", "pugna_decrepify", "utility", "0" , "0" },
	{ "npc_dota_hero_pugna", "pugna_nether_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_queenofpain", "queenofpain_sonic_wave", "nuke", "position" , "damage" },
	{ "npc_dota_hero_queenofpain", "queenofpain_shadow_strike", "nuke", "target" , "strike_damage" },
	{ "npc_dota_hero_queenofpain", "queenofpain_scream_of_pain", "nuke", "special" , "0" },
	{ "npc_dota_hero_queenofpain", "queenofpain_blink", "utility", "0" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_battery_assault", "disable", "no target" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_hookshot", "disable", "position" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_rocket_flare", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_power_cogs", "utility", "0" , "0" },
	{ "npc_dota_hero_razor", "razor_plasma_field", "nuke", "no target" , "damage_max" },
	{ "npc_dota_hero_razor", "razor_eye_of_the_storm", "nuke", "no target" , "0" },
	{ "npc_dota_hero_razor", "razor_static_link", "utility", "0" , "0" },
	{ "npc_dota_hero_razor", "razor_unstable_current", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_smoke_screen", "disable", "position" , "0" },
	{ "npc_dota_hero_riki", "riki_blink_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_permanent_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_tricks_of_the_trade", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_fade_bolt", "nuke", "target" , "damage" },
	{ "npc_dota_hero_rubick", "rubick_telekinesis", "disable", "target" , "0" },
	{ "npc_dota_hero_rubick", "rubick_telekinesis_land", "disable", "target" , "0" },
	{ "npc_dota_hero_rubick", "rubick_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden1", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden2", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden3", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_null_field", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_spell_steal", "utility", "0" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_burrowstrike", "disable", "position" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_epicenter", "nuke", "no target" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_caustic_finale", "utility", "0" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_sand_storm", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_demonic_purge", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_disruption", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_shadow_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_shadow_poison_release", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_soul_catcher", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_ether_shock", "nuke", "target" , "damage" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_shackles", "disable", "target" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_voodoo", "disable", "target" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_mass_serpent_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_whirling_death", "pure", "no target" , "whirling_damage" },
	{ "npc_dota_hero_shredder", "shredder_chakram", "nuke", "position" , "0" },
	{ "npc_dota_hero_shredder", "shredder_chakram_2", "nuke", "position" , "0" },
	{ "npc_dota_hero_shredder", "shredder_reactive_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_return_chakram", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_return_chakram_2", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_timber_chain", "utility", "0" , "0" },
	{ "npc_dota_hero_silencer", "silencer_last_word", "nuke", "target" , "damage" },
	{ "npc_dota_hero_silencer", "silencer_global_silence", "disable", "no target" , "0" },
	{ "npc_dota_hero_silencer", "silencer_curse_of_the_silent", "utility", "0" , "0" },
	{ "npc_dota_hero_silencer", "silencer_glaives_of_wisdom", "utility", "0" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_hellfire_blast", "disable", "target" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_reincarnation", "utility", "0" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_vampiric_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_arcane_bolt", "nuke", "target" , "bolt_damage" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_ancient_seal", "disable", "target" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_mystic_flare", "nuke", "position" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_concussive_shot", "nuke", "special" , "damage" },
	{ "npc_dota_hero_slardar", "slardar_slithereen_crush", "disable", "no target" , "0" },
	{ "npc_dota_hero_slardar", "slardar_amplify_damage", "utility", "0" , "0" },
	{ "npc_dota_hero_slardar", "slardar_bash", "utility", "0" , "0" },
	{ "npc_dota_hero_slardar", "slardar_sprint", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_dark_pact", "nuke", "no target" , "total_damage" },
	{ "npc_dota_hero_slark", "slark_essence_shift", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_pounce", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_shadow_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_assassinate", "nuke", "target" , "0" },
	{ "npc_dota_hero_sniper", "sniper_headshot", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_shrapnel", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_take_aim", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_spectral_dagger", "nuke", "target" , "damage" },
	{ "npc_dota_hero_spectre", "spectre_desolate", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_dispersion", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_haunt", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_reality", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_nether_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_charge_of_darkness", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_empowering_haste", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_greater_bash", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_electric_vortex", "disable", "target" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_ball_lightning", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_overload", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_static_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_storm_bolt", "disable", "target" , "0" },
	{ "npc_dota_hero_sven", "sven_gods_strength", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_great_cleave", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_warcry", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_land_mines", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_stasis_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_suicide", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_remote_mines", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_focused_detonate", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_remote_mines_self_detonate", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_minefield_sign", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_meld", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_psi_blades", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_psionic_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_refraction", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_self_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_conjure_image", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_metamorphosis", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_reflection", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_sunder", "utility", "0" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_ravage", "disable", "no target" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_anchor_smash", "nuke", "no target" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_gush", "nuke", "target" , "gush_damage" },
	{ "npc_dota_hero_tidehunter", "tidehunter_kraken_shell", "utility", "0" , "0" },
	{ "npc_dota_hero_tinker", "tinker_laser", "pure", "target" , "laser_damage" },
	{ "npc_dota_hero_tinker", "tinker_heat_seeking_missile", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_tinker", "tinker_march_of_the_machines", "utility", "0" , "0" },
	{ "npc_dota_hero_tinker", "tinker_rearm", "utility", "0" , "0" },
	{ "npc_dota_hero_tiny", "tiny_toss", "nuke", "position" , "toss_damage" },
	{ "npc_dota_hero_tiny", "tiny_avalanche", "disable", "position" , "avalanche_damage" },
	{ "npc_dota_hero_tiny", "tiny_craggy_exterior", "utility", "0" , "0" },
	{ "npc_dota_hero_tiny", "tiny_grow", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_overgrowth", "disable", "no target" , "0" },
	{ "npc_dota_hero_treant", "treant_eyes_in_the_forest", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_leech_seed", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_living_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_natures_guise", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_battle_trance", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_berserkers_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_fervor", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_whirling_axes_melee", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_whirling_axes_ranged", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_ice_shards", "nuke", "skillshot" , "shard_damage" },
	{ "npc_dota_hero_tusk", "tusk_walrus_kick", "nuke", "target" , "0" },
	{ "npc_dota_hero_tusk", "tusk_walrus_punch", "nuke", "target" , "0" },
	{ "npc_dota_hero_tusk", "tusk_frozen_sigil", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_launch_snowball", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_snowball", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_decay", "nuke", "position" , "decay_damage" },
	{ "npc_dota_hero_undying", "undying_flesh_golem", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_soul_rip", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone_zombie_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone_zombie_deathstrike", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_earthshock", "nuke", "no target" , "0" },
	{ "npc_dota_hero_ursa", "ursa_enrage", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_fury_swipes", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_overpower", "utility", "0" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_magic_missile", "disable", "target" , "magic_missile_damage" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_wave_of_terror", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_command_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_nether_swap", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_plague_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_poison_nova", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_poison_sting", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_venomous_gale", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_viper_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_viper", "viper_corrosive_skin", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_nethertoxin", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_poison_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_soul_assumption", "utilit<", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_grave_chill", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_gravekeepers_cloak", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_summon_familiars", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_summon_familiars_stone_form", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_rain_of_chaos", "disable", "position" , "0" },
	{ "npc_dota_hero_warlock", "warlock_shadow_word", "nuke", "target" , "0" },
	{ "npc_dota_hero_warlock", "warlock_fatal_bonds", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_golem_flaming_fists", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_golem_permanent_immolation", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_upheaval", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_geminate_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_shukuchi", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_the_swarm", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_time_lapse", "utility", "0" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_shackleshot", "disable", "target" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_powershot", "nuke", "skillshot" , "powershot_damage" },
	{ "npc_dota_hero_windrunner", "windrunner_focusfire", "utility", "0" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_windrun", "utility", "0" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_winters_curse", "disable", "target" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_splinter_blast", "nuke", "special" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_arctic_burn", "utility", "0" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_cold_embrace", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_overcharge", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_relocate", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits_in", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits_out", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_tether", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_tether_break", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_paralyzing_cask", "disable", "target" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_death_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_maledict", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_voodoo_restoration", "utility", "0" , "0" },
	{ "npc_dota_hero_zuus", "zuus_arc_lightning", "nuke", "target" , "arc_damage" },
	{ "npc_dota_hero_zuus", "zuus_lightning_bolt", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_zuus", "zuus_thundergods_wrath", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_zuus", "zuus_cloud", "utility", "0" , "0" },
	{ "npc_dota_hero_zuus", "zuus_static_field", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_bramble_maze", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_shadow_realm", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_cursed_crown", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_bedlam", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_terrorize", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_swashbuckle", "nuke", "special", "damage" },
	{ "npc_dota_hero_pangolier", "pangolier_shield_crash", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_heartpiercer", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_gyroshell", "utility", "0" , "0" } }

AIO_Umbrella.armletDotTickTable = {
	modifier_queenofpain_shadow_strike = 3,
	modifier_crystal_maiden_frostbite = 0.5,
	modifier_alchemist_acid_spray = 1,
	modifier_cold_feet =  1,
	modifier_arc_warden_flux = 0.5,
	modifier_axe_battle_hunger = 1,
	modifier_flamebreak_damage = 1,
	modifier_dazzle_poison_touch = 1,
	modifier_disruptor_thunder_strike = 2,
	modifier_doom_bringer_infernal_blade_burn = 1,
	modifier_dragon_knight_corrosive_breath_dot = 1,
	modifier_earth_spirit_magnetize = 0.5,
	modifier_ember_spirit_searing_chains = 1,
	modifier_enigma_malefice = 2,
	modifier_invoker_ice_wall_slow_debuff = 1,
	modifier_invoker_chaos_meteor_burn = 0.5,
	modifier_huskar_burning_spear_debuff = 1,
	modifier_jakiro_dual_breath_burn = 0.5,
	modifier_jakiro_liquid_fire_burn = 0.5,
	modifier_meepo_geostrike_debuff = 1,
	modifier_ogre_magi_ignite = 1,
	modifier_phoenix_icarus_dive_burn = 1,
	modifier_phoenix_fire_spirit_burn = 1,
	modifier_phoenix_sun_debuff = 1,
	modifier_silencer_curse_of_the_silent = 1,
	modifier_silencer_last_word = 4,
	modifier_sniper_shrapnel_slow = 1,
	modifier_shredder_chakram_debuff = 0.5,
	modifier_treant_leech_seed = 0.75,
	modifier_abyssal_underlord_firestorm_burn = 1,
	modifier_venomancer_venomous_gale = 3,
	modifier_venomancer_poison_sting = 1,
	modifier_venomancer_poison_nova = 1,
	modifier_venomancer_poison_sting_ward = 1,
	modifier_viper_poison_attack_slow = 1,
	modifier_viper_viper_strike_slow = 1,
	modifier_warlock_shadow_word = 1,
	modifier_weaver_swarm_debuff = 0.8,
	modifier_winter_wyvern_arctic_burn_slow = 1,
	modifier_maledict = 1,
	modifier_skeleton_king_hellfire_blast = 1,
	modifier_item_orb_of_venom_slow = 1,
	modifier_item_radiance_debuff = 1,
	modifier_item_urn_damage = 1,
	modifier_item_spirit_vessel_damage = 1,
	modifier_spawnlord_master_freeze_root = 0.5,
	modifier_broodmother_poison_sting_debuff = 1,
	modifier_gnoll_assassin_envenomed_weapon_poison = 1,
	modifier_warlock_golem_permanent_immolation_debuff =  1,
	modifier_necrolyte_heartstopper_aura_effect = 0.2,
	modifier_death_prophet_spirit_siphon_slow = 0.25,
	modifier_disruptor_static_storm = 0.25,
	modifier_pugna_life_drain = 0.25,
	modifier_skywrath_mystic_flare_aura_effect = 0.1,
	modifier_tornado_tempest_debuff = 0.25,
	modifier_pudge_rot = 0.2
		}

AIO_Umbrella.armletDotTickTableAOE = {
	modifier_doom_bringer_scorched_earth_effect = { 625, 1 },
	modifier_rattletrap_battery_assault = { 300, 0.7 },
	modifier_leshrac_pulse_nova = { 475, 1 },
	modifier_sandking_sand_storm = { 550, 0.5 },
	modifier_dark_seer_ion_shell = { 275, 0.1 },
	modifier_ember_spirit_flame_guard = { 425, 0.2 },
	modifier_juggernaut_blade_fury = { 275, 0.2 },
	modifier_leshrac_diabolic_edict = { 525, 0.25 },
	modifier_phoenix_sun_ray = { 1325, 0.2 },
	modifier_slark_dark_pact = { 350, 1.5 },
	modifier_slark_dark_pact_pulses = { 350, 0.1 },
	modifier_gyrocopter_rocket_barrage = { 425, 0.1 }
		}

AIO_Umbrella.RawDamageAbilityEstimation = {
	zuus_thundergods_wrath = { "no target", 0, 99999, 150, 0, 0 },
	puck_waning_rift = { "no target", 0, 400, 75, 0, 0 },
	ogre_magi_fireblast = { "target", 0, 0, 75, 0, 0 },
	obsidian_destroyer_astral_imprisonment = { "target", 0, 0, 75, 0, 0 },
	obsidian_destroyer_sanity_eclipse = { "position", 700, 575, 250, 0, 0 },
	necrolyte_reapers_scythe = { "target", 0, 0, 250, 0, 0 },
	magnataur_reverse_polarity = { "no target", 0, 410, 200, 0, 0 },
	lion_finger_of_death = { "target", 0, 0, 250, 0, 0 },
	lina_laguna_blade = { "target", 0, 0, 300, 0, 0 },
	legion_commander_duel = { "target", 0, 0, 250, 0, 0 },
	earthshaker_fissure = { "position", 0, 225, 75, 0, 0 },
	doom_bringer_doom = { "target", 0, 0, 150, 0, 0 },
	centaur_hoof_stomp = { "no target", 0, 315, 75, 0, 0 },
	bloodseeker_rupture = { "target", 0, 0, 150, 0, 0 },
	antimage_mana_void = { "position", 600, 500, 250, 0, 0 },
	queenofpain_sonic_wave = { "position", 0, 450, 170, 900, 0 },
	pudge_dismember = { "target", 0, 0, 75, 0, 0 },
	slardar_slithereen_crush = { "no target", 0, 350, 75, 0, 0 },
	bane_brain_sap = { "target", 0, 0, 75, 0, 0 },
	bane_fiends_grip = { "target", 0, 0, 500, 0, 0 },
	beastmaster_wild_axes = { "position", 0, 250, 75, 1200, 0 },
	bloodseeker_blood_bath = { "position", 0, 600, 60, 0, 2.6 },
	brewmaster_thunder_clap = { "no target", 0, 400, 75, 0, 0 },
	centaur_double_edge = { "target", 190, 0, 100, 0, 0 },
	chen_test_of_faith = { "target", 0, 0, 75, 0, 0 },
	crystal_maiden_crystal_nova = { "position", 0, 425, 75, 0, 0 },
	dragon_knight_breathe_fire = { "position", 0, 250, 75, 1050, 0 },
	gyrocopter_call_down = { "position", 0, 600, 150, 0, 2 },
	kunkka_torrent = { "position", 0, 225, 75, 0, 1.6 },
	zuus_lightning_bolt = { "position", 0, 325, 75, 0, 0 },
	legion_commander_overwhelming_odds = { "position", 0, 330, 75, 0, 0 },
	beastmaster_primal_roar = { "no target", 950, 300, 100, 0, 0 },
	bristleback_quill_spray = { "no target", 0, 700, 30, 2400, 0 },
	crystal_maiden_freezing_field = { "no target", 0, 835, 150, 0, 0 },
	dazzle_poison_touch = { "target", 0, 0, 50, 0, 0 },
	death_prophet_carrion_swarm = { "position", 0, 300, 75, 1100, 0 },
	earth_spirit_boulder_smash = { "target", 0, 0, 50, 0, 0 },	
	invoker_tornado = { "position", 0, 200, 300, 1000, 0 },
	invoker_chaos_meteor = { "position", 0, 275, 400, 0, 1.3 },
	invoker_deafening_blast = { "position", 0, 225, 300, 1100, 0 },
	invoker_emp = { "position", 0, 675, 300, 0, 2.9 },	
	jakiro_macropyre = { "position", 0, 260, 125, 0, 0 },
	juggernaut_omni_slash = { "target", 0, 0, 200, 0, 0 },
	kunkka_ghostship = { "position", 0, 425, 125, 650, 2.7 },	
	leshrac_split_earth = { "position", 0, 225, 75, 0, 0.35 },
	leshrac_lightning_storm = { "target", 0, 0, 50, 0, 0 },
	lich_frost_nova = { "position", 0, 200, 50, 0, 0 },
	lina_light_strike_array = { "position", 0, 225, 60, 0, 0.5 },
	lina_dragon_slave = { "position", 0, 275, 75, 1200, 0 },
	luna_lucent_beam = { "target", 0, 0, 75, 0, 0 },
	luna_eclipse = { "no target", 0, 675, 150, 0, 0 },	
	magnataur_shockwave = { "position", 0, 150, 75, 1050, 0 },
	meepo_poof = { "no target", 0, 375, 75, 0, 0 },
	monkey_king_boundless_strike = { "position", 0, 150, 100, 0, 0 },
	morphling_waveform = { "position", 0, 200, 75, 1250, 0 },	
	naga_siren_rip_tide = { "no target", 0, 320, 75, 0, 0 },
	nevermore_shadowraze1 = { "position", 200, 250, 75, 0, 0 },
	nevermore_shadowraze2 = { "position", 450, 250, 75, 0, 0 },
	nevermore_shadowraze3 = { "position", 700, 250, 75, 0, 0 },
	night_stalker_void = { "target", 0, 0, 75, 0, 0 },
	nyx_assassin_mana_burn = { "target", 0, 0, 75, 0, 0 },
	ogre_magi_unrefined_fireblast = { "target", 0, 0, 75, 0, 0 },
	omniknight_purification = { "position", 575, 260, 100, 0, 0 },
	oracle_purifying_flames = { "target", 0, 0, 75, 0, 0 },
	puck_dream_coil = { "position", 0, 375, 150, 0, 0 },
	pudge_meat_hook = { "position", 0, 100, 100, 1450, 0 },
	pugna_nether_blast = { "position", 0, 400, 75, 0, 0.9 },
	razor_plasma_field = { "no target", 0, 700, 80, 636, 0 },
	razor_eye_of_the_storm = { "no target", 0, 500, 100, 0, 0 },
	rubick_fade_bolt = { "target", 0, 0, 75, 0, 0 },
	rubick_telekinesis = { "target", 0, 0, 75, 0, 0 },
	sandking_burrowstrike = { "position", 0, 150, 75, 2000, 0 },
	sandking_epicenter = { "no target", 0, 525, 200, 0, 0 },
	shadow_demon_demonic_purge = { "target", 0, 0, 125, 0, 0 },
	shadow_shaman_ether_shock = { "target", 0, 0, 75, 0, 0 },
	shredder_whirling_death = { "no target", 0, 300, 75, 0, 0 },
	shredder_chakram = { "position", 0, 200, 100, 900, 0 },
	shredder_chakram_2 = { "position", 0, 200, 100, 900, 0 },
	slark_pounce = { "position", 700, 95, 60, 933.33, 0 },
	spirit_breaker_nether_strike = { "target", 0, 0, 125, 0, 1 },
	storm_spirit_static_remnant = { "no target", 0, 235, 75, 0, 0 },
	techies_suicide = { "target", 0, 0, 300 },	
	tidehunter_anchor_smash = { "no target", 0, 375, 75, 0, 0 },
	tinker_laser = { "target", 0, 0, 75, 0, 0 },
	tiny_avalanche = { "position", 0, 275, 75, 0, 0 },
	troll_warlord_whirling_axes_melee = { "no target", 0, 450, 75, 0, 0 },
	troll_warlord_whirling_axes_ranged = { "position", 0, 100, 45, 1500, 0 },
	tusk_ice_shards = { "position", 0, 200, 75, 1200, 0 },
	tusk_walrus_punch = { "target", 0, 0, 200, 0, 0 },
	undying_decay = { "position", 0, 325, 75, 0, 0 },
	ursa_earthshock = { "no target", 0, 385, 75, 0, 0 },
	vengefulspirit_wave_of_terror = { "position", 0, 300, 40, 2000, 0 },
	windrunner_powershot = { "position", 0, 125, 175, 3000, 0 },
	witch_doctor_death_ward = { "target", 0, 0, 200, 0, 0 },	
	zuus_arc_lightning = { "target", 0, 0, 35, 0, 0 },
	dark_willow_bedlam = { "no target", 0, 300, 175, 0, 0 },
	pangolier_shield_crash = { "no target", 0, 500, 75, 0, 0 },
	axe_berserkers_call = { "no target", 0, 400, 100, 0, 0 },
	batrider_flaming_lasso = { "target", 0, 0, 150, 0, 0 },
	crystal_maiden_frostbite = { "target", 0, 0, 100, 0, 0 },
	earthshaker_enchant_totem = { "no target", 0, 300, 100, 0, 0 },
	enigma_black_hole = { "position", 275, 420, 175, 0, 0 },
	faceless_void_chronosphere = { "position", 600, 600, 175, 0, 0 },
	sandking_burrowstrike = { "position", 0, 150, 100, 2000, 0 },
	shadow_shaman_shackles = { "target", 0, 0, 150, 0, 0 },
	storm_spirit_electric_vortex = { "target", 0, 0, 100, 0, 0 },
	warlock_rain_of_chaos = { "position", 0, 600, 150, 0, 0 },
	tidehunter_ravage = { "no target", 0, 1250, 150, 725, 0 },
	tidehunter_gush = { "target", 0, 0, 75, 2500, 0 }
		}

AIO_Umbrella.NeutralListComplete = {
	"npc_dota_neutral_alpha_wolf",
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_centaur_outrunner",
	"npc_dota_neutral_dark_troll_warlord",
	"npc_dota_neutral_fel_beast",
	"npc_dota_neutral_ghost",
	"npc_dota_neutral_giant_wolf",
	"npc_dota_neutral_harpy_scout",
	"npc_dota_neutral_harpy_storm",
	"npc_dota_neutral_polar_furbolg_champion",
	"npc_dota_neutral_polar_furbolg_ursa_warrior",
	"npc_dota_neutral_dark_troll",
	"npc_dota_neutral_forest_troll_berserker",
	"npc_dota_neutral_forest_troll_high_priest",
	"npc_dota_neutral_kobold",
	"npc_dota_neutral_kobold_tunneler",
	"npc_dota_neutral_kobold_taskmaster",
	"npc_dota_neutral_mud_golem",
	"npc_dota_neutral_ogre_mauler",
	"npc_dota_neutral_ogre_magi",
	"npc_dota_neutral_satyr_trickster",
	"npc_dota_neutral_satyr_soulstealer",
	"npc_dota_neutral_satyr_hellcaller",
	"npc_dota_neutral_gnoll_assassin",
	"npc_dota_neutral_wildkin",
	"npc_dota_neutral_enraged_wildkin"
		}

AIO_Umbrella.NeutralMainNPCsmall = {
	"npc_dota_neutral_kobold_taskmaster",
	"npc_dota_neutral_forest_troll_berserker",
	"npc_dota_neutral_gnoll_assassin",
	"npc_dota_neutral_ghost",
	"npc_dota_neutral_harpy_storm"
		}

AIO_Umbrella.NeutralMainNPCmedium = {
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_alpha_wolf",
	"npc_dota_neutral_satyr_soulstealer",
	"npc_dota_neutral_ogre_mauler",
	"npc_dota_neutral_mud_golem"
		}

AIO_Umbrella.NeutralMainNPChard = {
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_satyr_hellcaller",
	"npc_dota_neutral_polar_furbolg_ursa_warrior",
	"npc_dota_neutral_enraged_wildkin",
	"npc_dota_neutral_dark_troll_warlord"
		}

AIO_Umbrella.preemptiveBKB = {}
for i = 1, #AIO_Umbrella.preemptiveBKBtable do
	AIO_Umbrella.preemptiveBKB[i] = Menu.AddOption({ "Utility","All In One", "2. Item Usage", "2. Defensive Items", "1. BKB", "3. dangerous disables" }, AIO_Umbrella.preemptiveBKBtable[i], "")
end

AIO_Umbrella.dodgeItOptionTable = {}
for i = 1, #AIO_Umbrella.dodgeItItems do
	AIO_Umbrella.dodgeItOptionTable[i] = Menu.AddOption({ "Utility","All In One", "98. <BETA> DodgeIt", "1. Dodge items order" }, i .. ". " .. AIO_Umbrella.dodgeItItems[i][1].." ".."{{dodger}}", "if value == 0 then item will not be used; lower numbers will be used first", 0, #AIO_Umbrella.dodgeItItems, 1)
end

AIO_Umbrella.dodgeEnemySkillsOptionsTable = {}
for i = 1, 20 do
	AIO_Umbrella.dodgeEnemySkillsOptionsTable[AIO_Umbrella.dodgeEnemySkillsTable[i]] = Menu.AddOption({ "Utility","All In One", "98. <BETA> DodgeIt", "3. Dangerous enemy skills", "Table 1" }, AIO_Umbrella.dodgeEnemySkillsTable[i].." ".."{{dodger}}", "if enabled, skill will be dodged")
end
for i = 21, 40 do
	AIO_Umbrella.dodgeEnemySkillsOptionsTable[AIO_Umbrella.dodgeEnemySkillsTable[i]] = Menu.AddOption({ "Utility","All In One", "98. <BETA> DodgeIt", "3. Dangerous enemy skills", "Table 2" }, AIO_Umbrella.dodgeEnemySkillsTable[i].." ".."{{dodger}}", "if enabled, skill will be dodged")
end
for i = 41, #AIO_Umbrella.dodgeEnemySkillsTable do
	AIO_Umbrella.dodgeEnemySkillsOptionsTable[AIO_Umbrella.dodgeEnemySkillsTable[i]] = Menu.AddOption({ "Utility","All In One", "98. <BETA> DodgeIt", "3. Dangerous enemy skills", "Table 3" }, AIO_Umbrella.dodgeEnemySkillsTable[i].." ".."{{dodger}}", "if enabled, skill will be dodged")
end

AIO_Umbrella.dodgeEnemyHeroskillsOptionsTable = {}
for i = 1, #AIO_Umbrella.dodgeItSkills do
	AIO_Umbrella.dodgeEnemyHeroskillsOptionsTable[AIO_Umbrella.dodgeItSkills[i][1]] = Menu.AddOption({ "Utility","All In One", "98. <BETA> DodgeIt", "2. Select myHero skills" }, AIO_Umbrella.dodgeItSkills[i][1].." ".."{{dodger}}", "if not enabled, skill will not be used to dodge; only uses skill, if attack can be dodged with this skill")
end

AIO_Umbrella.dodgeEnemyHeroSpecialEmber = Menu.AddOption({ "Utility","All In One", "98. <BETA> DodgeIt", "2. Select myHero skills" }, "ember_spirit_remnant {{dodger}}", "if not enabled, skill will not be used to dodge; only uses skill, if attack can be dodged with this skill")

function AIO_Umbrella.ResetGlobalVariables()

	AIO_Umbrella.LockedTarget = nil
	AIO_Umbrella.myUnitName = nil
	AIO_Umbrella.lastCastTime = 0
	AIO_Umbrella.lastCastTime2 = 0
	AIO_Umbrella.lastCastTime3 = 0
	AIO_Umbrella.lastTick = 0
	AIO_Umbrella.delay = 0
	AIO_Umbrella.itemDelay = 0
	AIO_Umbrella.lastItemCast = 0
	AIO_Umbrella.lastDefItemPop = 0
	AIO_Umbrella.lastItemTick = 0
	AIO_Umbrella.ItemCastStop = false
	AIO_Umbrella.isArmletManuallyToggled = false
	AIO_Umbrella.isArmletManuallyToggledTime = 0
	AIO_Umbrella.armletDelayer = 0
	AIO_Umbrella.ControlledUnitCastTime = 0
	AIO_Umbrella.ControlledUnitPauseTime = 0
	AIO_Umbrella.lastAttackTime = 0
	AIO_Umbrella.lastAttackTime2 = 0
	AIO_Umbrella.LastTarget = nil
	AIO_Umbrella.LastTickManta1 = 0
	AIO_Umbrella.LastTickManta2 = 0
	AIO_Umbrella.ArcWardenEntity = nil
	AIO_Umbrella.ArcWardenEntityAnimationStart = 0
	AIO_Umbrella.ArcWardenEntityAnimationEnd = 0
	AIO_Umbrella.arcWardenPanelX = 0
	AIO_Umbrella.arcWardenPanelY = 0
	AIO_Umbrella.ArcTempestLockedTarget = nil
	AIO_Umbrella.ArcTempestLockedTargetParticle = 0
	AIO_Umbrella.ArcTempestLockedTargetParticleHero = nil
	AIO_Umbrella.arcWardenMagneticCastTime = 0
	AIO_Umbrella.arcWardenPushMode = false
	AIO_Umbrella.arcWardenPusher = false
	AIO_Umbrella.arcWardenPushModeLine = false
	AIO_Umbrella.arcWardenStatus = 0
	AIO_Umbrella.ArcTempestLockedTargetPos = Vector()
	AIO_Umbrella.ArcTempestLockedTargetPosTimer = 0
	AIO_Umbrella.TempestInAttackBackswing = false
	AIO_Umbrella.TempestOrbwalkerDelay = 0
	AIO_Umbrella.ArcWardenEntityProjectileCreate = 0
	AIO_Umbrella.GenericUpValue = false
	AIO_Umbrella.lastPosition = Vector(0, 0, 0)
	AIO_Umbrella.PuckOrbCastTime = 0
	AIO_Umbrella.Toggler = false
	AIO_Umbrella.TogglerTime = 0
	AIO_Umbrella.PreInvoke = false
	AIO_Umbrella.InvokerComboSelector = 0
	AIO_Umbrella.InvokerLastCastedSkill = nil
	AIO_Umbrella.InvokerLastCastedSkillTime = 0
	AIO_Umbrella.InvokerLastChangedInstance = 0
	AIO_Umbrella.InvokerCaptureManualInstances = 0
	AIO_Umbrella.invokerChannellingKillstealTimer = 0
	AIO_Umbrella.invokerCaptureGhostwalkActivation = 0
	AIO_Umbrella.getInvokerGhostWalkKey = nil
	AIO_Umbrella.invokerDisplayNeedsInit = true
	AIO_Umbrella.getInvokerSettings = nil
	AIO_Umbrella.InvokerCanComboStart = false
	AIO_Umbrella.AttackProjectileCreate = 0
	AIO_Umbrella.AttackAnimationCreate = 0
	AIO_Umbrella.AttackParticleCreate = 0
	AIO_Umbrella.InAttackBackswing = false
	AIO_Umbrella.OrbwalkerDelay = 0
	AIO_Umbrella.TPParticleIndex = nil
	AIO_Umbrella.TPParticleTime = 0
	AIO_Umbrella.TPParticleUnit = nil
	AIO_Umbrella.TPParticlePosition = Vector()
	AIO_Umbrella.GlimpseParticleIndex = nil
	AIO_Umbrella.GlimpseParticleTime = 0
	AIO_Umbrella.GlimpseParticleUnit = nil
	AIO_Umbrella.GlimpseParticlePosition = Vector()
	AIO_Umbrella.GlimpseParticleIndexStart = nil
	AIO_Umbrella.GlimpseParticlePositionStart = Vector()
	AIO_Umbrella.particleNextTime = 0
	AIO_Umbrella.currentParticle = 0
	AIO_Umbrella.currentParticleTarget = nil
	AIO_Umbrella.skywrathDMGwithoutUlt = 0
	AIO_Umbrella.skywrathDMGwithUlt = 0
	AIO_Umbrella.skywrathComboSelect = false
	AIO_Umbrella.clockwerkHookUpValue = false
	AIO_Umbrella.enemyCanBeShackled = false
	AIO_Umbrella.dodgeTiming = 0
	AIO_Umbrella.dodgerProjectileAdjustmentTick = 0
	AIO_Umbrella.saverTiming = 0
	AIO_Umbrella.VisageInstStunLockTarget = nil
	AIO_Umbrella.VisagePanicTarget = nil
	AIO_Umbrella.morphlingComboSelect = false
	AIO_Umbrella.morphlingTotalDMG = 0
	AIO_Umbrella.morphlingTotalDMGwoWave = 0
	AIO_Umbrella.MorphBalanceTimer = 0
	AIO_Umbrella.MorphBalanceSelectedHP = 0
	AIO_Umbrella.MorphBalanceSelected = 0
	AIO_Umbrella.MorphBalanceToggler = true
	AIO_Umbrella.wardCaptureTiming = 0
	AIO_Umbrella.sentryImageHandle = nil
	AIO_Umbrella.obsImageHandle = nil
	AIO_Umbrella.wardDrawingRemove = 0
	AIO_Umbrella.necroDMGwithoutUlt = 0
	AIO_Umbrella.necroDMGwithUlt = 0
	AIO_Umbrella.necroComboSelect = false
	AIO_Umbrella.magnusLastPos = Vector()
	AIO_Umbrella.SFcurrentParticle1 = 0
	AIO_Umbrella.SFcurrentParticle2 = 0
	AIO_Umbrella.SFcurrentParticle3 = 0
	AIO_Umbrella.SFParticleUpdateTime = 0
	AIO_Umbrella.armletRightClickToggle = false
	AIO_Umbrella.armletRightClickToggleTimer = 0
	AIO_Umbrella.armletRightClickDoubleClick = 0
	AIO_Umbrella.isArmletActive = false
	AIO_Umbrella.armletCurrentHPGain = 0
	AIO_Umbrella.armletToggleTime = 0
	AIO_Umbrella.armletToggleTimePingAdjuster = 0
	AIO_Umbrella.armletProjectileAdjustmentTick = 0
	AIO_Umbrella.armletDamageInstanceTable = {}
	AIO_Umbrella.lastHitterDelay = 0
	AIO_Umbrella.lastHitterOrbSkill = nil
	AIO_Umbrella.lastHitterOrbSkillEnemy = nil
	AIO_Umbrella.lastHitterKillableImage = nil
	AIO_Umbrella.kunkkaXMarkPosition = Vector()
	AIO_Umbrella.kunkkaGhostshipTimer = 0
	AIO_Umbrella.kunkkaXMarkCastTime = 0
	AIO_Umbrella.TinkerStatus = 0
	AIO_Umbrella.TinkerPusher = false
	AIO_Umbrella.TinkerPorted = false
	AIO_Umbrella.TinkerJungle = false
	AIO_Umbrella.TinkerMarched = 0
	AIO_Umbrella.TinkerGlimmerCastTime = 0
	AIO_Umbrella.TinkerPanicRearmBlink = 0
	AIO_Umbrella.TinkerPanelX = 0
	AIO_Umbrella.TinkerPanelY = 0
	AIO_Umbrella.TinkerPushMode = false
	AIO_Umbrella.TinkerPushCreeps = 3
	AIO_Umbrella.TinkerPushEnemies = 0
	AIO_Umbrella.TinkerPushAllies = 0
	AIO_Umbrella.TinkerPushJungle = true
	AIO_Umbrella.TinkerPushSave = true
	AIO_Umbrella.TinkerPushDefend = true
	AIO_Umbrella.PudgeRotComboActivation = false
	AIO_Umbrella.PudgeRotComboDeactivation = 0
	AIO_Umbrella.PudgeHookStartTimer = 0
	AIO_Umbrella.PudgeHookDelayer = 0
	AIO_Umbrella.PudgeHookRotDelayer = 0
	AIO_Umbrella.PudgeHookTarget = nil
	AIO_Umbrella.PudgeHookTargetedPos = nil
	AIO_Umbrella.PudgeHookHit = false
	AIO_Umbrella.PudgecurrentParticle = 0
	AIO_Umbrella.PudgecurrentParticleTarget = nil
	AIO_Umbrella.PudgeRotFarmToggled = false
	AIO_Umbrella.PudgeRotFarmToggledTime = 0
	AIO_Umbrella.TinkerJungleFarmPos = {}
	AIO_Umbrella.JungleTrackTable = {}
	AIO_Umbrella.ShrinePositionTable = {}
	AIO_Umbrella.wardDispenserCount = {}
	AIO_Umbrella.wardProcessingTable = {}
	AIO_Umbrella.lastHitCreepHPPrediction = {}
	AIO_Umbrella.lastHitCreepHPPredictionTime = {}
	AIO_Umbrella.creepAttackPointData = {}
	AIO_Umbrella.dodgeItTable = {}
	AIO_Umbrella.dodgeItSkillReady = {}
	AIO_Umbrella.dodgeItReadyTable = {}
	AIO_Umbrella.LinkensBreakerItemOrder = {}
	AIO_Umbrella.ItemCastOrder = {}
	AIO_Umbrella.rotationTable = {}
	AIO_Umbrella.PuckOrbHitSim = {}
	AIO_Umbrella.enemyHeroTable = {}
	AIO_Umbrella.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
	AIO_Umbrella.PreInvokeSkills = {}
	AIO_Umbrella.invokerCachedIcons = {}
	AIO_Umbrella.VisageFamiliarAttackCounter = {}
	AIO_Umbrella.heroIconHandler = {}
	AIO_Umbrella.itemIconHandler = {}
	AIO_Umbrella.ControllableEntityTable = {}
	AIO_Umbrella.ControllableAttackTiming = {}

end

function AIO_Umbrella.OnGameStart()
	
	AIO_Umbrella.ResetGlobalVariables()

end

function AIO_Umbrella.OnGameEnd()
	
	AIO_Umbrella.ResetGlobalVariables()

end
	
-- main callback
function AIO_Umbrella.OnUpdate()

	if not Menu.IsEnabled(AIO_Umbrella.optionEnable) then return end

	if not Engine.IsInGame() then
		AIO_Umbrella.ResetGlobalVariables()
	end
	
	if GameRules.GetGameState() < 4 then return end
	if GameRules.GetGameState() > 5 then return end

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Entity.IsAlive(myHero) then return end
		if AIO_Umbrella.myUnitName == nil then
			AIO_Umbrella.myUnitName = NPC.GetUnitName(myHero)
		end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroMorphReplicate) then
		local replicateMod = NPC.GetModifier(myHero, "modifier_morphling_replicate")
		if replicateMod then
			local checkAbility = NPC.GetAbilityByIndex(myHero, 0)
				if checkAbility == nil then
					checkAbility = NPC.GetAbilityByIndex(myHero, 1)
				end
			if checkAbility then
				local abilityName = Ability.GetName(checkAbility)
				local abilityNameShort = string.sub(abilityName, 1, string.find(abilityName, "_") - 1)
				local heroName = "npc_dota_hero_" .. abilityNameShort
				if heroName == "npc_dota_hero_skywrath" then
					heroName = "npc_dota_hero_skywrath_mage"
				elseif heroName == "npc_dota_hero_ember" then
					heroName = "npc_dota_hero_ember_spirit"
				elseif heroName == "npc_dota_hero_templar" then
					heroName = "npc_dota_hero_templar_assassin"
				elseif heroName == "npc_dota_hero_phantom" then
					if abilityName == "phantom_assassin_stifling_dagger" or abilityName == "phantom_assassin_phantom_strike" then
						heroName = "npc_dota_hero_phantom_assassin"
					end
				elseif heroName == "npc_dota_hero_obsidian" then
					heroName = "npc_dota_hero_obsidian_destroyer"
				elseif heroName == "npc_dota_hero_dark" then
					if abilityName == "dark_willow_bramble_maze" or abilityName == "dark_willow_shadow_realm" then
						heroName = "npc_dota_hero_dark_willow"
					end
				elseif heroName == "npc_dota_hero_arc" then
					heroName = "npc_dota_hero_arc_warden"
				elseif heroName == "npc_dota_hero_invoker" then
					heroName = "npc_dota_hero_morphling"
				elseif heroName == "npc_dota_hero_legion" then
					heroName = "npc_dota_hero_legion_commander"
				end
				if AIO_Umbrella.utilityIsInTable(AIO_Umbrella.heroList, heroName) then
					AIO_Umbrella.myUnitName = heroName
				end
			end
		else
			if NPC.GetUnitName(myHero) ~= AIO_Umbrella.myUnitName then
				AIO_Umbrella.myUnitName = NPC.GetUnitName(myHero)
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroMorphReplicateBack) then
		local replicateBack = NPC.GetAbility(myHero, "morphling_morph_replicate")
		if replicateBack and not Ability.IsHidden(replicateBack) and Ability.IsReady(replicateBack) then
			if AIO_Umbrella.heroCanCastSpells(myHero) == true then
				if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(AIO_Umbrella.optionHeroMorphReplicateBackHP) / 100 then
					Ability.CastNoTarget(replicateBack)
					return
				end
			end
		end
	end

	if next(AIO_Umbrella.ItemCastOrder) == nil then
		AIO_Umbrella.setOrderItem(false)
	end
 	if next(AIO_Umbrella.LinkensBreakerItemOrder) == nil then
		AIO_Umbrella.setOrderLinkens(false)
	end

	local isHeroSupported = AIO_Umbrella.heroSupported(myHero)

	local enemy = AIO_Umbrella.getComboTarget(myHero)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
		if Menu.GetValue(AIO_Umbrella.optionTargetStyle) < 1 then
			if AIO_Umbrella.LockedTarget == nil then
				if enemy then
					AIO_Umbrella.LockedTarget = enemy
				else
					AIO_Umbrella.LockedTarget = nil
				end
			end
		else
			if enemy then
				AIO_Umbrella.LockedTarget = enemy
			else
				AIO_Umbrella.LockedTarget = nil
			end
		end
	else
		AIO_Umbrella.LockedTarget = nil
	end

	if AIO_Umbrella.LockedTarget ~= nil then
		if not Entity.IsAlive(AIO_Umbrella.LockedTarget) then
			AIO_Umbrella.LockedTarget = nil
		elseif Entity.IsDormant(AIO_Umbrella.LockedTarget) then
			AIO_Umbrella.LockedTarget = nil
		elseif not NPC.IsEntityInRange(myHero, AIO_Umbrella.LockedTarget, 3000) then
			AIO_Umbrella.LockedTarget = nil
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionLockTargetIndicator) then
		AIO_Umbrella.TargetIndicator(myHero)
	end

	local comboTarget
		if AIO_Umbrella.LockedTarget ~= nil then
			comboTarget = AIO_Umbrella.LockedTarget
		else
			if not Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
				comboTarget = enemy
			end
		end
			
	if comboTarget then
		if isHeroSupported then
			if AIO_Umbrella.myUnitName == "npc_dota_hero_axe" then
				AIO_Umbrella.axeCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_rattletrap" then
				AIO_Umbrella.clockwerkCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_skywrath_mage" then
				AIO_Umbrella.skywrathCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_tiny" then
				AIO_Umbrella.tinyCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_windrunner" then
				AIO_Umbrella.WindRunnerCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_ember_spirit" then
				AIO_Umbrella.EmberCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_ursa" then
				AIO_Umbrella.UrsaCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_templar_assassin" then
				AIO_Umbrella.TACombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_slardar" then
				AIO_Umbrella.SlardarCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_queenofpain" then
				AIO_Umbrella.QoPCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_sven" then
				AIO_Umbrella.SvenCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_visage" then
				AIO_Umbrella.VisageCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_puck" then
				AIO_Umbrella.PuckCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_antimage" then
				AIO_Umbrella.AntiMageCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_phantom_assassin" then
				AIO_Umbrella.PACombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_obsidian_destroyer" then
				AIO_Umbrella.ODCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_silencer" then
				AIO_Umbrella.SilencerCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_dark_willow" then
				AIO_Umbrella.WillowCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_dazzle" then
				AIO_Umbrella.DazzleHelper(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_centaur" then
				AIO_Umbrella.centaurCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_ogre_magi" then
				AIO_Umbrella.OgreCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_ancient_apparition" then
				AIO_Umbrella.AACombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_nyx_assassin" then
				AIO_Umbrella.NyxCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_night_stalker" then
				AIO_Umbrella.NSCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_chaos_knight" then
				AIO_Umbrella.CKCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_witch_doctor" then
				AIO_Umbrella.WDCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_shadow_shaman" then
				AIO_Umbrella.SSCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_death_prophet" then
				AIO_Umbrella.DPCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_crystal_maiden" then
				AIO_Umbrella.CMCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_lion" then
				AIO_Umbrella.LionCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_pugna" then
				AIO_Umbrella.PugnaCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_undying" then
				AIO_Umbrella.UndyingCombo(myHero, comboTarget)
			elseif AIO_Umbrella.myUnitName == "npc_dota_hero_vengefulspirit" then
				AIO_Umbrella.VSCombo(myHero, comboTarget)
			end
		else
			if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(comboTarget) then	
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", comboTarget, nil)	
				AIO_Umbrella.itemUsage(myHero, comboTarget)
			end
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
		AIO_Umbrella.InvokerCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_arc_warden" then
		AIO_Umbrella.ArcWardenCombo(myHero, comboTarget)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_furion" then
		AIO_Umbrella.ProphetHelper(myHero, comboTarget)
	end
	
	if AIO_Umbrella.myUnitName == "npc_dota_hero_clinkz" then
		AIO_Umbrella.ClinkzCombo(myHero, comboTarget)
		if Menu.IsEnabled(AIO_Umbrella.optionHeroClinkzUlt) then
			AIO_Umbrella.ClinkzAutoUlt(myHero)
		end
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_legion_commander" then
		AIO_Umbrella.LegionCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_morphling" then
		AIO_Umbrella.MorphCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_necrolyte" then
		AIO_Umbrella.NecroCombo(myHero, comboTarget)
	end
	
	if AIO_Umbrella.myUnitName == "npc_dota_hero_magnataur" then
		AIO_Umbrella.magnusCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_nevermore" then
		AIO_Umbrella.SFCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_tinker" then
		AIO_Umbrella.TinkerCombo(myHero, comboTarget)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_axe" then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroAxeForceBlink) then
			AIO_Umbrella.ForceBlink(myHero, comboTarget, Menu.GetValue(AIO_Umbrella.optionHeroAxeForceBlinkRange))
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_centaur" then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroCentaurForceBlink) then
			AIO_Umbrella.ForceBlink(myHero, comboTarget, Menu.GetValue(AIO_Umbrella.optionHeroCentaurForceBlinkRange))
		end
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_shredder" then
		AIO_Umbrella.TimberCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_kunkka" then
		AIO_Umbrella.KunkkaShipCombo(myHero, enemy)
	end
	
	if AIO_Umbrella.myUnitName == "npc_dota_hero_zuus" then
		AIO_Umbrella.ZuusCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_huskar" then
		AIO_Umbrella.huskarCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_viper" then
		AIO_Umbrella.ViperCombo(myHero, comboTarget)
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_pudge" then
		AIO_Umbrella.PudgeCombo(myHero, comboTarget)
	end

	AIO_Umbrella.lastHitter(myHero)
	AIO_Umbrella.GetControllableEntities(myHero)
	AIO_Umbrella.GenericJungleTracker(myHero)

	if Menu.IsEnabled(AIO_Umbrella.optionDodgeItEnable) then	
		AIO_Umbrella.dodgerSelectItemorSkill(myHero)
		AIO_Umbrella.dodgerSkillAvailable(myHero)
		AIO_Umbrella.dodger(myHero)
	end
	
	if Menu.IsEnabled(AIO_Umbrella.optionUtilityEnable) then
		AIO_Umbrella.utilityItemUsage(myHero)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionKillStealEnable) then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
			if Menu.IsEnabled(AIO_Umbrella.optionKillStealInvoker) then
				AIO_Umbrella.AutoSunstrikeKillStealNew(myHero)
			end
		else
			AIO_Umbrella.AutoNukeKillSteal(myHero)
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItems) then
		AIO_Umbrella.useDefensiveItems(myHero, comboTarget)
	end
	
	if Menu.IsEnabled(AIO_Umbrella.optionWardAwareness) then
		AIO_Umbrella.wardProcessing(myHero)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmlet) then
		AIO_Umbrella.armletHandler(myHero)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemHurricane) then
		AIO_Umbrella.ItemAutoHurricaneUsage(myHero, comboTarget)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemBlademail) then
		AIO_Umbrella.ItemAutoBMUsage(myHero)
	end

	if AIO_Umbrella.LockedTarget == nil then
		if Menu.IsEnabled(AIO_Umbrella.optionMoveToCursor) then
			if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
				return
			end
		end	
	end

--	for i = 1, NPCs.Count() do
--	local npc = NPCs.Get(i)
--	Log.Write(tostring(NPC.GetUnitName(npc)) .. " " .. tostring(Entity.GetOwner(npc)) .. " " .. tostring(Entity.OwnedBy(npc, myHero)))
--	end

--	local modifiers = NPC.GetModifiers(myHero)
--	for _, modifier in ipairs(modifiers) do
--	local modifierName = Modifier.GetName(modifier)
--	Log.Write(modifierName)
--	end

--	for i = 1, Abilities.Count() do
--	local abilities = Abilities.Get(i)
--	local abilityNames = Ability.GetName(abilities)
--	Log.Write(abilityNames)
--	end

end

function AIO_Umbrella.getComboTarget(myHero)

	if not myHero then return end

	local targetingRange = Menu.GetValue(AIO_Umbrella.optionTargetRange)
	local mousePos = Input.GetWorldCursorPos()

	local enemyTable = Heroes.InRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)
		if #enemyTable < 1 then return end

	local nearestTarget = nil
	local distance = 99999

	for i, v in ipairs(enemyTable) do
		if v and Entity.IsHero(v) then
			if AIO_Umbrella.targetChecker(v) ~= nil then
				local enemyDist = (Entity.GetAbsOrigin(v) - mousePos):Length2D()
				if enemyDist < distance then
					nearestTarget = v
					distance = enemyDist
				end
			end
		end
	end

	return nearestTarget or nil

end

function AIO_Umbrella.OnEntityDestroy(ent)

	if not ent then return end

	if AIO_Umbrella.lastHitCreepHPPrediction[ent] ~= nil then
		AIO_Umbrella.lastHitCreepHPPrediction[ent] = nil
	end

	if AIO_Umbrella.lastHitCreepHPPredictionTime[ent] ~= nil then
		AIO_Umbrella.lastHitCreepHPPredictionTime[ent] = nil
	end

	if Entity.IsNPC(ent) and NPC.IsNeutral(ent) then
		local minute = math.floor((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60)
		local entityPos = Entity.GetAbsOrigin(ent)
			entityPos:SetZ(0)

		for key, info in ipairs(AIO_Umbrella.JungleTrackTable) do
			local pos = info[1]		
			if (pos - entityPos):Length2D() < 1000 then
				local class = info[4]
				local checkTable = {}
					if class == "small" then
						checkTable = AIO_Umbrella.NeutralMainNPCsmall
					elseif class == "medium" then
						checkTable = AIO_Umbrella.NeutralMainNPCmedium
					else
						checkTable = AIO_Umbrella.NeutralMainNPChard
					end
				if next(checkTable) ~= nil then
					local checkValue = false
						for i, v in ipairs(checkTable) do
							if NPC.GetUnitName(ent) == v then
								checkValue = true
								break
							end
						end
					
					if checkValue then	
						if info[2] == true and (pos - entityPos):Length2D() < 1000 then
							AIO_Umbrella.JungleTrackTable[key][2] = false
							AIO_Umbrella.JungleTrackTable[key][3] = minute
							break
						end
					end
				end
			end
		end
	end

	if not Menu.IsEnabled(AIO_Umbrella.optionWardAwareness) then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionWardAwarenessRemove) then return end

	if not Heroes.GetLocal() then return end

	if not Entity.IsNPC(ent) then return end
	if Entity.IsSameTeam(Heroes.GetLocal(), ent) then return end
	if NPC.GetUnitName(ent) ~= "npc_dota_sentry_wards" and NPC.GetUnitName(ent) ~= "npc_dota_observer_wards" then return end

	if next(AIO_Umbrella.wardProcessingTable) ~= nil then
		for i, v in pairs(AIO_Umbrella.wardProcessingTable) do
			if v then
				if (v.pos - Entity.GetAbsOrigin(ent)):Length2D() <= 500 then
					AIO_Umbrella.wardProcessingTable[i] = nil
				end
			end
		end
	end

end

function AIO_Umbrella.OnParticleCreate(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	local enemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(Heroes.GetLocal()), Enum.TeamType.TEAM_ENEMY))

	if particle.name == "teleport_start" then
		if particle.entityForModifiers ~= nil and particle.entityForModifiers ~= Heroes.GetLocal() then
			if not Entity.IsSameTeam(Heroes.GetLocal(), particle.entityForModifiers) then
				AIO_Umbrella.TPParticleIndex = particle.index
				AIO_Umbrella.TPParticleTime = GameRules.GetGameTime()
				AIO_Umbrella.TPParticleUnit = particle.entityForModifiers
			end
		end
	end

	if particle.name == "furion_sprout" then
		if particle.entityForModifiers ~= nil and Entity.IsSameTeam(Heroes.GetLocal(), particle.entityForModifiers) then
			AIO_Umbrella.InvokerKSparticleProcess[1][1] = particle.index
			AIO_Umbrella.InvokerKSparticleProcess[1][2] = particle.name
			AIO_Umbrella.InvokerKSparticleProcess[1][3] = GameRules.GetGameTime()
			AIO_Umbrella.InvokerKSparticleProcess[1][4] = particle.entityForModifiers
		end
	end

	if particle.name == "rattletrap_cog_deploy" then
		if particle.entity ~= nil and Entity.IsSameTeam(Heroes.GetLocal(), particle.entity) then
			AIO_Umbrella.InvokerKSparticleProcess[1][1] = particle.index
			AIO_Umbrella.InvokerKSparticleProcess[1][2] = particle.name
			AIO_Umbrella.InvokerKSparticleProcess[1][3] = GameRules.GetGameTime()
			AIO_Umbrella.InvokerKSparticleProcess[1][4] = particle.entity
			AIO_Umbrella.InvokerKSparticleProcess[1][5] = Entity.GetAbsOrigin(particle.entity)
		end
	end

	if particle.name == "disruptor_glimpse_targetend" then
		AIO_Umbrella.GlimpseParticleIndex = particle.index
		AIO_Umbrella.GlimpseParticleTime = GameRules.GetGameTime()
	end

	if particle.name == "disruptor_glimpse_targetstart" then
		AIO_Umbrella.GlimpseParticleIndexStart = particle.index
	end
	
end

function AIO_Umbrella.OnParticleUpdate(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	if particle.position:__tostring() == Vector(1.0, 1.0, 1.0):__tostring() then return end
	if particle.position:__tostring() == Vector(0.0, 0.0, 0.0):__tostring() then return end
	if particle.position:Length() < 75 then return end

	if particle.index  == AIO_Umbrella.TPParticleIndex then
		if particle.controlPoint == 0 then
			AIO_Umbrella.TPParticlePosition = particle.position
		end
	end

	if particle.index  == AIO_Umbrella.InvokerKSparticleProcess[1][1] then
		if particle.position:__tostring() ~= Vector(0.0, 150.0, 0.0):__tostring() then
			AIO_Umbrella.InvokerKSparticleProcess[1][5] = particle.position
		end
	end

	if particle.index  == AIO_Umbrella.GlimpseParticleIndex then
		if particle.position:Length2D() > 100 then
			AIO_Umbrella.GlimpseParticlePosition = particle.position
		end
	end

end

function AIO_Umbrella.OnParticleUpdateEntity(particle)

	if not particle then return end

	if not Heroes.GetLocal() then return end	
	if not particle.position then return end
	if particle.controlPoint > 0 then return end

	if particle.index  == AIO_Umbrella.GlimpseParticleIndexStart then
		if particle.entity ~= nil and not Entity.IsSameTeam(Heroes.GetLocal(), particle.entity) then
			if particle.position:__tostring() ~= Vector(0.0, 0.0, 0.0):__tostring() then
				AIO_Umbrella.GlimpseParticlePositionStart = particle.position
				AIO_Umbrella.GlimpseParticleUnit = particle.entity
			end
		end
	end

end

function AIO_Umbrella.OnUnitAnimation(animation)

	if not animation then return end
	if not Heroes.GetLocal() then return end

	if Menu.IsEnabled(AIO_Umbrella.optionDodgeItEnable) then
		AIO_Umbrella.dodgeProcessing(Heroes.GetLocal(), animation.unit, animation.activity, animation.castpoint)
	end

	if animation.unit then
		if Entity.IsNPC(animation.unit) and not Entity.IsSameTeam(Heroes.GetLocal(), animation.unit) and not Entity.IsHero(animation.unit) and not Entity.IsDormant(animation.unit) and NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, 1000) then
			local name = NPC.GetUnitName(animation.unit)
			if AIO_Umbrella.creepAttackPointData[name] == nil then
				AIO_Umbrella.creepAttackPointData[name] = animation.castpoint
			else
				if animation.castpoint < AIO_Umbrella.creepAttackPointData[name] then
					AIO_Umbrella.creepAttackPointData[name] = animation.castpoint
				end
			end
		end
	end

	if Entity.IsNPC(animation.unit) and not NPC.IsRanged(animation.unit) then
		if NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, 1000) then
			if NPC.IsLaneCreep(animation.unit) then
				if AIO_Umbrella.lastHitterGetTarget(Heroes.GetLocal(), animation.unit) ~= nil then
					local targetCreep = AIO_Umbrella.lastHitterGetTarget(Heroes.GetLocal(), animation.unit)
					local creepHP = math.floor(Entity.GetHealth(targetCreep) + NPC.GetHealthRegen(targetCreep))
					local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * ((NPC.GetMinDamage(animation.unit) + NPC.GetBonusDamage(animation.unit)) * NPC.GetArmorDamageMultiplier(targetCreep)))
						if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
							creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * (((NPC.GetTrueMaximumDamage(animation.unit) + NPC.GetTrueDamage(animation.unit)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
						end
				--	local hitTime = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3)
					local hitTime = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035), 3)
					local sourceIndex = Entity.GetIndex(animation.unit)
					if AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] == nil then
						AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] = {}
						table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						if AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) > 0.45 then
							if creepHP > 2 * creepDMG then
								table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(animation.unit), creepDMG, sourceIndex })
							end
						end
					else
						local inserted = false
						for _, info in ipairs(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep]) do
							if info and info[3] == sourceIndex and math.abs(hitTime - info[1]) < 0.25 then
								inserted = true
							end
						end
						if not inserted then
							table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
							if AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) > 0.45 then
								if creepHP > 2 * creepDMG then
									table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(animation.unit), creepDMG, sourceIndex })
								end
							end
						else
							if AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) > 0.45 then
								if creepHP > 2 * creepDMG then
									table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(animation.unit), creepDMG, sourceIndex })
								end
							end
						end
					end
					local removeInstance = 0
					local removeTarget = nil
					for target, table in pairs(AIO_Umbrella.lastHitCreepHPPrediction) do
						if table then
							if target ~= targetCreep then
								for i, info in ipairs(table) do
									if info and info[3] == sourceIndex and info[1] > GameRules.GetGameTime() and math.abs(hitTime - info[1]) > 0.1 then
										removeInstance = i
										removeTarget = target
									end
								end
							end
						end
					end
					if removeInstance > 0 and removeTarget ~= nil then
						table.remove(AIO_Umbrella.lastHitCreepHPPrediction[removeTarget], removeInstance)
					end
				end
			else
				if Entity.IsHero(animation.unit) then
					if AIO_Umbrella.lastHitterGetTarget(Heroes.GetLocal(), animation.unit) ~= nil then
						local targetCreep = AIO_Umbrella.lastHitterGetTarget(Heroes.GetLocal(), animation.unit)
						local creepHP = math.floor(Entity.GetHealth(targetCreep) + NPC.GetHealthRegen(targetCreep))
						local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * ((NPC.GetMinDamage(animation.unit) + NPC.GetBonusDamage(animation.unit)) * NPC.GetArmorDamageMultiplier(targetCreep)))
							if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
								creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * (((NPC.GetTrueMaximumDamage(animation.unit) + NPC.GetTrueDamage(animation.unit)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
							end
						local hitTime = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035), 3)
						local sourceIndex = Entity.GetIndex(animation.unit)
						if AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] == nil then
							AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] = {}
							table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						else
							table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						end
					end
				end
			end
		end
	end

	if animation.unit and Entity.IsNPC(animation.unit) and not Entity.IsSameTeam(Heroes.GetLocal(), animation.unit) and animation.type == 1 then
		if not NPC.IsRanged(animation.unit) then
			local attackRange = NPC.GetAttackRange(animation.unit) + 155
			if NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, attackRange) and NPC.FindFacingNPC(animation.unit) == Heroes.GetLocal() then
				local damage = AIO_Umbrella.getAdjustedMaxTrueDamage(animation.unit, Heroes.GetLocal())
				table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(animation.unit), time = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = animation.castpoint, backswingstart = GameRules.GetGameTime() + animation.castpoint - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(animation.unit) - 0.035, type = "attack", damage = damage, isProjectile = false })
			end
		else
			local attackRange = NPC.GetAttackRange(animation.unit) + 264
			if Entity.IsHero(animation.unit) and NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, attackRange) and NPC.FindFacingNPC(animation.unit) == Heroes.GetLocal() then
				local myProjectedPosition = Entity.GetAbsOrigin(Heroes.GetLocal())
				local projectileTiming = ((Entity.GetAbsOrigin(animation.unit) - myProjectedPosition):Length2D() - NPC.GetHullRadius(Heroes.GetLocal())) / AIO_Umbrella.attackPointTable[NPC.GetUnitName(animation.unit)][3]
				local damage = AIO_Umbrella.getAdjustedMaxTrueDamage(animation.unit, Heroes.GetLocal())
				table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(animation.unit), time = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = animation.castpoint, backswingstart = GameRules.GetGameTime() + animation.castpoint - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(animation.unit) - 0.035, type = "rangeattack", damage = damage, projectileorigin = Entity.GetAbsOrigin(animation.unit), projectilestarttime = GameRules.GetGameTime() + animation.castpoint - 0.035, projectilespeed = AIO_Umbrella.attackPointTable[NPC.GetUnitName(animation.unit)][3], isProjectile = true })
			end
		end
	end

	if NPC.GetUnitName(Heroes.GetLocal()) ~= NPC.GetUnitName(animation.unit) then return end

	if AIO_Umbrella.ArcWardenEntity ~= nil then
		if animation.unit == AIO_Umbrella.ArcWardenEntity and animation.type == 1 then
			AIO_Umbrella.ArcWardenEntityAnimationStart = GameRules.GetGameTime() - 0.035
			AIO_Umbrella.ArcWardenEntityAnimationEnd = GameRules.GetGameTime() + animation.castpoint + 0.035
		end
	end

	if Heroes.GetLocal() ~= animation.unit then return end

	if animation.type == 1 then
		AIO_Umbrella.AttackAnimationCreate = os.clock()
		AIO_Umbrella.AttackParticleCreate = os.clock() + animation.castpoint
	end

end

function AIO_Umbrella.OnProjectile(projectile)

	if not projectile then return end

	local myHero = Heroes.GetLocal()
		if not myHero then return end

	local armletProjectileList = {
		"npc_dota_hero_abaddon",
		"npc_dota_hero_broodmother",
		"npc_dota_hero_dragon_knight",
		"npc_dota_hero_enchantress",
		"npc_dota_hero_oracle",
		"npc_dota_hero_phantom_assassin",
		"npc_dota_hero_queenofpain",
		"npc_dota_hero_skywrath_mage",
		"npc_dota_hero_tidehunter",
		"npc_dota_hero_tiny",
		"npc_dota_hero_visage",
		"npc_dota_hero_winter_wyvern",
		"npc_dota_hero_bounty_hunter",
		"npc_dota_hero_earthshaker",
		"npc_dota_hero_morphling",
		"npc_dota_hero_phantom_lancer",
		"npc_dota_hero_tinker",
		"npc_dota_hero_gyrocopter",
		"npc_dota_hero_mirana",
		"npc_dota_hero_spectre",
		"npc_dota_hero_treant",
		"npc_dota_hero_medusa",
		"npc_dota_hero_arcwarden",
		"npc_dota_hero_necrolyte",
		"npc_dota_hero_witch_doctor",
		"npc_dota_hero_tusk",
		"npc_dota_hero_huskar",
		"npc_dota_hero_nyx_assassin",
		"npc_dota_hero_lion",
		"npc_dota_hero_lich",
		"npc_dota_hero_chaos_knight",
		"npc_dota_hero_alchemist",
		"npc_dota_hero_skeleton_king",
		"npc_dota_hero_sniper",
		"npc_dota_hero_sven",
		"npc_dota_hero_vengefulspirit",
			}

	if projectile.source and Entity.IsNPC(projectile.source) and projectile.isAttack then
		if NPC.IsEntityInRange(Heroes.GetLocal(), projectile.source, 1250) then
			if NPC.IsLaneCreep(projectile.source) or NPC.IsTower(projectile.source) then
				if projectile.target and Entity.IsNPC(projectile.target) and (NPC.IsLaneCreep(projectile.target) or NPC.IsTower(projectile.target)) then
					local projectileSpeed = projectile.moveSpeed
					local distance = math.max((Entity.GetAbsOrigin(projectile.source) - Entity.GetAbsOrigin(projectile.target)):Length2D() - NPC.GetHullRadius(projectile.target) - NPC.GetHullRadius(projectile.source), 1)
					local travelTime = distance / projectileSpeed - 0.035
					local targetCreep = projectile.target
					local creepHP = Entity.GetHealth(targetCreep) + NPC.GetHealthRegen(targetCreep)
					local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * ((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * NPC.GetArmorDamageMultiplier(targetCreep)))
						if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
							creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * (((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
						end
						if Entity.GetClassName(projectile.source) == "C_DOTA_BaseNPC_Creep_Siege" and Entity.GetClassName(projectile.target) == "C_DOTA_BaseNPC_Creep_Siege" then
							creepDMG = math.ceil((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
								creepDMG = math.ceil(((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							end
						elseif Entity.GetClassName(projectile.source) == "C_DOTA_BaseNPC_Tower" and Entity.GetClassName(projectile.target) == "C_DOTA_BaseNPC_Creep_Siege" then
							creepDMG = math.ceil((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
								creepDMG = math.ceil(((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							end
						elseif Entity.GetClassName(projectile.source) == "C_DOTA_BaseNPC_Creep_Siege" and Entity.GetClassName(projectile.target) == "C_DOTA_BaseNPC_Tower" then
							creepDMG = math.ceil((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
								creepDMG = math.ceil(((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							end
						end
				--	local hitTime = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + travelTime - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3)
					local hitTime = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + travelTime - 0.035), 3)
					local sourceIndex = Entity.GetIndex(projectile.source)
					if AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] == nil then
						AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] = {}
						table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						if AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and travelTime < AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) * 1.2 then
							if creepHP > 2 * creepDMG then
								table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(projectile.source), creepDMG, sourceIndex })
							end
						end
					else
						local inserted = false
						local insertedKey = 0
						for i, info in ipairs(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep]) do
							if info and info[3] == sourceIndex then
								if info[1] > GameRules.GetGameTime() then
									if math.abs(hitTime - info[1]) < 0.25 then
										inserted = true
										insertedKey = i
									end
								end
							end
						end
						if not inserted then
							table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
							if AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and travelTime < AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) * 1.2 then
								if creepHP > 2 * creepDMG then
									table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(projectile.source), creepDMG, sourceIndex })
								end
							end
						else
							table.remove(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], insertedKey)
							table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
							if AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and travelTime < AIO_Umbrella.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) * 1.2 then
								if creepHP > 2 * creepDMG then
									table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(projectile.source), creepDMG, sourceIndex })
								end
							end
						end
					end
					local removeInstance = 0
					local removeTarget = nil
					for target, table in pairs(AIO_Umbrella.lastHitCreepHPPrediction) do
						if table then
							if target ~= targetCreep then
								for i, info in ipairs(table) do
									if info and info[3] == sourceIndex then
										if info[1] > GameRules.GetGameTime() and math.abs(hitTime - info[1]) > 0.1 then
											removeInstance = i
											removeTarget = target
										end
									end
								end
							end
						end
					end
					if removeInstance > 0 and removeTarget ~= nil then
						table.remove(AIO_Umbrella.lastHitCreepHPPrediction[removeTarget], removeInstance)
					end
				end
			else
				if Entity.IsHero(projectile.source) then
					if projectile.target and Entity.IsNPC(projectile.target) and (NPC.IsLaneCreep(projectile.target) or NPC.IsTower(projectile.target)) then
						local projectileSpeed = projectile.moveSpeed
						local distance = math.max((Entity.GetAbsOrigin(projectile.source) - Entity.GetAbsOrigin(projectile.target)):Length2D() - NPC.GetHullRadius(projectile.target) - NPC.GetHullRadius(projectile.source), 1)
						local travelTime = distance / projectileSpeed - 0.035
						local targetCreep = projectile.target
						local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * ((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * NPC.GetArmorDamageMultiplier(targetCreep)))
							if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
								creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * (((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
							end
						local hitTime = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + travelTime - 0.035), 3)
						local sourceIndex = Entity.GetIndex(projectile.source)
						if AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] == nil then
							AIO_Umbrella.lastHitCreepHPPrediction[targetCreep] = {}
							table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						else
							table.insert(AIO_Umbrella.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						end
					end
				end	
			end
		end
	end

	if projectile.source and Entity.GetClassName(projectile.source) == "C_DOTA_Unit_VisageFamiliar" then

		local familiarAttackTime = NPC.GetAttackTime(projectile.source)
		if AIO_Umbrella.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)] == nil then
			AIO_Umbrella.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)] = { GameRules.GetGameTime(), 1 }
		else
			if AIO_Umbrella.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][1] + familiarAttackTime * 1.5 > GameRules.GetGameTime() then
				AIO_Umbrella.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][1] = GameRules.GetGameTime()
				AIO_Umbrella.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][2] = AIO_Umbrella.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][2] + 1
			else
				AIO_Umbrella.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)] = { GameRules.GetGameTime(), 1 }
			end
		end
	end

	if projectile.source and Entity.IsNPC(projectile.source) and NPC.IsRanged(projectile.source) and not Entity.IsSameTeam(Heroes.GetLocal(), projectile.source) and projectile.isAttack then
		local attackRange = NPC.GetAttackRange(projectile.source)
		if not Entity.IsHero(projectile.source) then
			if projectile.target == Heroes.GetLocal() then
				local casttime = 0.5
					if AIO_Umbrella.creepAttackPointData[NPC.GetUnitName(projectile.source)] ~= nil then
						casttime = AIO_Umbrella.creepAttackPointData[NPC.GetUnitName(projectile.source)]
					end
				local myProjectedPosition = Entity.GetAbsOrigin(myHero)
				local projectileTiming = ((Entity.GetAbsOrigin(projectile.source) - myProjectedPosition):Length() - NPC.GetHullRadius(projectile.target)) / projectile.moveSpeed
				local damage = AIO_Umbrella.getAdjustedMaxTrueDamage(projectile.source, Heroes.GetLocal())
				table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(projectile.source), time = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = casttime, backswingstart = GameRules.GetGameTime() - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(projectile.source) - casttime - 0.035, type = "rangeattack", damage = damage, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
			end
		else
			if projectile.target == Heroes.GetLocal() then
				local myProjectedPosition = Entity.GetAbsOrigin(myHero)
				local projectileTiming = ((Entity.GetAbsOrigin(projectile.source) - myProjectedPosition):Length2D() - NPC.GetHullRadius(projectile.target)) / projectile.moveSpeed
				local damage = AIO_Umbrella.getAdjustedMaxTrueDamage(projectile.source, Heroes.GetLocal())
				local inserted = false
				for k, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
					if info and info.instanceindex == Entity.GetIndex(projectile.source) then
						if math.abs(info.time - AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3)) < NPC.GetAttackTime(projectile.source) * 0.75 then
							inserted = true
						end
					end
				end
				if not inserted then
					local casttime = AIO_Umbrella.attackPointTable[NPC.GetUnitName(projectile.source)][1] / (1 + NPC.GetIncreasedAttackSpeed(projectile.source))
					table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(projectile.source), time = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = casttime, backswingstart = GameRules.GetGameTime() - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(projectile.source) - casttime - 0.035, type = "rangeattack", damage = damage, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
				end	
			end
		end
	end

	if projectile.source and Entity.IsNPC(projectile.source) and not projectile.isAttack and projectile.name ~= "rod_of_atos_attack" then
		if projectile.target == Heroes.GetLocal() then
			local myProjectedPosition = Entity.GetAbsOrigin(myHero)
			local projectileTiming = ((Entity.GetAbsOrigin(projectile.source) - myProjectedPosition):Length2D() - NPC.GetHullRadius(projectile.target)) / projectile.moveSpeed
			if not Entity.IsSameTeam(Heroes.GetLocal(), projectile.source) then
				if projectile.name ~= "nullifier_proj" then
					local insert = false
					for i, v in ipairs(armletProjectileList) do
						if v and v == NPC.GetUnitName(projectile.source) then
							insert = true
						end
					end
					if insert then
						table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = projectile.name, time = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = 0, type = "ability", damage = 250, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
					end
				else
					table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = projectile.name, time = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = 0, type = "ability", damage = 1000, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
				end	
			else
				if projectile.name == "medusa_mystic_snake_projectile" or projectile.name == "earthshaker_echoslam" or projectile.name == "bounty_hunter_suriken_toss" or projectile.name == "wyvern_splinter_blast" then
					table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = projectile.name, time = AIO_Umbrella.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = 0, type = "ability", damage = 250, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime(), projectilespeed = projectile.moveSpeed, isProjectile = true })
				end
			end
		end
	end

	if AIO_Umbrella.ArcWardenEntity ~= nil then
		if projectile.source == AIO_Umbrella.ArcWardenEntity and projectile.isAttack then
			AIO_Umbrella.ArcWardenEntityProjectileCreate = GameRules.GetGameTime() - 0.035
		end
	end

	if projectile.source ~= Heroes.GetLocal() then return end
	if not projectile.isAttack then return end

	AIO_Umbrella.AttackProjectileCreate = os.clock()

end

function AIO_Umbrella.OnLinearProjectileCreate(projectile)
	
	if not projectile or not projectile.source then return end
	
	if projectile.name ~= "puck_illusory_orb" then return end
	
	AIO_Umbrella.PuckOrbHitSim = {{projectile.origin, projectile.velocity}}

	
end

function AIO_Umbrella.OnParticleDestroy(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	if particle.index  == AIO_Umbrella.TPParticleIndex then
		AIO_Umbrella.TPParticlePosition = Vector()
		AIO_Umbrella.TPParticleTime = 0
		AIO_Umbrella.TPParticleUnit = nil
	end

end

function AIO_Umbrella.OnDraw()

	local myHero = Heroes.GetLocal()
        	if not myHero then return end
		if not Entity.IsAlive(myHero) then return end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_morphling" then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroMorphlingKill) then
			AIO_Umbrella.drawMorphlingKillIndicator(myHero)
		end
		if Menu.IsEnabled(AIO_Umbrella.optionHeroMorphDrawBoard) then
			AIO_Umbrella.MorphDrawBalanceBoard(myHero)
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_arc_warden" then
		AIO_Umbrella.drawArcWardenPanel(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_furion" then
		if Menu.IsEnabled(AIO_Umbrella.optionProphetDrawToggle) then
			AIO_Umbrella.DrawProphetHelperSwitch()
		end
		if Menu.IsEnabled(AIO_Umbrella.optionProphetDrawKS) or Menu.IsEnabled(AIO_Umbrella.optionProphetDrawKSminimap) then
			AIO_Umbrella.DrawProphetAwareness(myHero)
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
		AIO_Umbrella.InvokerDraw(myHero)
		AIO_Umbrella.InvokerDrawShort(myHero)
		AIO_Umbrella.invokerDisplayDrawDisplay(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_phantom_assassin" then
		AIO_Umbrella.DrawPADaggerSwitch()
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_skywrath_mage" then
		AIO_Umbrella.skywrathComboDrawDamage(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_necrolyte" then
		AIO_Umbrella.necroComboDrawDamage(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_nevermore" then
		AIO_Umbrella.SFComboDrawRequiemDamage(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_rattletrap" then
		AIO_Umbrella.clockwerkDrawHookIndicator(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_windrunner" then
		AIO_Umbrella.windrunnerDrawShackleIndicator(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_tinker" then
		AIO_Umbrella.drawTinkerPanel(myHero)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionWardAwareness) then
		AIO_Umbrella.drawWard(myHero)
	end

	AIO_Umbrella.lastHitterDrawing(myHero)

end

function AIO_Umbrella.OnPrepareUnitOrders(orders)

	if not orders then return true end
	if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_TRAIN_ABILITY then return true end

	local myHero = Heroes.GetLocal()
    		if not myHero then return true end
    
	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerInstanceHelper) then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
			AIO_Umbrella.invokerProcessInstances(myHero, orders.order)
			return true
		end
	end
	
	if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
		local quas = NPC.GetAbility(myHero, "invoker_quas")
		local wex = NPC.GetAbility(myHero, "invoker_wex")
		local exort = NPC.GetAbility(myHero, "invoker_exort")
		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
			if orders.ability == quas or orders.ability == wex or orders.ability == exort then
				AIO_Umbrella.InvokerCaptureManualInstances = os.clock()
				return true
			end
		end
	end

	
	if Menu.IsEnabled(AIO_Umbrella.optionLinkensManual) then
		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then
			if orders.target ~= nil and Entity.IsHero(orders.target) and not Entity.IsSameTeam(myHero, orders.target) then
				if NPC.IsLinkensProtected(orders.target) then
					if AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
						Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), orders.target)
						return true
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemVeilManual) then
		local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
		if veil and Ability.IsReady(veil) then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then
				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then
					if not Ability.IsPassive(orders.ability) and Ability.GetCastPoint(orders.ability) > 0.05 then
						if orders.target ~= nil and not Entity.IsDormant(orders.target) and Entity.IsAlive(orders.target) and not NPC.IsIllusion(orders.target) then
							Ability.CastPosition(veil, Entity.GetAbsOrigin(orders.target))
							if not NPC.HasItem(myHero, "item_soul_ring", true) then
								return true
							end
						end
					end
				end
			elseif orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION then
				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then
					if not Ability.IsPassive(orders.ability) and Ability.GetCastPoint(orders.ability) > 0.05 then
						local mousePos = Input.GetWorldCursorPos()
						local checkTarget = nil
							for _, v in ipairs(Heroes.InRadius(mousePos, 600, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)) do
								if v and Entity.IsHero(v) and not Entity.IsDormant(v) and Entity.IsAlive(v) and not NPC.IsIllusion(v) then
									checkTarget = v
									break
								end
							end

						if checkTarget ~= nil then
							Ability.CastPosition(veil, Entity.GetAbsOrigin(checkTarget))
							if not NPC.HasItem(myHero, "item_soul_ring", true) then
								return true
							end
						end
					end
				end
			end						
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemSoulringManual) then
		local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
		if soulring and Ability.IsReady(soulring) then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION or orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET or
			orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then
					if not Ability.IsPassive(orders.ability) and Ability.GetManaCost(orders.ability) > 50 and Ability.GetCastPoint(orders.ability) > 0.05 then
						Ability.CastNoTarget(soulring)
						return true
					end
				end
			end
		end
	end
				
	if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusAutoEmpower) then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_magnataur" then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
				if orders.target and Entity.IsNPC(orders.target) and not Entity.IsSameTeam(myHero, orders.target) then
					AIO_Umbrella.magnusAutoEmpower(myHero)
					return true
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmlet) then
		local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if armlet and not NPC.HasModifier(myHero, "modifier_item_armlet_unholy_strength") then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TOGGLE then
				if orders.ability == armlet and not AIO_Umbrella.isArmletManuallyToggled then
					AIO_Umbrella.isArmletManuallyToggled = true
					AIO_Umbrella.isArmletManuallyToggledTime = GameRules.GetGameTime()
					return true
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmlet) and Menu.IsEnabled(AIO_Umbrella.optionItemArmletRightClick) then
		local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if armlet then
			if not AIO_Umbrella.armletRightClickToggle then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
					if not Entity.IsSameTeam(myHero, orders.target) then
						if Menu.GetValue(AIO_Umbrella.optionItemArmletRightClickStyle) > 0 then
							if os.clock() - AIO_Umbrella.armletRightClickDoubleClick > 0.3 then
								AIO_Umbrella.armletRightClickDoubleClick = os.clock()
								return true
							else
								if os.clock() - AIO_Umbrella.armletRightClickDoubleClick > 0.05 then
									AIO_Umbrella.armletRightClickToggle = true
									AIO_Umbrella.armletRightClickToggleTimer = os.clock()
									return true
								end
							end
						else
							AIO_Umbrella.armletRightClickToggle = true
							AIO_Umbrella.armletRightClickToggleTimer = os.clock()
							return true
						end
					end
				end
			else
				if os.clock() - AIO_Umbrella.armletRightClickToggleTimer > 0.6 then
					if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
						AIO_Umbrella.armletRightClickToggle = false
						return true
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmlet) and Menu.IsEnabled(AIO_Umbrella.optionItemArmletIllusion) then
		local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if armlet and not Ability.GetToggleState(armlet) then
			local manta = NPC.GetItem(myHero, "item_manta", true)
			local ckUlt = NPC.GetAbility(myHero, "chaos_knight_phantasm")
			local terrorImg = NPC.GetAbility(myHero, "terrorblade_conjure_image")
			if manta or ckUlt or terrorImg then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability == manta or orders.ability == terrorImg then
						Ability.Toggle(armlet, false)
						AIO_Umbrella.armletDelayer = os.clock() + 0.25
						return true
					elseif orders.ability == ckUlt then
						Ability.Toggle(armlet, false)
						AIO_Umbrella.armletDelayer = os.clock() + 0.75
						return true
					end
				end
			end
			local lsUlt = NPC.GetAbility(myHero, "life_stealer_infest")
			if lsUlt then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then
					if orders.ability == lsUlt then
						if orders.target and Entity.IsHero(orders.target) and Entity.IsSameTeam(myHero, orders.target) then
							Ability.Toggle(armlet, false)
							AIO_Umbrella.armletDelayer = os.clock() + (math.max(((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(orders.target)):Length2D() - 150), 0) / NPC.GetMoveSpeed(myHero)) + 0.25
							return true
						end
					end
				end
			end
		end
		if armlet and Ability.GetToggleState(armlet) then
			local lsConsume = NPC.GetAbility(myHero, "life_stealer_consume")
			if lsConsume and not Ability.IsHidden(lsConsume) then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability == lsConsume then
						AIO_Umbrella.armletDelayer = os.clock() + 1.5
						return true
					end
				end
			end
		end
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_kunkka" and AIO_Umbrella.kunkkaGhostshipTimer > os.clock() and AIO_Umbrella.kunkkaXMarkCastTime > os.clock() then
		local Q = NPC.GetAbilityByIndex(myHero, 0)
		local Xreturn = NPC.GetAbility(myHero, "kunkka_return")
		local Ship = NPC.GetAbility(myHero, "kunkka_ghostship")
		if AIO_Umbrella.kunkkaXMarkCastTime - os.clock() < 1 and AIO_Umbrella.kunkkaXMarkCastTime - os.clock() > 0 and Ability.IsReady(Ship) then
			return false
		elseif AIO_Umbrella.kunkkaGhostshipTimer - os.clock() < 2.25 and AIO_Umbrella.kunkkaGhostshipTimer - os.clock() > 1.75 and Ability.IsReady(Q) then
			return false
		elseif AIO_Umbrella.kunkkaGhostshipTimer - os.clock() < 0.80 and AIO_Umbrella.kunkkaGhostshipTimer - os.clock() > 0.30 and not Ability.IsHidden(Xreturn) then
			return false
		elseif Q and Ability.IsInAbilityPhase(Q) then
			return false
		elseif Xreturn and Ability.IsInAbilityPhase(Xreturn) then
			return false
		elseif Ship and Ability.IsInAbilityPhase(Ship) then
			return false
		end
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_pudge" then
		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION or orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
			if AIO_Umbrella.PudgeHookHit then
				AIO_Umbrella.PudgeHookHit = false
			end
		end
	end

	if AIO_Umbrella.myUnitName == "npc_dota_hero_tinker" then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerPushReset) then
			if AIO_Umbrella.TinkerPusher then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
					AIO_Umbrella.TinkerPusher = false
					if AIO_Umbrella.TinkerPorted or AIO_Umbrella.TinkerMarched > 0 then
						if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
							AIO_Umbrella.TinkerPorted = false
							AIO_Umbrella.TinkerJungle = false
							AIO_Umbrella.TinkerMarched = 0
							AIO_Umbrella.TinkerJungleFarmPos = {}
							return true
						end
					else
						return true
					end
				end
			else
				if AIO_Umbrella.TinkerPorted or AIO_Umbrella.TinkerMarched > 0 then
					if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
						AIO_Umbrella.TinkerPorted = false
						AIO_Umbrella.TinkerJungle = false
						AIO_Umbrella.TinkerMarched = 0
						AIO_Umbrella.TinkerJungleFarmPos = {}
						return true
					end
				end
			end
		end
		
		if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerMiscFailUlt) then
			local ult = NPC.GetAbility(myHero, "tinker_rearm")
			if ult then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability and orders.ability == ult then
						if Ability.IsChannelling(ult) then
							return false
						end
						if Ability.SecondsSinceLastUse(ult) > -1 and Ability.SecondsSinceLastUse(ult) < 0.5 then
							return false
						end
					end
				end
			end
		end

		if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerMiscFailRockets) then
			local rockets = NPC.GetAbilityByIndex(myHero, 1)
			if rockets then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability and orders.ability == rockets then
						if #Entity.GetHeroesInRadius(myHero, 2499, Enum.TeamType.TEAM_ENEMY) < 1 then
							return false
						end
					end
				end
			end
		end

		if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerMiscBlink) then
			local ult = NPC.GetAbility(myHero, "tinker_rearm")
			local blink = NPC.GetItem(myHero, "item_blink", true)
			if ult and blink then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability and orders.ability == ult and Ability.IsCastable(ult, NPC.GetMana(myHero)) then
						local check = false
						for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 750, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
								if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 30) then
									if NPC.FindFacingNPC(v) == myHero then
										check = true
										break
									end
								end
								for ability, info in pairs(AIO_Umbrella.RawDamageAbilityEstimation) do
									if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
										local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
										local abilityRadius = info[3]
										if AIO_Umbrella.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
											check = true
											break
										end
									end
								end	
							end
						end
						if check then
							AIO_Umbrella.TinkerPanicRearmBlink = os.clock()
							return true
						end
					end
				end
			end
		end					
	end
	
	return true

end

-- last Hitter
function AIO_Umbrella.lastHitter(myHero)
	
	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionLastHitEnable) then return end

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)

	local attackPoint = 0
	for i, v in pairs(AIO_Umbrella.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			attackPoint = v[1] / (1 + (increasedAS/100))
			break
		end
	end

	AIO_Umbrella.lastHitterPredictDieTime(myHero)
	AIO_Umbrella.lastHitterDieTimeCleaner(myHero, attackPoint)
	AIO_Umbrella.lastHitterGetOrbSkill(myHero)
	AIO_Umbrella.lastHitterGetOrbSkillHarass(myHero)
	AIO_Umbrella.lastHitterExecuteLastHit(myHero, attackPoint)
			
end

function AIO_Umbrella.lastHitterExecuteLastHit(myHero, attackPoint)

	if not myHero then return end

	local curTime = GameRules.GetGameTime()

	if Menu.IsEnabled(AIO_Umbrella.optionLastHitDrawRange) and NPC.IsRanged(myHero) then
		if Menu.IsKeyDown(AIO_Umbrella.optionLastHitKey) then
			Engine.ExecuteCommand("dota_range_display " .. NPC.GetAttackRange(myHero))
		else
			Engine.ExecuteCommand("dota_range_display 0")
		end
	end

	local lastHitTarget = nil
	local lastHitTime = 0
		for i, v in pairs(AIO_Umbrella.lastHitCreepHPPredictionTime) do
			if i and Entity.IsNPC(i) and Entity.IsAlive(i) then
				if (not Entity.IsSameTeam(myHero, i) and (not NPC.IsTower(i) or (NPC.IsTower(i) and Entity.GetHealth(i) < 159))) or (Entity.IsSameTeam(myHero, i) and ((not NPC.IsTower(i) and Entity.GetHealth(i)/Entity.GetMaxHealth(i) < 0.5) or (NPC.IsTower(i) and Entity.GetHealth(i) < 159))) then
					if Menu.GetValue(AIO_Umbrella.optionLastHitStyle) == 0 then
						if AIO_Umbrella.utilityGetTableLength(AIO_Umbrella.lastHitCreepHPPredictionTime) <= 1 then
							lastHitTarget = i
							lastHitTime = v
							break
						else
							local tempTable = {}

							for k, l in pairs(AIO_Umbrella.lastHitCreepHPPredictionTime) do
								table.insert(tempTable, { l, k })
							end

							if #tempTable > 1 then
								if Entity.IsNPC(tempTable[1][2]) and Entity.IsNPC(tempTable[2][2]) then
									if math.abs(tempTable[2][1] - tempTable[1][1]) < NPC.GetAttackTime(myHero) + 0.1 then
										if not Entity.IsSameTeam(myHero, tempTable[1][2]) then
											lastHitTarget = tempTable[1][2]
											lastHitTime = tempTable[1][1]
										else
											if not Entity.IsSameTeam(myHero, tempTable[2][2]) then
												lastHitTarget = tempTable[2][2]
												lastHitTime = tempTable[2][1]
											else
												lastHitTarget = tempTable[1][2]
												lastHitTime = tempTable[1][1]
											end
										end
									else
										lastHitTarget = tempTable[1][2]
										lastHitTime = tempTable[1][1]
									end
								end
							end
						end
					elseif Menu.GetValue(AIO_Umbrella.optionLastHitStyle) == 1 then
						if not Entity.IsSameTeam(myHero, i) then
							lastHitTarget = i
							lastHitTime = v
							break
						end
					elseif Menu.GetValue(AIO_Umbrella.optionLastHitStyle) == 2 then
						if Entity.IsSameTeam(myHero, i) then
							lastHitTarget = i
							lastHitTime = v
							break
						end
					end
				end
			end
		end


	if Menu.IsKeyDown(AIO_Umbrella.optionLastHitKey) then
		if AIO_Umbrella.myUnitName == "npc_dota_hero_invoker" then
			AIO_Umbrella.invokerProcessInstances(myHero, Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET)
		end

		if lastHitTarget == nil then 

			if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeEnemy) then
				local searchRange = NPC.GetAttackRange(myHero)
					if AIO_Umbrella.lastHitterOrbSkillEnemy ~= nil and Ability.GetName(AIO_Umbrella.lastHitterOrbSkillEnemy) == "skywrath_mage_arcane_bolt" then
						searchRange = Ability.GetCastRange(AIO_Umbrella.lastHitterOrbSkillEnemy)
					end
				if #Entity.GetHeroesInRadius(myHero, searchRange, Enum.TeamType.TEAM_ENEMY) < 1 then
					if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
						if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
							AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
							return
						else
							if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
								Player.HoldPosition(Players.GetLocal(), myHero, false)
								return
							end
						end
					else
						if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
							Player.HoldPosition(Players.GetLocal(), myHero, false)
							return
						end
					end
				else
					if not AIO_Umbrella.lastHitBackswingChecker(myHero) then
						for _, v in ipairs(Entity.GetHeroesInRadius(myHero, searchRange, Enum.TeamType.TEAM_ENEMY)) do
							if v then
								local target = AIO_Umbrella.targetChecker(v)
								if target then
									if not AIO_Umbrella.lastHitRoughCalcForHit(myHero) then
										if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeEnemySave) then
											if AIO_Umbrella.lastHitCheckCreepAggro(myHero) == false then
												if AIO_Umbrella.lastHitterOrbSkillEnemy ~= nil and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
													Ability.CastTarget(AIO_Umbrella.lastHitterOrbSkillEnemy, target)
													return
												else
													AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", v, nil)
													return
												end
											else
												if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
													if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
														AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
														return
													else
														if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
															Player.HoldPosition(Players.GetLocal(), myHero, false)
															return
														end
													end
												else
													if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
														Player.HoldPosition(Players.GetLocal(), myHero, false)
														return
													end
												end
											end	
										else
											if AIO_Umbrella.lastHitterOrbSkillEnemy ~= nil and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
												Ability.CastTarget(AIO_Umbrella.lastHitterOrbSkillEnemy, target)
												return
											else
												AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", v, nil)
												return
											end
										end
									else
										if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
											if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
												AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
												return
											else
												if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
													Player.HoldPosition(Players.GetLocal(), myHero, false)
													return
												end
											end
										else
											if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
												Player.HoldPosition(Players.GetLocal(), myHero, false)
												return
											end
										end
									end
								else
									if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
										if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
											AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
											return
										else
											if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
												Player.HoldPosition(Players.GetLocal(), myHero, false)
												return
											end
										end
									else
										if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
											Player.HoldPosition(Players.GetLocal(), myHero, false)
											return
										end
									end
								end
							else
								if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
									if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
										AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
										return
									else
										if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
											Player.HoldPosition(Players.GetLocal(), myHero, false)
											return
										end
									end
								else
									if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
										Player.HoldPosition(Players.GetLocal(), myHero, false)
										return
									end
								end
							end
						end
					else
						if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
							if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
								AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
								return
							else
								if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
									Player.HoldPosition(Players.GetLocal(), myHero, false)
									return
								end
							end
						else
							if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
								Player.HoldPosition(Players.GetLocal(), myHero, false)
								return
							end
						end
					end
				end
			else
				if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
					if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
						AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
						return
					else
						if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
							Player.HoldPosition(Players.GetLocal(), myHero, false)
							return
						end
					end
				else
					if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
						Player.HoldPosition(Players.GetLocal(), myHero, false)
						return
					end
				end
			end
		else
			local target = lastHitTarget
			local hitTime = AIO_Umbrella.utilityRoundNumber((lastHitTime + (Menu.GetValue(AIO_Umbrella.optionLastHitOffset) / 20) - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)), 3)
			if Entity.IsNPC(target) and Entity.IsAlive(target) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
				if curTime > hitTime - AIO_Umbrella.lastHitterTimingOffsetter(myHero, target) then
					if not AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) then
						if AIO_Umbrella.lastHitterOrbSkill ~= nil and not Entity.IsSameTeam(myHero, target) and not NPC.IsTower(target) then
							Ability.CastTarget(AIO_Umbrella.lastHitterOrbSkill, target)
							return
						else
							Player.AttackTarget(Players.GetLocal(), myHero, target, false)
							return
						end
					end	
				else
					if AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint) == true then
						if (GameRules.GetGameTime() - (os.clock() - AIO_Umbrella.AttackAnimationCreate)) + AIO_Umbrella.lastHitterTimingOffsetter(myHero, target) < hitTime then
							Player.HoldPosition(Players.GetLocal(), myHero, false)
							return
						end
					else
						if Menu.IsEnabled(AIO_Umbrella.optionLastHitAutoModeMove) then
							if hitTime - curTime - AIO_Umbrella.lastHitterTimingOffsetter(myHero, target) > 0.15 then
								if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionLastHitAutoModeMoveRange), 0) then
									AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
									return
								end
							end
						end
					end
				end	
			end
		end
	end
	
	return

end

function AIO_Umbrella.lastHitterGetOrbSkill(myHero)

	if not myHero then return end

	local orbSkill = nil
	if Menu.IsEnabled(AIO_Umbrella.optionLastHitOrb) then
		local orbSkillTable = {
			npc_dota_hero_clinkz = "clinkz_searing_arrows",
			npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
			npc_dota_hero_silencer = "silencer_glaives_of_wisdom"
				}

		if orbSkillTable[AIO_Umbrella.myUnitName] ~= nil then
			orbSkill = NPC.GetAbility(myHero, orbSkillTable[AIO_Umbrella.myUnitName])
		end

		if orbSkill ~= nil then
			if Ability.GetLevel(orbSkill) < 1 then
				orbSkill = nil
			elseif (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) * 100 < Menu.GetValue(AIO_Umbrella.optionLastHitOrbMana) then
				orbSkill = nil
			elseif AIO_Umbrella.heroCanCastSpells(myHero, target) == false then
				orbSkill = nil
			elseif not Ability.IsReady(orbSkill) then
				orbSkill = nil
			elseif not Ability.IsCastable(orbSkill, NPC.GetMana(myHero)) then
				orbSkill = nil
			end
		end
	end

	if orbSkill then
		AIO_Umbrella.lastHitterOrbSkill = orbSkill
	else
		AIO_Umbrella.lastHitterOrbSkill = nil
	end

	return	
end

function AIO_Umbrella.lastHitterGetOrbSkillHarass(myHero)

	if not myHero then return end

	local orbSkill = nil
	if Menu.IsEnabled(AIO_Umbrella.optionLastHitOrb) then
		local orbSkillTable = {
			npc_dota_hero_clinkz = "clinkz_searing_arrows",
			npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
			npc_dota_hero_enchantress = "enchantress_impetus",
			npc_dota_hero_huskar = "huskar_burning_spear",
			npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
			npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
			npc_dota_hero_viper = "viper_poison_attack",
			npc_dota_hero_skywrath_mage = "skywrath_mage_arcane_bolt"
				}

		if orbSkillTable[AIO_Umbrella.myUnitName] ~= nil then
			orbSkill = NPC.GetAbility(myHero, orbSkillTable[AIO_Umbrella.myUnitName])
		end

		if orbSkill ~= nil then
			if Ability.GetLevel(orbSkill) < 1 then
				orbSkill = nil
			elseif (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) * 100 < Menu.GetValue(AIO_Umbrella.optionLastHitOrbMana) then
				orbSkill = nil
			elseif AIO_Umbrella.heroCanCastSpells(myHero, target) == false then
				orbSkill = nil
			elseif not Ability.IsReady(orbSkill) then
				orbSkill = nil
			elseif not Ability.IsCastable(orbSkill, NPC.GetMana(myHero)) then
				orbSkill = nil
			end
		end
	end

	if orbSkill then
		AIO_Umbrella.lastHitterOrbSkillEnemy = orbSkill
	else
		AIO_Umbrella.lastHitterOrbSkillEnemy = nil
	end

	return	
end

function AIO_Umbrella.lastHitCheckCreepAggro(myHero)

	if not myHero then return false end

	if AIO_Umbrella.lastHitterOrbSkillEnemy ~= nil then return false end
	
	local creepsAround = Entity.GetUnitsInRadius(myHero, 500, Enum.TeamType.TEAM_ENEMY)
		if #creepsAround < 1 then return false end

	for _, v in ipairs(creepsAround) do
		if v and Entity.IsNPC(v) and Entity.IsAlive(v) then
			if NPC.IsLaneCreep(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
				if v ~= nil then
					return true
				end
			end
		end
	end

	return false

end

function AIO_Umbrella.lastHitRoughCalcForHit(myHero)

	if not myHero then return false end

	local attackTime = NPC.GetAttackTime(myHero)

	if next(AIO_Umbrella.lastHitCreepHPPrediction) == nil then return false end

	for i, v in pairs(AIO_Umbrella.lastHitCreepHPPrediction) do
		if i and Entity.IsNPC(i) and Entity.IsAlive(i) then
			local creepHP = Entity.GetHealth(i)
			local attackerCount = AIO_Umbrella.lastHitGetAttackerCount(myHero, i)
			if creepHP < math.ceil(2 * attackTime) * attackerCount * 18 then
				return true
			end
		end
	end

	return false

end

function AIO_Umbrella.lastHitGetAttackerCount(myHero, target)

	if not myHero then return 0 end
	if not target then return 0 end

	local count = 0
	for i, v in pairs(AIO_Umbrella.lastHitCreepHPPrediction) do
		if i and Entity.IsNPC(i) and Entity.IsAlive(i) then
			if i == target then
				local temp = {}
				for k, l in ipairs(v) do
					if not AIO_Umbrella.utilityIsInTable(temp, l[3]) and GameRules.GetGameTime() > l[1] then
						table.insert(temp, l[3])
					end
				end
				count = #temp or 0
			end
		end
	end
				
	return count

end

function AIO_Umbrella.lastHitBackswingChecker(myHero)

	if not myHero then return false end

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)
	local attackTime = NPC.GetAttackTime(myHero)
	local attackPoint
	local attackBackSwing
	for i, v in pairs(AIO_Umbrella.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			attackPoint = v[1] / (1 + (increasedAS/100))
			attackBackSwing = v[2] / (1 + (increasedAS/100))
			break
		end
	end

	local idleTime = attackTime - attackPoint - attackBackSwing

	if NPC.IsRanged(myHero) then
		if AIO_Umbrella.AttackProjectileCreate > 0 then
			if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackProjectileCreate + attackBackSwing + idleTime then
				return true
			else
				return false
			end
		end
	else
		if AIO_Umbrella.AttackParticleCreate > 0 then
			if NPC.HasItem(myHero, "item_echo_sabre", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) < (attackPoint / 1.49) + 0.15 then
					return false
				else
					if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackParticleCreate + attackBackSwing + idleTime then
						return true
					else
						return false
					end
				end
			else
				if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackParticleCreate + attackBackSwing + idleTime then
					return true
				else
					return false
				end
			end
		end
	end

	return false

end

function AIO_Umbrella.lastHitterTimingOffsetter(myHero, target)

	if not myHero then return 0 end
	if not target then return 0 end
	if target and not Entity.IsNPC(target) then return 0 end

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)

	local attackPoint = 0
	local projectileSpeed = 0
	for i, v in pairs(AIO_Umbrella.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			if NPC.IsRanged(myHero) then
				attackPoint = v[1] / (1 + (increasedAS/100))
				projectileSpeed = v[3]
				break
			else
				attackPoint = v[1] / (1 + (increasedAS/100))
				projectileSpeed = 0
				break
			end
		end
	end

	local faceTime = math.max(NPC.GetTimeToFace(myHero, target) - ((0.033 * math.pi / NPC.GetTurnRate(myHero) / 180) * 11.5), 0)

	local myAttackRange = NPC.GetAttackRange(myHero)
	local myMovementSpeed = NPC.GetMoveSpeed(myHero)
	local distanceToTarget = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(target)):Length2D()
	local projectileDistance = distanceToTarget - math.max(distanceToTarget - (myAttackRange + NPC.GetHullRadius(myHero) + NPC.GetHullRadius(target)), 0)
	local moveDistance = distanceToTarget - projectileDistance

	local projectileOffset = 0
		if projectileSpeed > 0 then
			projectileOffset = (projectileDistance - 24) / projectileSpeed
		end

	local moveTime = 0
		if moveDistance > 0 then
			moveTime = moveDistance / myMovementSpeed
		end

	local overallOffset = AIO_Umbrella.utilityRoundNumber(attackPoint + projectileOffset + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + faceTime + moveTime, 3)

	return overallOffset or 0

end

function AIO_Umbrella.myCreepDamageAdjuster(myHero, target)

	if not myHero then return 0 end

	local quelling = NPC.GetItem(myHero, "item_quelling_blade", true)

	local minCreepDamage = NPC.GetMinDamage(myHero)
	local bonusCreepDamage = 0
		if quelling then
			if NPC.IsRanged(myHero) then
				bonusCreepDamage = 7
			else
				bonusCreepDamage = 24
			end
		end

	local orbSkill = AIO_Umbrella.lastHitterOrbSkill
	if orbSkill ~= nil then
		if not Entity.IsSameTeam(myHero, target) and not NPC.IsTower(target) then
			local orbSkillName = Ability.GetName(orbSkill)
			if orbSkillName == "clinkz_searing_arrows" then
				minCreepDamage = minCreepDamage + (20 + 10 * Ability.GetLevel(orbSkill))
				if NPC.HasAbility(myHero, "special_bonus_unique_clinkz_1") then
					if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_clinkz_1")) > 0 then
						minCreepDamage = minCreepDamage + 30
					end
				end
			elseif orbSkillName == "obsidian_destroyer_arcane_orb" then
				local bonusDMG = (0.05 + (0.01 * Ability.GetLevel(orbSkill))) * NPC.GetMana(myHero)
				local bonusPureDMG = bonusDMG * (1 + (1 - NPC.GetDamageMultiplierVersus(myHero, target)) + (1 - NPC.GetArmorDamageMultiplier(target)))
				minCreepDamage = minCreepDamage + bonusPureDMG
			elseif orbSkillName == "silencer_glaives_of_wisdom" then
				local myInt = Hero.GetIntellectTotal(myHero)
				local bonusDMG = 0.15 * Ability.GetLevel(orbSkill) * myInt
					if NPC.HasAbility(myHero, "special_bonus_unique_silencer_3") then
						if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_silencer_3")) > 0 then
							bonusDMG = (0.2 + 0.15 * Ability.GetLevel(orbSkill)) * myInt
						end
					end
				local bonusPureDMG = bonusDMG * (1 + (1 - NPC.GetDamageMultiplierVersus(myHero, target)) + (1 - NPC.GetArmorDamageMultiplier(target)))
				minCreepDamage = minCreepDamage + bonusPureDMG
			end
		end
	end

	if NPC.HasModifier(myHero, "modifier_storm_spirit_overload") then
		local overload = NPC.GetAbility(myHero, "storm_spirit_overload")
		local bonus = 0
		if overload and Ability.GetLevel(overload) > 0 then
			bonus = Ability.GetDamage(overload)
		end
		local bonusTrue = (1 - NPC.GetMagicalArmorValue(target)) * bonus + bonus * (Hero.GetIntellectTotal(myHero) / 14 / 100)
		minCreepDamage = minCreepDamage + bonusTrue
	end

	local overallCreepDamage = minCreepDamage + bonusCreepDamage

	return math.floor(overallCreepDamage)

end

function AIO_Umbrella.lastHitInAttackAnimation(myHero, attackPoint)

	if not myHero then return false end
	if not attackPoint then return false end
		if attackPoint == 0 then return false end

	if os.clock() >= AIO_Umbrella.AttackAnimationCreate - 0.035 then
		if os.clock() <= (AIO_Umbrella.AttackAnimationCreate + attackPoint + 0.075) then
			return true
		end
	end

	return false

end

function AIO_Umbrella.lastHitterDrawing(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionLastHitDrawCreepEnable) then return end
	
	if next(AIO_Umbrella.lastHitCreepHPPredictionTime) == nil then return end

	if Menu.IsEnabled(AIO_Umbrella.optionLastHitDrawCreepTimer) then
		local imageHandle = AIO_Umbrella.lastHitterKillableImage
			if imageHandle == nil then
				imageHandle = Renderer.LoadImage("resource/flash3/images/heroes/selection/fav_heart.png")
				AIO_Umbrella.lastHitterKillableImage = imageHandle
			end
		for i, v in pairs(AIO_Umbrella.lastHitCreepHPPredictionTime) do
			local target = i
			local dieTime = v
			if target and Entity.IsNPC(target) then
				local pos = Entity.GetAbsOrigin(target)
				local posY = NPC.GetHealthBarOffset(target)
					pos:SetZ(pos:GetZ() + posY)	
				local x, y, visible = Renderer.WorldToScreen(pos)
				if Menu.GetValue(AIO_Umbrella.optionLastHitDrawStyle) < 1 then
					if visible then
						if dieTime - GameRules.GetGameTime() > AIO_Umbrella.lastHitterTimingOffsetter(myHero, target) then
							Renderer.SetDrawColor(255,215,0,200)
							Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
						else
							Renderer.SetDrawColor(50,205,50,200)
							Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
						end
					end
				else
					if not Entity.IsSameTeam(myHero, i) then
						if visible then
							if dieTime - GameRules.GetGameTime() > AIO_Umbrella.lastHitterTimingOffsetter(myHero, target) then
								Renderer.SetDrawColor(255,215,0,200)
								Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
							else
								Renderer.SetDrawColor(50,205,50,200)
								Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
							end
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.lastHitterPredictDieTime(myHero)

	if not myHero then return end

	if next(AIO_Umbrella.lastHitCreepHPPredictionTime) ~= nil then
		table.sort(AIO_Umbrella.lastHitCreepHPPredictionTime, function(a, b)
       			return a < b
    		end)
	end

	for target, attackTable in pairs(AIO_Umbrella.lastHitCreepHPPrediction) do
		if attackTable then
			if target and Entity.IsNPC(target) and Entity.IsAlive(target) then
				local creepHP = math.ceil(Entity.GetHealth(target) + NPC.GetHealthRegen(target))
				local myAttackDMG = math.floor(math.floor(NPC.GetDamageMultiplierVersus(myHero, target) * ((AIO_Umbrella.myCreepDamageAdjuster(myHero, target) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(target))) * 0.975)
					if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
						local avgDmgGap = math.floor((NPC.GetTrueMaximumDamage(myHero) - NPC.GetTrueDamage(myHero)) / 2)
						myAttackDMG = math.floor(math.floor(NPC.GetDamageMultiplierVersus(myHero, target) * ((AIO_Umbrella.myCreepDamageAdjuster(myHero, target) + NPC.GetBonusDamage(myHero) + avgDmgGap) * NPC.GetArmorDamageMultiplier(target))) * 0.975)
					end
				table.sort(attackTable, function(a, b)
       					return a[1] < b[1]
    				end)

				for i, info in ipairs(attackTable) do
					if info then
						local hitTime = info[1]
						local hitDamage = info[2]
						if hitTime > GameRules.GetGameTime() and math.abs(hitTime - GameRules.GetGameTime()) > 0.15 then
							creepHP = creepHP - hitDamage
							if AIO_Umbrella.lastHitCreepHPPredictionTime[target] == nil then
								local offSet = AIO_Umbrella.lastHitGetAttackerCount(myHero, target)
									if Menu.IsEnabled(AIO_Umbrella.optionLastHitPredict) then
										offSet = math.ceil(offSet / 2)
									end
								if creepHP > myAttackDMG and creepHP - myAttackDMG <= math.ceil(math.ceil(0.025 * myAttackDMG) + offSet) then
									if hitTime > GameRules.GetGameTime() and hitTime - GameRules.GetGameTime() < AIO_Umbrella.lastHitterTimingOffsetter(myHero, target) * 1.25 then
										AIO_Umbrella.lastHitCreepHPPredictionTime[target] = hitTime + 0.075
										break
										return
									end
								elseif creepHP <= myAttackDMG then
									if hitTime > GameRules.GetGameTime() and hitTime - GameRules.GetGameTime() < AIO_Umbrella.lastHitterTimingOffsetter(myHero, target) * 1.25 then
										AIO_Umbrella.lastHitCreepHPPredictionTime[target] = hitTime + 0.075
										break
										return
									end
								end
							else
								if creepHP <= myAttackDMG then
									if hitTime + 0.075 < AIO_Umbrella.lastHitCreepHPPredictionTime[target] then
										AIO_Umbrella.lastHitCreepHPPredictionTime[target] = hitTime + 0.075
										break
										return
									end
								end
							end	
						end
					end
				end
		
				


			end
		end
	end

	for i, v in ipairs(Entity.GetUnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_BOTH)) do
		if v and Entity.IsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" and (NPC.IsCreep(v) or NPC.IsTower(v)) then
			local creepHP = Entity.GetHealth(v) + NPC.GetHealthRegen(v)
			local myAttackDMG = NPC.GetDamageMultiplierVersus(myHero, v) * ((AIO_Umbrella.myCreepDamageAdjuster(myHero, v) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(v))
			if creepHP < myAttackDMG then
				AIO_Umbrella.lastHitCreepHPPredictionTime[v] = GameRules.GetGameTime()
			end
		end
	end
	
end

function AIO_Umbrella.lastHitterDieTimeCleaner(myHero, attackPoint)

	if next(AIO_Umbrella.lastHitCreepHPPredictionTime) == nil then return end

	if not myHero then
		AIO_Umbrella.lastHitCreepHPPredictionTime = {}
	end

	if not Entity.IsAlive(myHero) then
		AIO_Umbrella.lastHitCreepHPPredictionTime = {}
	end

	if #NPC.GetUnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_BOTH) <= 1 then
		AIO_Umbrella.lastHitCreepHPPredictionTime = {}
	end

	if next(AIO_Umbrella.lastHitCreepHPPredictionTime) ~= nil then
		for i, v in pairs(AIO_Umbrella.lastHitCreepHPPredictionTime) do
			local target = i
			local dieTime = v
			if not target then
				AIO_Umbrella.lastHitCreepHPPredictionTime[i] = nil
				break
				return
			end
			if target and Entity.IsNPC(target) and not Entity.IsAlive(target) then
				AIO_Umbrella.lastHitCreepHPPredictionTime[i] = nil
				break
				return
			end
			if GameRules.GetGameTime() > dieTime then
				AIO_Umbrella.lastHitCreepHPPredictionTime[i] = nil
				break
				return
			end
		end
	end	

end

function AIO_Umbrella.lastHitterGetTarget(myHero, creep)

	if not myHero then return end
	if not creep then return end

	if not Entity.IsNPC(creep) then return end
	if not NPC.IsLaneCreep(creep) then return end
	if NPC.IsRanged(creep) then return end
	if not Entity.IsAlive(creep) then return end
	
	local creepRotation = Entity.GetRotation(creep):GetForward():Normalized()
	
	local targets = Entity.GetUnitsInRadius(creep, 148, Enum.TeamType.TEAM_ENEMY)
		if next(targets) == nil then return end
		if #targets < 1 then return end

	if #targets == 1 then
		if Entity.IsNPC(targets[1]) and NPC.IsLaneCreep(targets[1]) then
			return targets[1]
		end
	else
		local adjustedHullSize = 20
		for i, v in ipairs(targets) do
			if v and Entity.IsNPC(v) and NPC.IsLaneCreep(v) and Entity.IsAlive(v) then
				local vpos = Entity.GetAbsOrigin(v)
				local vposZ = vpos:GetZ()
				local pos = Entity.GetAbsOrigin(creep)
				for i = 1, 9 do
					local searchPos = pos + creepRotation:Scaled(25*(9-i))
						searchPos:SetZ(vposZ)
					if NPC.IsPositionInRange(v, searchPos, adjustedHullSize, 0) then
						return v
					end
				end
			end
		end
	end

	return

end

function AIO_Umbrella.utilityRoundNumber(number, digits)

	if not number then return end

  	local mult = 10^(digits or 0)
  	return math.floor(number * mult + 0.5) / mult

end

function AIO_Umbrella.utilityGetTableLength(table)

	if not table then return 0 end
	if next(table) == nil then return 0 end

	local count = 0
	for i, v in pairs(table) do
		count = count + 1
	end

	return count

end

function AIO_Umbrella.utilityIsInTable(table, arg)

	if not table then return false end
	if not arg then return false end
	if next(table) == nil then return false end

	for i, v in pairs(table) do
		if i == arg then
			return true
		end
		if type(v) ~= 'table' and v == arg then
			return true
		end
	end

	return false

end

-- utility functions
function AIO_Umbrella.heroSupported(myHero)

	if not myHero then return end
	local supportedHeroList = AIO_Umbrella.heroList

	for _, heroName in pairs(supportedHeroList) do
		if heroName == NPC.GetUnitName(myHero) then
			return true
		end
	end
	return false
end

function AIO_Umbrella.setOrderItem(printed)

	AIO_Umbrella.ItemCastOrder = {
        	{Menu.GetValue(AIO_Umbrella.optionItemVeil), "item_veil_of_discord", "position"},
        	{Menu.GetValue(AIO_Umbrella.optionItemHex), "item_sheepstick", "target"},
        	{Menu.GetValue(AIO_Umbrella.optionItemBlood), "item_bloodthorn", "target"},
        	{Menu.GetValue(AIO_Umbrella.optionItemeBlade), "item_ethereal_blade", "target"},
        	{Menu.GetValue(AIO_Umbrella.optionItemOrchid),"item_orchid", "target"},
        	{Menu.GetValue(AIO_Umbrella.optionItemAtos),"item_rod_of_atos", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemAbyssal),"item_abyssal_blade", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemHalberd),"item_heavens_halberd", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemShivas),"item_shivas_guard", "no target"},
		{Menu.GetValue(AIO_Umbrella.optionItemDagon),"item_dagon", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemDagon),"item_dagon_2", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemDagon),"item_dagon_3", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemDagon),"item_dagon_4", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemDagon),"item_dagon_5", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemUrn),"item_urn_of_shadows", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemMedallion),"item_medallion_of_courage", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemCrest),"item_solar_crest", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemDiffusal),"item_diffusal_blade", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemSpirit),"item_spirit_vessel", "target"},
		{Menu.GetValue(AIO_Umbrella.optionItemNull),"item_nullifier", "target"},
    				}

    	table.sort(AIO_Umbrella.ItemCastOrder, function(a, b)
        	return a[1] > b[1]
    	end)
	Log.Write(".....Item Cast Order....")
	local printed = false
		if not printed then
			for k,v in ipairs(AIO_Umbrella.ItemCastOrder) do
			Log.Write(v[1]..':'..v[2])
			printed = true
			end
		end
end			

function AIO_Umbrella.setOrderLinkens(printed)
	
	AIO_Umbrella.LinkensBreakerItemOrder = {
        	{Menu.GetValue(AIO_Umbrella.optionLinkensForce), "item_force_staff"},
        	{Menu.GetValue(AIO_Umbrella.optionLinkensEul), "item_cyclone"},
        	{Menu.GetValue(AIO_Umbrella.optionLinkensHalberd), "item_heavens_halberd"},
        	{Menu.GetValue(AIO_Umbrella.optionLinkensHex), "item_sheepstick"},
        	{Menu.GetValue(AIO_Umbrella.optionLinkensBlood),"item_bloodthorn"},
        	{Menu.GetValue(AIO_Umbrella.optionLinkensOrchid),"item_orchid"},
		{Menu.GetValue(AIO_Umbrella.optionLinkensDiffusal),"item_diffusal_blade", "target"},
		{Menu.GetValue(AIO_Umbrella.optionLinkensPike),"item_hurricane_pike"}
    				}

    	table.sort(AIO_Umbrella.LinkensBreakerItemOrder, function(a, b)
        	return a[1] > b[1]
    	end)
	Log.Write(".....Linkens Breaker Priorization Order....")
	local printed = false
		if not printed then
			for k,v in ipairs(AIO_Umbrella.LinkensBreakerItemOrder) do
			Log.Write(v[1]..':'..v[2])
			printed = true
			end
		end			
	
end

function AIO_Umbrella.OnMenuOptionChange(option, old, new)

    	if option == AIO_Umbrella.optionItemVeil or
		option == AIO_Umbrella.optionItemHex or
		option == AIO_Umbrella.optionItemBlood or
		option == AIO_Umbrella.optionItemeBlade or 
		option == AIO_Umbrella.optionItemOrchid or 
		option == AIO_Umbrella.optionItemAtos or 
		option == AIO_Umbrella.optionItemAbyssal or 
		option == AIO_Umbrella.optionItemHalberd or 
		option == AIO_Umbrella.optionItemShivas or 
		option == AIO_Umbrella.optionItemDagon or 
		option == AIO_Umbrella.optionItemUrn or
		option == AIO_Umbrella.optionItemManta or
		option == AIO_Umbrella.optionItemMjollnir or
		option == AIO_Umbrella.optionItemMedallion or
		option == AIO_Umbrella.optionItemCrest or
		option == AIO_Umbrella.optionItemDiffusal or
		option == AIO_Umbrella.optionItemSpirit or
		option == AIO_Umbrella.optionItemNull then
			AIO_Umbrella.setOrderItem(false)
	end
	
	if option == AIO_Umbrella.optionLinkensForce or
		option == AIO_Umbrella.optionLinkensEul or
		option == AIO_Umbrella.optionLinkensHalberd or
		option == AIO_Umbrella.optionLinkensHex or
		option == AIO_Umbrella.optionLinkensBlood or
		option == AIO_Umbrella.optionLinkensOrchid or
		option == AIO_Umbrella.optionLinkensDiffusal or
		option == AIO_Umbrella.optionLinkensPike then
        		AIO_Umbrella.setOrderLinkens(false)
    	end

	if option == AIO_Umbrella.invokerDisplaySizeOption then
        	AIO_Umbrella.invokerDisplayInit()
    	end

	if option == AIO_Umbrella.invokerPanelSizeOption then
		AIO_Umbrella.invokerPanelInit()
    	end

	if option == AIO_Umbrella.dodgeItOptionTable[1] or 
		option == AIO_Umbrella.dodgeItOptionTable[2] or
		option == AIO_Umbrella.dodgeItOptionTable[3] or
		option == AIO_Umbrella.dodgeItOptionTable[4] or
		option == AIO_Umbrella.dodgeItOptionTable[5] or
		option == AIO_Umbrella.dodgeItOptionTable[6] or
		option == AIO_Umbrella.dodgeItOptionTable[7] then
		AIO_Umbrella.dodgeItReadyTable = {}
	end

end

function AIO_Umbrella.targetChecker(genericEnemyEntity)

	local myHero = Heroes.GetLocal()
		if not myHero then return end

	if genericEnemyEntity and not NPC.IsDormant(genericEnemyEntity) and not NPC.IsIllusion(genericEnemyEntity) and Entity.GetHealth(genericEnemyEntity) > 0 then

		if Menu.IsEnabled(AIO_Umbrella.optionTargetCheckAM) then
			if NPC.GetUnitName(genericEnemyEntity) == "npc_dota_hero_antimage" and NPC.HasItem(genericEnemyEntity, "item_ultimate_scepter", true) and NPC.HasModifier(genericEnemyEntity, "modifier_antimage_spell_shield") and Ability.IsReady(NPC.GetAbility(genericEnemyEntity, "antimage_spell_shield")) then
				return
			end
		end
		if Menu.IsEnabled(AIO_Umbrella.optionTargetCheckLotus) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_item_lotus_orb_active") then
				return
			end
		end
		if Menu.IsEnabled(AIO_Umbrella.optionTargetCheckBlademail) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_item_blade_mail_reflect") and Entity.GetHealth(Heroes.GetLocal()) <= 0.25 * Entity.GetMaxHealth(Heroes.GetLocal()) then
				return
			end
		end
		if Menu.IsEnabled(AIO_Umbrella.optionTargetCheckNyx) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_nyx_assassin_spiked_carapace") then
				return
			end
		end
		if Menu.IsEnabled(AIO_Umbrella.optionTargetCheckUrsa) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_ursa_enrage") then
				return
			end
		end
		if Menu.IsEnabled(AIO_Umbrella.optionTargetCheckAbbadon) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_abaddon_borrowed_time") then
				return
			end
		end
		if Menu.IsEnabled(AIO_Umbrella.optionTargetCheckDazzle) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_dazzle_shallow_grave") and NPC.GetUnitName(myHero) ~= "npc_dota_hero_axe" then
				return
			end
		end
		if NPC.HasModifier(genericEnemyEntity, "modifier_skeleton_king_reincarnation_scepter_active") then
			return
		end
		if NPC.HasModifier(genericEnemyEntity, "modifier_winter_wyvern_winters_curse") then
			return
		end

	return genericEnemyEntity
	end	
end

function AIO_Umbrella.makeDelay(sec)

	AIO_Umbrella.delay = sec + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
	AIO_Umbrella.lastTick = os.clock()

end

function AIO_Umbrella.noItemCastFor(sec)

	AIO_Umbrella.itemDelay = sec
	AIO_Umbrella.lastItemTick = os.clock()

end

function AIO_Umbrella.SleepReady(sleep)

	if (os.clock() - AIO_Umbrella.lastTick) >= sleep then
		return true
	end
	return false

end

function AIO_Umbrella.ItemSleepReady(sleep)

	if (os.clock() - AIO_Umbrella.lastItemCast) >= sleep then
		return true
	end
	return false

end

function AIO_Umbrella.GetAvgLatency()

	local AVGlatency = NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2
	return AVGlatency

end

function AIO_Umbrella.CastAnimationDelay(ability)

	if not ability then return end

	local abilityAnimation = Ability.GetCastPoint(ability) + AIO_Umbrella.GetAvgLatency()

	return abilityAnimation

end
	
function AIO_Umbrella.castLinearPrediction(myHero, enemy, adjustmentVariable)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy):GetVectors()
		enemyRotation:SetZ(0)
    	local enemyOrigin = NPC.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)


	local cosGamma = (NPC.GetAbsOrigin(myHero) - enemyOrigin):Dot2D(enemyRotation:Scaled(100)) / ((NPC.GetAbsOrigin(myHero) - enemyOrigin):Length2D() * enemyRotation:Scaled(100):Length2D())

		if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin
			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(AIO_Umbrella.GetMoveSpeed(enemy) * adjustmentVariable * (1 - cosGamma)))
			end
		end
end

function AIO_Umbrella.castPrediction(myHero, enemy, adjustmentVariable)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy):GetVectors()
		enemyRotation:SetZ(0)
    	local enemyOrigin = NPC.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)

	if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin
			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(AIO_Umbrella.GetMoveSpeed(enemy) * adjustmentVariable))
			end
	end
end

function AIO_Umbrella.isEnemyTurning(enemy)

	if enemy == nil then return true end
	if not NPC.IsRunning(enemy) then return true end

	local rotationSpeed = Entity.GetAngVelocity(enemy):Length2D()
	if NPC.IsRunning(enemy) then
		table.insert(AIO_Umbrella.rotationTable, rotationSpeed)
			if #AIO_Umbrella.rotationTable > (Menu.GetValue(AIO_Umbrella.optionKillStealInvokerTurn) + 1) then
				table.remove(AIO_Umbrella.rotationTable, 1)
			end
	end
	
	if #AIO_Umbrella.rotationTable < Menu.GetValue(AIO_Umbrella.optionKillStealInvokerTurn) then 
		return true
	else
		local rotationSpeedCounter = 0
		i = 1
		repeat
			rotationSpeedCounter = rotationSpeedCounter + AIO_Umbrella.rotationTable[#AIO_Umbrella.rotationTable + 1 - i]
			i = i + 1
		until i > Menu.GetValue(AIO_Umbrella.optionKillStealInvokerTurn)

		if rotationSpeedCounter / Menu.GetValue(AIO_Umbrella.optionKillStealInvokerTurn) <= 10 then
			return false
		else
			return true
		end
	end
 
end

function AIO_Umbrella.GetMoveSpeed(enemy)

	if not enemy then return end

	local base_speed = NPC.GetBaseSpeed(enemy)
	local bonus_speed = NPC.GetMoveSpeed(enemy) - NPC.GetBaseSpeed(enemy)
	local modifierHex
    	local modSheep = NPC.GetModifier(enemy, "modifier_sheepstick_debuff")
    	local modLionVoodoo = NPC.GetModifier(enemy, "modifier_lion_voodoo")
    	local modShamanVoodoo = NPC.GetModifier(enemy, "modifier_shadow_shaman_voodoo")

	if modSheep then
		modifierHex = modSheep
	end
	if modLionVoodoo then
		modifierHex = modLionVoodoo
	end
	if modShamanVoodoo then
		modifierHex = modShamanVoodoo
	end

	if modifierHex then
		if math.max(Modifier.GetDieTime(modifierHex) - GameRules.GetGameTime(), 0) > 0 then
			return 140 + bonus_speed
		end
	end

    	if NPC.HasModifier(enemy, "modifier_invoker_ice_wall_slow_debuff") then 
		return 100 
	end

	if NPC.HasModifier(enemy, "modifier_invoker_cold_snap_freeze") or NPC.HasModifier(enemy, "modifier_invoker_cold_snap") then
		return (base_speed + bonus_speed) * 0.5
	end

	if NPC.HasModifier(enemy, "modifier_spirit_breaker_charge_of_darkness") then
		local chargeAbility = NPC.GetAbility(enemy, "spirit_breaker_charge_of_darkness")
		if chargeAbility then
			local specialAbility = NPC.GetAbility(enemy, "special_bonus_unique_spirit_breaker_2")
			if specialAbility then
				 if Ability.GetLevel(specialAbility) < 1 then
					return Ability.GetLevel(chargeAbility) * 50 + 550
				else
					return Ability.GetLevel(chargeAbility) * 50 + 1050
				end
			end
		end
	end
			
    	return base_speed + bonus_speed
end

function AIO_Umbrella.getBestPosition(unitsAround, radius)

	if not unitsAround or #unitsAround < 1 then
		return 
	end

	local countEnemies = #unitsAround

	if countEnemies == 1 then 
		return Entity.GetAbsOrigin(unitsAround[1]) 
	end

	return AIO_Umbrella.getMidPoint(unitsAround)

--	local maxCount = 1
--	local bestPosition = Entity.GetAbsOrigin(unitsAround[1])
--	for i = 1, (countEnemies - 1) do
--		for j = i + 1, countEnemies do
--			if unitsAround[i] and unitsAround[j] then
--				local pos1 = Entity.GetAbsOrigin(unitsAround[i])
--				local pos2 = Entity.GetAbsOrigin(unitsAround[j])
--				local mid = pos1:__add(pos2):Scaled(0.5)
--
--				local heroesCount = 0
--				for k = 1, countEnemies do
--				--	if NPC.IsPositionInRange(unitsAround[k], mid, radius, 0) then
--					if (Entity.GetAbsOrigin(unitsAround[k]) - mid):Length2D() <= radius then
--						heroesCount = heroesCount + 1
--					end
--				end
--
--				if heroesCount > maxCount then
--					maxCount = heroesCount
--					bestPosition = mid
--				end
--			end
--		end
--	end
--	return bestPosition

end

function AIO_Umbrella.getMidPoint(entityList)

	if not entityList then return end
	if #entityList < 1 then return end

	local pts = {}
		for i, v in ipairs(entityList) do
			if v and not Entity.IsDormant(v) then
				local pos = Entity.GetAbsOrigin(v)
				local posX = pos:GetX()
				local posY = pos:GetY()
				table.insert(pts, { x=posX, y=posY })
			end
		end
	
	local x, y, c = 0, 0, #pts

		if (pts.numChildren and pts.numChildren > 0) then c = pts.numChildren end

	for i = 1, c do

		x = x + pts[i].x
		y = y + pts[i].y

	end

	return Vector(x/c, y/c, 0)

end

function AIO_Umbrella.GetMyFaction(myHero)

	if not myHero then return end
	
	local radiantFountain = Vector(-7600, -7300, 640)
	local direFountain = Vector(7800, 7250, 640)
	
	local myFountain
	if myFountain == nil then
		for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
    			if Entity.IsSameTeam(myHero, npc) and NPC.IsStructure(npc) then
    				if NPC.GetUnitName(npc) ~= nil then
        				if NPC.GetUnitName(npc) == "dota_fountain" then
						myFountain = npc
					end
				end
			end
		end
	end

	local myFaction
	if myFaction == nil and myFountain ~= nil then
		if NPC.IsPositionInRange(myFountain, radiantFountain, 1000, 0) then
			myFaction = "radiant"
		else myFaction = "dire"
		end
	end

	return myFaction

end

function AIO_Umbrella.GetMyFountainPos(myHero)

	if not myHero then return end

	local myFaction = AIO_Umbrella.GetMyFaction(myHero)

	local myFountainPos
	if myFaction == "radiant" then
		myFountainPos = Vector(-7600, -7300, 640)
	else myFountainPos = Vector(7800, 7250, 640)
	end

	return myFountainPos

end

function AIO_Umbrella.GetEnemyFountainPos(myHero)

	if not myHero then return end

	local myFaction = AIO_Umbrella.GetMyFaction(myHero)

	local enemyFountainPos
	if myFaction == "radiant" then
		enemyFountainPos = Vector(7800, 7250, 640)
	else enemyFountainPos = Vector(-7600, -7300, 640)
	end

	return enemyFountainPos

end

function AIO_Umbrella.IsCreepAncient(npc)

	if not npc then return false end

	ancientNameList = { 
		"npc_dota_neutral_black_drake",
    		"npc_dota_neutral_black_dragon",
    		"npc_dota_neutral_blue_dragonspawn_sorcerer",
    		"npc_dota_neutral_blue_dragonspawn_overseer",
    		"npc_dota_neutral_granite_golem",
    		"npc_dota_neutral_elder_jungle_stalker",
    		"npc_dota_neutral_prowler_acolyte",
    		"npc_dota_neutral_prowler_shaman",
    		"npc_dota_neutral_rock_golem",
    		"npc_dota_neutral_small_thunder_lizard",
    		"npc_dota_neutral_jungle_stalker",
    		"npc_dota_neutral_big_thunder_lizard",
    		"npc_dota_roshan" }

	for _, creepName in ipairs(ancientNameList) do
		if creepName and NPC.GetUnitName(npc) ~= nil then
			if NPC.GetUnitName(npc) == creepName then
				return true
			end
		end
	end

	return false

end

function AIO_Umbrella.GetControllableEntities(myHero)

	if not myHero then return end

	for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
		if Entity.IsNPC(npc) and Entity.IsAlive(npc) and Entity.IsSameTeam(myHero, npc) then
			if npc ~= myHero then
				if Entity.GetOwner(npc) == Entity.GetOwner(myHero) or Entity.OwnedBy(myHero, npc) or Entity.OwnedBy(npc, myHero) then
					if npc ~= nil then
						if AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] == nil then
							AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] = npc
						end
					end
				else
					if AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] ~= nil then
						AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] = nil
					end
				end	
			else
				if AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] ~= nil then
					AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] = nil
				end
			end		
		else
			if AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] ~= nil then
				AIO_Umbrella.ControllableEntityTable[Entity.GetIndex(npc)] = nil
			end
		end	
	end

	return

end

function AIO_Umbrella.GetNecronomiconEntityTable(myHero, caster)

	if not myHero then return end
	if not caster then return end

	local necronomiconTable = {}
	for i, npc in ipairs(NPC.GetUnitsInRadius(myHero, 99999, Enum.TeamType.TEAM_FRIEND)) do
    		if Entity.IsSameTeam(myHero, npc) and Entity.GetOwner(npc) == caster then
    			if NPC.GetUnitName(npc) ~= nil then
				if NPC.GetUnitName(npc) == string.match(NPC.GetUnitName(npc) , 'npc_dota_necronomicon_archer_.') or NPC.GetUnitName(npc) == string.match(NPC.GetUnitName(npc) , 'npc_dota_necronomicon_warrior_.') then
					if npc ~= nil then
						table.insert(necronomiconTable, npc)
					end
				end
			end
		end
	end
	
	return necronomiconTable

end

function AIO_Umbrella.GetIllusionEntityTable(myHero, caster)

	if not myHero then return end
	if not caster then return end

	local controllableTable = {}
	if next(controllableTable) == nil then
		for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
			if Entity.IsSameTeam(myHero, npc) then
				if npc ~= myHero then
					if Entity.GetOwner(npc) == Entity.GetOwner(caster) then
						if NPC.HasModifier(npc, "modifier_illusion") then
							if npc ~= nil then
								table.insert(controllableTable, npc)
							else controllableTable = {}
							break
							end
						end
					end
				end
			end
		end
	end
	
	return controllableTable

end

function AIO_Umbrella.NecronomiconController(necronomiconEntity, target, position)

	if not necronomiconEntity then return end
	if not target and not position then return end

	if target ~= nil then
		if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_archer_.') then
			if not NPC.IsAttacking(necronomiconEntity) then
				if (os.clock() - AIO_Umbrella.lastCastTime) >= 0.5 then
					if not NPC.IsEntityInRange(necronomiconEntity, target, 600) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
						AIO_Umbrella.lastCastTime = os.clock()
					else			
						if Ability.IsReady(NPC.GetAbilityByIndex(necronomiconEntity, 0)) then
							if NPC.IsHero(target) then
								Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, target, Vector(0,0,0), NPC.GetAbilityByIndex(necronomiconEntity, 0), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
								AIO_Umbrella.lastCastTime = os.clock()
							end
						end
						if not Ability.IsReady(NPC.GetAbilityByIndex(necronomiconEntity, 0)) then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
							AIO_Umbrella.lastCastTime = os.clock()
						end	
					end
				end
			end
		end
		if (os.clock() - AIO_Umbrella.lastCastTime) >= 0.25 then
			if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_warrior_.') then
				if not NPC.IsAttacking(necronomiconEntity) then
					if (os.clock() - AIO_Umbrella.lastCastTime2) >= 0.5 then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
						AIO_Umbrella.lastCastTime2 = os.clock()
					end
				end
			end
		end
	end

	if position ~= nil then
		if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_archer_.') then
			if not NPC.IsAttacking(necronomiconEntity) and not NPC.IsRunning(necronomiconEntity) then
				if (os.clock() - AIO_Umbrella.lastCastTime) >= 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
					AIO_Umbrella.lastCastTime = os.clock()
				end
			end
		end
		if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_warrior_.') then
			if (os.clock() - AIO_Umbrella.lastCastTime) >= 0.25 then
				if not NPC.IsAttacking(necronomiconEntity) and not NPC.IsRunning(necronomiconEntity) then
					if (os.clock() - AIO_Umbrella.lastCastTime2) >= 0.5 then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
						AIO_Umbrella.lastCastTime2 = os.clock()
					end
				end
			end
		end	
	end

end

function AIO_Umbrella.invokerForgedSpiritController(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	for i = 1, NPCs.Count() do 
	local npc = NPCs.Get(i)
		if Entity.IsSameTeam(myHero, npc) then
			if npc ~= myHero and Entity.OwnedBy(npc, myHero) then
				if NPC.GetUnitName(npc) ~= nil then
					if  NPC.GetUnitName(npc) == "npc_dota_invoker_forged_spirit" then
						if npc ~= nil and Entity.IsAlive(npc) then
							AIO_Umbrella.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, npc)
						end	
					end
				end
			end
		end
	end

end

function AIO_Umbrella.MantaIlluController(target, position, myHero, tempestDoubleEntity)

	if not myHero then return end
	if next(AIO_Umbrella.GetIllusionEntityTable(myHero, tempestDoubleEntity)) == nil then return end
	if not target and not position then return end
	 
	local mantaIllu1 = AIO_Umbrella.GetIllusionEntityTable(myHero, tempestDoubleEntity)[1]
	local mantaIllu2 = AIO_Umbrella.GetIllusionEntityTable(myHero, tempestDoubleEntity)[2]

	if target ~= nil then
		if mantaIllu1 then
			if os.clock() - AIO_Umbrella.LastTickManta1 >= 0.5 then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu1)
				AIO_Umbrella.LastTickManta1 = os.clock()
			end
		end
		if mantaIllu2 then
			if os.clock() - AIO_Umbrella.LastTickManta2 >= 0.5 then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu2)
				AIO_Umbrella.LastTickManta2 = os.clock()
			end
		end
	end

	if position ~= nil then
		if mantaIllu1 then
			if not NPC.IsAttacking(mantaIllu1) and not NPC.IsRunning(mantaIllu1) then
				if os.clock() - AIO_Umbrella.LastTickManta1 >= 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu1)
					AIO_Umbrella.LastTickManta1 = os.clock()
				end
			end
		end
		if mantaIllu2 then
			if not NPC.IsAttacking(mantaIllu2) and not NPC.IsRunning(mantaIllu2) then
				if os.clock() - AIO_Umbrella.LastTickManta2 >= 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu2)
					AIO_Umbrella.LastTickManta2 = os.clock()
				end
			end
		end
	end	
end

function AIO_Umbrella.IsInAbilityPhase(myHero)

	if not myHero then return false end

	local myAbilities = {}

	for i= 0, 10 do
		local ability = NPC.GetAbilityByIndex(myHero, i)
		if ability and Entity.IsAbility(ability) and Ability.GetLevel(ability) > 0 then
			table.insert(myAbilities, ability)
		end
	end

	if #myAbilities < 1 then return false end

	for _, v in ipairs(myAbilities) do
		if v then
			if Ability.IsInAbilityPhase(v) then
				return true
			end
		end
	end

	return false

end

function AIO_Umbrella.GenericMainAttack(myHero, attackType, target, position)
	
	if not myHero then return end
	if not target and not position then return end

	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.IsInAbilityPhase(myHero) == true then return end

	if Menu.IsEnabled(AIO_Umbrella.optionOrbwalkEnable) then
		if target ~= nil then
			if NPC.HasModifier(myHero, "modifier_windrunner_focusfire") then
				AIO_Umbrella.GenericAttackIssuer(attackType, target, position, myHero)
			elseif NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then
				AIO_Umbrella.GenericAttackIssuer(attackType, target, position, myHero)
			else
				AIO_Umbrella.OrbWalker(myHero, target)
			end
		else
			AIO_Umbrella.GenericAttackIssuer(attackType, target, position, myHero)
		end
	else
		AIO_Umbrella.GenericAttackIssuer(attackType, target, position, myHero)
	end

end

function AIO_Umbrella.GenericAttackIssuer(attackType, target, position, npc)

	if not npc then return end
	if not target and not position then return end
	if os.clock() - AIO_Umbrella.lastAttackTime2 < 0.5 then return end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET" then
		if target ~= nil then
			if target ~= AIO_Umbrella.LastTarget then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0, 0, 0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
				AIO_Umbrella.LastTarget = target
			end
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE" then
		if position ~= nil then
			if not NPC.IsAttacking(npc) or not NPC.IsRunning(npc) then
				if position:__tostring() ~= AIO_Umbrella.LastTarget then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
					AIO_Umbrella.LastTarget = position:__tostring()
				end
			end
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION" then
		if position ~= nil then
			if position:__tostring() ~= AIO_Umbrella.LastTarget then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
				AIO_Umbrella.LastTarget = position:__tostring()
			end
		end
	end

	if target ~= nil then
		if target == AIO_Umbrella.LastTarget then
			if not NPC.IsAttacking(npc) then
				AIO_Umbrella.LastTarget = nil
				AIO_Umbrella.lastAttackTime2 = os.clock()
				return
			end
		end
	end

	if position ~= nil then
		if position:__tostring() == AIO_Umbrella.LastTarget then
			if not NPC.IsRunning(npc) then
				AIO_Umbrella.LastTarget = nil
				AIO_Umbrella.lastAttackTime2 = os.clock()
				return
			end
		end
	end

end

function AIO_Umbrella.GenericAttackIssuer2(attackType, target, position, npc)

	if not npc or (npc and not Entity.IsAlive(npc)) then return end
	if not target and not position then return end

	if AIO_Umbrella[tostring(npc)] ~= nil then
		if os.clock() - AIO_Umbrella[tostring(npc)] < 1.0 then
			return
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET" and (Menu.IsKeyDown(AIO_Umbrella.optionComboKey) or Menu.IsKeyDown(AIO_Umbrella.optionHeroVisageInstStunKey)) then
		if target ~= nil then
			Player.AttackTarget(Players.GetLocal(), npc, target, false)
			AIO_Umbrella[tostring(npc)] = os.clock()
			return
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE" then
		if position ~= nil then
			if #NPC.GetUnitsInRadius(npc, NPC.GetAttackRange(npc)+50, 1) < 1 then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
				AIO_Umbrella[tostring(npc)] = os.clock()
				return
			end
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION" then
		if position ~= nil then
			if not NPC.IsRunning(npc) then
				NPC.MoveTo(npc, position, false, false)
				AIO_Umbrella[tostring(npc)] = os.clock()
				return
			end
		end
	end
end

function AIO_Umbrella.GenericControllableAttackIssuer(attackType, target, position)

	if next(AIO_Umbrella.ControllableEntityTable) == nil then return end
	if not target and not position then return end

	local controllableEntity = nil
		for i, v in pairs(AIO_Umbrella.ControllableEntityTable) do
			if v and Entity.IsNPC(v) and Entity.IsAlive(v) and AIO_Umbrella.heroCanCastItems(v) == true then
				if AIO_Umbrella.ControllableAttackTiming[Entity.GetIndex(v)] == nil or os.clock() - AIO_Umbrella.ControllableAttackTiming[Entity.GetIndex(v)] > 0.5 then
					controllableEntity = v
					break
				end
			end
		end

	if controllableEntity ~= nil then

		if attackType == "ATTACK_TARGET" then
			if target ~= nil then
				Player.AttackTarget(Players.GetLocal(), controllableEntity, target, false)
				AIO_Umbrella.ControllableAttackTiming[Entity.GetIndex(controllableEntity)] = os.clock()
				return
			end
		end

		if attackType == "MOVE_TO_POSITION" then
			if position ~= nil then
				if not NPC.IsRunning(controllableEntity) then
					NPC.MoveTo(controllableEntity, position, false, false)
					AIO_Umbrella.ControllableAttackTiming[Entity.GetIndex(controllableEntity)] = os.clock()
					return
				end
			end
		end

	end

	return

end

function AIO_Umbrella.OrbWalker(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	if NPC.IsChannellingAbility(myHero) then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.IsInAbilityPhase(myHero) == true then return end

	local myMana = NPC.GetMana(myHero)

	local attackRange = NPC.GetAttackRange(myHero)

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)
	local attackTime = NPC.GetAttackTime(myHero)
	local movementSpeed = NPC.GetMoveSpeed(myHero)

	local attackPoint
	local attackBackSwing
	for i, v in pairs(AIO_Umbrella.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			attackPoint = v[1] / (1 + (increasedAS/100))
			attackBackSwing = v[2] / (1 + (increasedAS/100))
			break
		end
	end

	local idleTime = attackTime - attackPoint - attackBackSwing

	local turnTime180degrees = (0.03 * math.pi) / NPC.GetTurnRate(myHero)

	local orbWalkSkill
	for i, v in pairs(AIO_Umbrella.orbAttackTable) do
		if i == NPC.GetUnitName(myHero) then
			orbWalkSkill = NPC.GetAbility(myHero, v)
			break
		end
	end

	if orbWalkSkill then
		if Ability.GetName(orbWalkSkill) == "viper_poison_attack" then
			if NPC.HasModifier(enemy, "modifier_viper_poison_attack_slow") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_viper_poison_attack_slow"))
				if dieTime - GameRules.GetGameTime() > 1.0 then
					orbWalkSkill = nil
				end
			end
		end
	end

	if Entity.IsSameTeam(myHero, enemy) then
		orbWalkSkill = nil
	end

	if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		orbWalkSkill = nil
	end

	if NPC.IsRanged(myHero) then
		if AIO_Umbrella.AttackProjectileCreate > 0 then
			if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackProjectileCreate + attackBackSwing + idleTime then
				AIO_Umbrella.InAttackBackswing = true
			else
				AIO_Umbrella.InAttackBackswing = false
			end
		end
	else
		if AIO_Umbrella.AttackParticleCreate > 0 then
			if NPC.HasItem(myHero, "item_echo_sabre", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) < (attackPoint / 1.49) + 0.15 then
					AIO_Umbrella.InAttackBackswing = false
				else
					if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackParticleCreate + attackBackSwing + idleTime then
						AIO_Umbrella.InAttackBackswing = true
					else
						AIO_Umbrella.InAttackBackswing = false
					end
				end
			else
				if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackParticleCreate + attackBackSwing + idleTime then
					AIO_Umbrella.InAttackBackswing = true
				else
					AIO_Umbrella.InAttackBackswing = false
				end
			end
		end
	end

	if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackParticleCreate then
		AIO_Umbrella.InAttackBackswing = false
	end

	if os.clock() > AIO_Umbrella.AttackAnimationCreate and os.clock() < AIO_Umbrella.AttackProjectileCreate then
		AIO_Umbrella.InAttackBackswing = false
	end

	local breakPoint
		if NPC.IsRanged(myHero) then
			breakPoint = attackRange * (Menu.GetValue(AIO_Umbrella.optionOrbwalkDistance) / 100)
		else
			breakPoint = attackRange
		end

	local moveDistance = NPC.GetMoveSpeed(myHero) * (attackBackSwing + idleTime - NPC.GetTimeToFace(myHero, enemy)) * (1 - (Menu.GetValue(AIO_Umbrella.optionOrbwalkOffset) / 100))
		if NPC.IsRanged(myHero) then
			if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() > breakPoint and (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() <= breakPoint + moveDistance then
				moveDistance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - breakPoint
			end
		end

	local kiteDistance = 0
		if (2 * turnTime180degrees) < (attackBackSwing + idleTime) * (1 - (Menu.GetValue(AIO_Umbrella.optionOrbwalkOffset) / 100)) then
			kiteDistance = ((attackBackSwing + idleTime) * (1 - (Menu.GetValue(AIO_Umbrella.optionOrbwalkOffset) / 100)) - (2 * turnTime180degrees)) * NPC.GetMoveSpeed(myHero)
		end

	local styleSelector = 0
		if Menu.GetValue(AIO_Umbrella.optionOrbwalkStyle) == 0 then
			styleSelector = 1
		else
			if Menu.GetValue(AIO_Umbrella.optionOrbwalkMouseStyle) == 1 then
				styleSelector = 2
			else
				if NPC.IsRanged(myHero) then			
					styleSelector = 2
				else
					styleSelector = 1
				end
			end
		end
	
	if styleSelector < 2 then
		if not AIO_Umbrella.InAttackBackswing then
			if orbWalkSkill and Ability.IsCastable(orbWalkSkill, myMana) then
				if os.clock() - AIO_Umbrella.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastTarget(orbWalkSkill, enemy)
					AIO_Umbrella.OrbwalkerDelay = os.clock()
					return
				end
			else
				if os.clock() - AIO_Umbrella.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and os.clock() - AIO_Umbrella.AttackAnimationCreate > attackPoint + 0.1 then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					AIO_Umbrella.OrbwalkerDelay = os.clock()
					return
				end
			end
		else
			if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() > breakPoint then
				if os.clock() - AIO_Umbrella.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					if moveDistance > 50 then
						local targetVector = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(moveDistance)
						NPC.MoveTo(myHero, targetVector, false, false)
						AIO_Umbrella.OrbwalkerDelay = os.clock()
						return
					end
				end
	
			end
			if Menu.IsEnabled(AIO_Umbrella.optionOrbwalkKiting) then
				if NPC.IsRanged(myHero) then
					if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() < breakPoint - 50 then
						if os.clock() - AIO_Umbrella.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
							if kiteDistance > 50 then
								local targetVector = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(kiteDistance)
								NPC.MoveTo(myHero, targetVector, false, false)
								AIO_Umbrella.OrbwalkerDelay = os.clock()
								return
							end
						end
					end
				end
			end
		end
	else
		local mousePos = Input.GetWorldCursorPos()
		local breakPoint2
			if NPC.IsRanged(myHero) then
				breakPoint2 = attackRange * (Menu.GetValue(AIO_Umbrella.optionOrbwalkDistanceMouse) / 100)
			else
				breakPoint2 = attackRange
			end
		local moveDistance2 = NPC.GetMoveSpeed(myHero) * (attackBackSwing + idleTime - NPC.GetTimeToFace(myHero, enemy) - AIO_Umbrella.TimeToFacePosition(myHero, mousePos)) * (1 - (Menu.GetValue(AIO_Umbrella.optionOrbwalkOffset) / 100))
		
		if not AIO_Umbrella.InAttackBackswing then
			if orbWalkSkill and Ability.IsCastable(orbWalkSkill, myMana) then
				if os.clock() - AIO_Umbrella.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastTarget(orbWalkSkill, enemy)
					AIO_Umbrella.OrbwalkerDelay = os.clock()
					return
				end
			else
				if os.clock() - AIO_Umbrella.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and os.clock() - AIO_Umbrella.AttackAnimationCreate > attackPoint + 0.1 then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					AIO_Umbrella.OrbwalkerDelay = os.clock()
					return
				end
			end
		else
			if os.clock() - AIO_Umbrella.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				local myDisToMouse = (Entity.GetAbsOrigin(myHero) - mousePos):Length2D()
				if moveDistance2 > 50 and myDisToMouse > Menu.GetValue(AIO_Umbrella.optionOrbwalkMouseHold) then
					local targetVector = Entity.GetAbsOrigin(myHero) + (mousePos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(moveDistance2)
					if not NPC.IsPositionInRange(enemy, targetVector, breakPoint2, 0) then
						NPC.MoveTo(myHero, targetVector, false, false)
						AIO_Umbrella.OrbwalkerDelay = os.clock()
						return
					end
				end
			end
		end
	end

end

function AIO_Umbrella.TimeToFacePosition(myHero, pos)

	if not myHero then return 0 end
	if not pos then return 0 end

	local myPos = Entity.GetAbsOrigin(myHero)
	local myRotation = Entity.GetRotation(myHero):GetForward():Normalized()

	local baseVec = (pos - myPos):Normalized()

	local tempProcessing = math.min(baseVec:Dot2D(myRotation) / (baseVec:Length2D() * myRotation:Length2D()), 1)	

	local checkAngleRad = math.acos(tempProcessing)
	local checkAngle = (180 / math.pi) * checkAngleRad

	local myTurnRate = NPC.GetTurnRate(myHero)

	local turnTime = AIO_Umbrella.utilityRoundNumber(((0.033 * math.pi / myTurnRate) / 180) * checkAngle, 3)

	return turntime or 0

end

function AIO_Umbrella.GetLongestCooldown(myHero, skill1, skill2, skill3, skill4, skill5)

	if not myHero then return end

	local skill1 = skill1
	local skill2 = skill2
	local skill3 = skill3
	local skill4 = skill4
	local skill5 = skill5


	local tempTable = {}

	if skill1 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill1)))
	end
	if skill2 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill2)))
	end
	if skill3 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill3)))
	end
	if skill4 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill4)))
	end
	if skill5 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill5)))
	end

	table.sort(tempTable, function(a, b)
        	return a > b
    			end)

	return tempTable[1]

end

function AIO_Umbrella.GenericLanePusher(npc)

	if not npc or (npc and not Entity.IsAlive(npc)) then return end

	local myFaction = AIO_Umbrella.GetMyFaction(npc)
	local myFountainPos = AIO_Umbrella.GetMyFountainPos(npc)
	local enemyFountainPos = AIO_Umbrella.GetEnemyFountainPos(npc)

	local leftCornerPos = Vector(-5750, 6050, 384)
	local rightCornerPos = Vector(6000, -5800, 384)
	local midPos = Vector(-600, -300, 128)

	local radiantTop2 = Vector(-6150, -800, 384)
	local radiantBot2 = Vector(-800, -6250, 384)
	local radiantMid2 = Vector(-2800, -2250, 256)
	
	local direTop2 = Vector(800, 6000, 384)
	local direBot2 = Vector(6200, 400, 384)
	local direMid2 = Vector(2800, 2100, 256)


	local myBotTower2
		if myFaction == "radiant"
			then myBotTower2 = radiantBot2
		else myBotTower2 = direBot2
		end

	local myTopTower2
		if myFaction == "radiant"
			then myTopTower2 = radiantTop2
		else myTopTower2 = direTop2
		end

	local myMidTower2
		if myFaction == "radiant"
			then myMidTower2 = radiantMid2
		else myMidTower2 = direMid2
		end


	local myPos = Entity.GetAbsOrigin(npc)

	local homeSide
	if myPos:__sub(myFountainPos):Length2D() < myPos:__sub(enemyFountainPos):Length2D() then
		homeSide = true
	else homeSide = false
	end
	
	if not homeSide then
		return enemyFountainPos
	end

	if homeSide then
		if myPos:__sub(leftCornerPos):Length2D() <= 800 then
			return enemyFountainPos
		elseif myPos:__sub(rightCornerPos):Length2D() <= 800 then
			return enemyFountainPos
		elseif myPos:__sub(midPos):Length2D() <= 800 then
			return enemyFountainPos
		end
	end

	if homeSide then
		if myPos:__sub(leftCornerPos):Length2D() > 800 and myPos:__sub(rightCornerPos):Length2D() > 800 and myPos:__sub(midPos):Length2D() > 800 then
			
			if myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(midPos):Length2D() then
				return leftCornerPos
			elseif myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myTopTower2):Length2D() < myPos:__sub(midPos):Length2D() and myPos:__sub(myMidTower2):Length2D() > myPos:__sub(myTopTower2):Length2D() then
				return leftCornerPos
			elseif myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(midPos):Length2D() then
				return rightCornerPos
			elseif myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(myBotTower2):Length2D() < myPos:__sub(midPos):Length2D() and myPos:__sub(myMidTower2):Length2D() > myPos:__sub(myBotTower2):Length2D() then
				return rightCornerPos
			elseif myPos:__sub(midPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(midPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myMidTower2):Length2D() < myPos:__sub(myTopTower2):Length2D() then
				return enemyFountainPos
			elseif myPos:__sub(midPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(midPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myMidTower2):Length2D() < myPos:__sub(myBotTower2):Length2D() then
				return enemyFountainPos
			else return enemyFountainPos
			end
		end
	end
end

function AIO_Umbrella.ForceBlink(myHero, enemy, range)

	if not myHero then return end
	
	local blink = NPC.GetItem(myHero, "item_blink", true)
		if not blink then return end
		if blink and not Ability.IsReady(blink) then return end

	if not enemy or (enemy and not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), range, 0)) then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
			if NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), 1100, 0) then
				Ability.CastPosition(blink, Input.GetWorldCursorPos())
				return
			else
				if AIO_Umbrella.SleepReady(0.1) then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Input.GetWorldCursorPos(), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end	
		end
	end
end

function AIO_Umbrella:WorldToMiniMap(pos, screenWidth, screenHeight)
	local screenH = screenHeight
	local screenW = screenWidth 
	local MapLeft = -8000
	local MapTop = 7350
	local MapRight = 7500
	local MapBottom = -7200
	local mapWidth = math.abs(MapLeft - MapRight)
	local mapHeight = math.abs(MapBottom - MapTop)
	

	local x = pos:GetX() - MapLeft
	local y = pos:GetY() - MapBottom

	local dx, dy, px, py
	if self.Round(screenW / screenH, 1) >= 1.7 then

		dx = 272 / 1920 * screenW
		dy = 261 / 1080 * screenH
		px = 11 / 1920 * screenW
		py = 11 / 1080 * screenH
	elseif self.Round(screenW / screenH, 1) >= 1.5 then

		dx = 267 / 1680 * screenW
		dy = 252 / 1050 * screenH
		px = 10 / 1680 * screenW
		py = 11 / 1050 * screenH
	else
		dx = 255 / 1280 * screenW
		dy = 229 / 1024 * screenH
		px = 6 / 1280 * screenW
		py = 9 / 1024 * screenH
	end
	local minimapMapScaleX = dx / mapWidth
	local minimapMapScaleY = dy / mapHeight

	local scaledX = math.min(math.max(x * minimapMapScaleX, 0), dx)
	local scaledY = math.min(math.max(y * minimapMapScaleY, 0), dy)

	local screenX = px + scaledX
	local screenY = screenH - scaledY - py

	return Vector(math.floor(screenX - 20 + Menu.GetValue(AIO_Umbrella.optionWorldToMinimapOffsetX)), math.floor(screenY - 12 + Menu.GetValue(AIO_Umbrella.optionWorldToMinimapOffsetY)), 0)
end

function AIO_Umbrella.Round(num, numDecimalPlaces)
	local mult = 10^(numDecimalPlaces or 0)
	return math.floor(num * mult + 0.5) / mult
end

function AIO_Umbrella.TargetDisableTimer(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_item_rod_of_atos_debuff",
		"modifier_eul_cyclone",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption"
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				return Modifier.GetCreationTime(searchMod) + 4
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				return Modifier.GetCreationTime(searchMod) + (3.5 + AIO_Umbrella.GetTeammateAbilityLevel(myHero, "faceless_void_chronosphere") * 0.5)
			else
				return Modifier.GetDieTime(searchMod)
			end
		else
			return 0
		end
	else
		return 0
	end

end

function AIO_Umbrella.GetTeammateAbilityLevel(myHero, ability)

	if not myHero then return end
	if not ability then return 0 end

	for _, teamMate in ipairs(NPC.GetHeroesInRadius(myHero, 99999, Enum.TeamType.TEAM_FRIEND)) do
		if NPC.HasAbility(teamMate, ability) then
			if NPC.GetAbility(teamMate, ability) then
				return Ability.GetLevel(NPC.GetAbility(teamMate, ability))
			end
		end
	end
	return 0

end

function AIO_Umbrella.TargetIsInvulnarable(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local curTime = GameRules.GetGameTime()

	local invuList = {
		"modifier_eul_cyclone",
		"modifier_invoker_tornado",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption"
			}
	
	local searchMod
	for _, modifier in ipairs(invuList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			return Modifier.GetDieTime(searchMod)
		else
			return 0
		end
	else
		return 0
	end

end

function AIO_Umbrella.EnemyHPTracker(myHero)

	if not myHero then return end

	if Heroes.Count() == 0 then
		AIO_Umbrella.enemyHeroTable = {}
		return
	end	

	for i = 1, Heroes.Count() do
		local allHeroes = Heroes.Get(i)
	
		if allHeroes == nil then
			AIO_Umbrella.enemyHeroTable = {}
			return
		else
			if Entity.IsHero(allHeroes) and not Entity.IsSameTeam(myHero, allHeroes) then
				if not NPC.IsIllusion(allHeroes) then
					if AIO_Umbrella.enemyHeroTable[allHeroes] == nil then
						AIO_Umbrella.enemyHeroTable[allHeroes] = { 99999, 99999, 0 }
					end
				end
			end
		end
	end

	for hero, data in pairs(AIO_Umbrella.enemyHeroTable) do
		if hero and not Entity.IsNPC(hero) then
			AIO_Umbrella.enemyHeroTable[hero] = nil
		end
		if hero and Entity.IsNPC(hero) and Entity.IsAlive(hero) and not Entity.IsDormant(hero) and GameRules.GetGameTime() - data[3] > 1 then
			local heroHP = Entity.GetHealth(hero)
			local heroHPreg = NPC.GetHealthRegen(hero)
			local timeStamp = GameRules.GetGameTime()
			AIO_Umbrella.enemyHeroTable[hero] = { heroHP, heroHPreg, timeStamp }
		end
	end

end

function AIO_Umbrella.getEnemyBeShackledWithNPC(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)
	local shackleShot = NPC.GetAbility(myHero, "windrunner_shackleshot")
		if not shackleShot then return end
		if not Ability.IsCastable(shackleShot, myMana) then return end

	local shackleSearchRange = 575
	local shackleCastRange = 785

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunnerPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(shackleSearchRange)

	local npcs = Entity.GetUnitsInRadius(enemy, shackleSearchRange, Enum.TeamType.TEAM_FRIEND)
		if next(npcs) == nil then return end

		local shackleNPC
		local minAngle = 180
		local minRange = 99999	

		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length2D()
				local myDisToNPC = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetNPC)):Length2D()
				local enemyDisToNPC = (enemyPos - Entity.GetAbsOrigin(targetNPC)):Length2D()
				if myDisToEnemy < myDisToNPC then
					if myDisToEnemy < shackleCastRange then
						local vectorEnemyToNPC = Entity.GetAbsOrigin(targetNPC) - enemyPos
						local vectormyHerotoEnemy = enemyPos - Entity.GetAbsOrigin(myHero)
						local tempProcessing = vectormyHerotoEnemy:Dot2D(vectorEnemyToNPC) / (vectormyHerotoEnemy:Length2D() * vectorEnemyToNPC:Length2D())
							if tempProcessing > 1 then
								tempProcessing = 1
							end	
						local searchAngleRad = math.acos(tempProcessing)
						local searchAngle = (180 / math.pi) * searchAngleRad
						if searchAngle < minAngle then
							shackleNPC = enemy
							minAngle = searchAngle
						end
					end
				else
					if myDisToNPC < shackleCastRange then
						local vectorNPCToEnemy = enemyPos - Entity.GetAbsOrigin(targetNPC)
						local vectormyHerotoNPC = Entity.GetAbsOrigin(targetNPC) - Entity.GetAbsOrigin(myHero)
						local tempProcessing = vectormyHerotoNPC:Dot2D(vectorNPCToEnemy) / (vectormyHerotoNPC:Length2D() * vectorNPCToEnemy:Length2D())
							if tempProcessing > 1 then
								tempProcessing = 1
							end	
						local searchAngleRad = math.acos(tempProcessing)
						local searchAngle = (180 / math.pi) * searchAngleRad
						if searchAngle < minAngle and vectorNPCToEnemy:Length2D() < minRange then
							shackleNPC = targetNPC
							minAngle = searchAngle
							minRange = vectorNPCToEnemy:Length2D()
						end
					end
				end
			end
		end

		if shackleNPC and minAngle < 23 then
			return shackleNPC
		end
	
	return

end

function AIO_Umbrella.getEnemyShackledBestPosition(myHero, enemy, dist)

	if not myHero then return Vector() end
	if not enemy then return Vector() end
	if not dist then return Vector() end

	local myMana = NPC.GetMana(myHero)
	local shackleShot = NPC.GetAbility(myHero, "windrunner_shackleshot")
		if not shackleShot then return Vector() end
		if not Ability.IsCastable(shackleShot, myMana) then return Vector() end

	local shackleSearchRange = 575
	local shackleCastRange = 785

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunnerPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(shackleSearchRange)

	local shacklePos = Vector()
	local minDis = 99999
	local minCreepDis = 99999

	if not AIO_Umbrella.canEnemyBeShackledWithTree(myHero, enemy) and AIO_Umbrella.getEnemyBeShackledWithNPC(myHero, enemy) == nil then
		local npcs = Entity.GetUnitsInRadius(enemy, shackleSearchRange, Enum.TeamType.TEAM_FRIEND)
		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length2D()
				local myDisToNPC = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetNPC)):Length2D()
				local enemyDisToNPC = (enemyPos - Entity.GetAbsOrigin(targetNPC)):Length2D()
				
				if myDisToEnemy < myDisToNPC then
					local vectorNPCtoEnemy = enemyPos - Entity.GetAbsOrigin(targetNPC)
					local searchVec = Entity.GetAbsOrigin(targetNPC) + vectorNPCtoEnemy:Normalized():Scaled(vectorNPCtoEnemy:Length2D() + 250)
					local myDisToSearchPos = (searchVec - Entity.GetAbsOrigin(myHero)):Length2D()
					if #Trees.InRadius(searchVec, 300, true) < 1 and #Heroes.InRadius(searchVec, 150, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
						if myDisToSearchPos < minDis then
							shacklePos = searchVec
							minDis = myDisToSearchPos
						end
					end
				else
					local vectorEnemyToNPC = Entity.GetAbsOrigin(targetNPC) - enemyPos
					local searchVec = enemyPos + vectorEnemyToNPC:Normalized():Scaled(vectorEnemyToNPC:Length2D() + 250)
					local myDisToSearchPos = (searchVec - Entity.GetAbsOrigin(myHero)):Length2D()
					if #Trees.InRadius(searchVec, 300, true) < 1 and #Heroes.InRadius(searchVec, 150, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
						if myDisToSearchPos < minDis and vectorEnemyToNPC:Length2D() < minCreepDis then
							shacklePos = searchVec
							minDis = myDisToSearchPos
							minCreepDis = vectorEnemyToNPC:Length2D()
						end
					end
				end
			end
		end
		
		if shacklePos:__tostring() == Vector():__tostring() then
			if next(AIO_Umbrella.getEnemyShackleTrees(myHero, enemy)) ~= nil then
				for _, targetTree in ipairs(AIO_Umbrella.getEnemyShackleTrees(myHero, enemy)) do
					if targetTree then
						local vectorTreeToEnemy = enemyPos - Entity.GetAbsOrigin(targetTree)
						local searchVec = Entity.GetAbsOrigin(targetTree) + vectorTreeToEnemy:Normalized():Scaled(vectorTreeToEnemy:Length2D() + 350)
						local myDisToSearchPos = (searchVec - Entity.GetAbsOrigin(myHero)):Length2D()
						if #Trees.InRadius(searchVec, 300, true) < 1 and #Heroes.InRadius(searchVec, 300, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
							if myDisToSearchPos < minDis then
								shacklePos = searchVec
								minDis = myDisToSearchPos
							end
						end
					end
				end
			end	
		end
	end
	
	if shacklePos:__tostring() ~= Vector():__tostring() and minDis < dist then
		return shacklePos
	end

	return Vector()

end

function AIO_Umbrella.getEnemyShackleTrees(myHero, enemy)

	if not myHero then return {} end
	if not enemy then return {} end

	local shackleSearchRange = 575

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunnerPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local trees = Trees.InRadius(enemyPos, shackleSearchRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			table.insert(returnTrees, targetTree)
		end
	end

	if next(returnTrees) ~= nil then
		return returnTrees
	end
	return {}

end
			
function AIO_Umbrella.canEnemyBeShackledWithTree(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)
	local shackleShot = NPC.GetAbility(myHero, "windrunner_shackleshot")
		if not shackleShot then return false end
		if not Ability.IsCastable(shackleShot, myMana) then return false end

	local shackleSearchRange = 575
	local shackleCastRange = 785

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunnerPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(shackleSearchRange)

	local trees = Trees.InRadius(directLineVector, shackleSearchRange, true)
		if next(trees) == nil then return false end

		local shackleTree
		local minAngle = 180
		
		for _, targetTree in ipairs(trees) do		
			if targetTree then
				local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length2D()
				local enemyDisToTree = (enemyPos - Entity.GetAbsOrigin(targetTree)):Length2D()
				if myDisToEnemy < shackleCastRange then
					if enemyDisToTree < shackleSearchRange then
						if targetTree ~= nil then
							local vectorEnemyToTree = Entity.GetAbsOrigin(targetTree) - enemyPos
							local vectormyHerotoEnemy = enemyPos - Entity.GetAbsOrigin(myHero)
							local tempProcessing = vectormyHerotoEnemy:Dot2D(vectorEnemyToTree) / (vectormyHerotoEnemy:Length2D() * vectorEnemyToTree:Length2D())
							if tempProcessing > 1 then
								tempProcessing = 1
							end
							local searchAngleRad = math.acos(tempProcessing)
							local searchAngle = (180 / math.pi) * searchAngleRad
							if searchAngle < minAngle then
								shackleTree = targetTree
								minAngle = searchAngle
							end
						end
					end
				end
			end
		end

		if shackleTree and minAngle < 23 then
			return true
		end
	
	return false

end

function AIO_Umbrella.TimberIsTreeInRangeForChain(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return end
		if not Ability.IsCastable(timberChain, myMana) then return end

	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroTimberPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local remainingDis = chainCastRange - (enemyPos - Entity.GetAbsOrigin(myHero)):Length2D()
	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(remainingDis)

	local trees = Trees.InRadius(directLineVector, remainingDis, true)
		if next(trees) == nil then return end

		local chainTree
		local minDis = 99999
		
		for _, targetTree in ipairs(trees) do		
			if targetTree then
				local myDisToTree = (Entity.GetAbsOrigin(targetTree) - Entity.GetAbsOrigin(myHero)):Length2D()
				if myDisToTree < chainCastRange then
					local vectormyHeroToTree = Entity.GetAbsOrigin(targetTree) - Entity.GetAbsOrigin(myHero)
					if AIO_Umbrella.TimberAmIhittingWithChain(myHero, enemy, Entity.GetAbsOrigin(targetTree)) == true and myDisToTree < minDis then
						chainTree = targetTree
						minDis = myDisToTree
					end
				end
			end
		end


		if chainTree then
			return chainTree
		end
	
	return 

end

function AIO_Umbrella.TimberAmIhittingWithChain(myHero, enemy, pos)

	if not myHero then return false end
	if not enemy then return false end
	if not pos then return false end

	local myPos = Entity.GetAbsOrigin(myHero)
	local chainDistance = (pos - myPos):Length2D()
	local chainVector = myPos - pos

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroTimberPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local checkNum = tonumber(math.floor(chainDistance/150) + 1)
	for i = checkNum, 1, -1 do 
        	chainVector:Normalize()
        	chainVector:Scale(150 * (i-1))
        	local checkPos = pos + chainVector
		if (checkPos - enemyPos):Length2D() < 200 then
            		return true
		end
	end

	return false

end

function AIO_Umbrella.TimberGetEnemyChainTrees(myHero, enemy)

	if not myHero then return {} end
	if not enemy then return {} end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
		if not Ability.IsCastable(timberChain, myMana) then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroTimberPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local remainingDis = chainCastRange - (enemyPos - Entity.GetAbsOrigin(myHero)):Length2D()

	local trees = Trees.InRadius(enemyPos, remainingDis, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			table.insert(returnTrees, targetTree)
		end
	end

	if next(returnTrees) ~= nil then
		return returnTrees
	end
	return {}

end

function AIO_Umbrella.GetClosestPoint(A,  B,  P, segmentClamp)
	
	A:SetZ(0)
	B:SetZ(0)
	P:SetZ(0)

	local Ax = A:GetX()
	local Ay = A:GetY()
	local Bx = B:GetX()
	local By = B:GetY()
	local Px = P:GetX()
	local Py = P:GetY()

	local AP = P - A
	local AB = B - A

	local APx = AP:GetX()
	local APy = AP:GetY()

	local ABx = AB:GetX()
	local ABy = AB:GetY()

	local ab2 = ABx*ABx + ABy*ABy
	local ap_ab = APx*ABx + APy*ABy

	local t = ap_ab / ab2
 
	if (segmentClamp or true) then
		if (t < 0.0) then
			t = 0.0
		elseif (t > 1.0) then
			t = 1.0
		end
	end
 
	local Closest = Vector(Ax + ABx*t, Ay + ABy * t, 0)
 
	return Closest
end

function AIO_Umbrella.TimberGetBestChainPos(myHero, enemy, dist)

	if not myHero then return Vector() end
	if not enemy then return Vector() end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return Vector() end
		if not Ability.IsCastable(timberChain, myMana) then return Vector() end

	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(AIO_Umbrella.optionHeroTimberPredict) then
		enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local remainingDis = chainCastRange - (enemyPos - Entity.GetAbsOrigin(myHero)):Length2D()

	local chainPos = Vector()
	local minDis = 99999

	if AIO_Umbrella.TimberIsTreeInRangeForChain(myHero, enemy) == nil then
		if next(AIO_Umbrella.TimberGetEnemyChainTrees(myHero, enemy)) ~= nil then
			for _, targetTree in ipairs(AIO_Umbrella.TimberGetEnemyChainTrees(myHero, enemy)) do
				if targetTree then
					local vectorTreeToEnemy = enemyPos - Entity.GetAbsOrigin(targetTree)
					local vectorTreeTomyHero = Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetTree)
					local searchVec = enemyPos + vectorTreeToEnemy:Normalized():Scaled(chainCastRange)
					local closestPointToSearchVec = AIO_Umbrella.GetClosestPoint(enemyPos, searchVec, Entity.GetAbsOrigin(myHero), true)
					local disClosestPointToSearchVec = (closestPointToSearchVec - Entity.GetAbsOrigin(myHero)):Length2D()
					if #Trees.InRadius(closestPointToSearchVec, 300, true) < 1 then
						if (closestPointToSearchVec - Entity.GetAbsOrigin(targetTree)):Length2D() < chainCastRange then
							if disClosestPointToSearchVec < minDis then
								chainPos = closestPointToSearchVec
								minDis = disClosestPointToSearchVec
							end
						end
					end
				end
			end
		end
	end
		
	
	if chainPos:__tostring() ~= Vector():__tostring() and minDis < dist then
		return chainPos
	end

	return Vector()

end

function AIO_Umbrella.TimberPanicIsTreeInChainWay(myHero, pos)

	if not myHero then return false end
	if not pos then return false end

	local myPos = Entity.GetAbsOrigin(myHero)
	local chainDistance = (pos - myPos):Length2D()
	local chainVector = myPos - pos

	local checkNum = tonumber(math.floor(chainDistance/50))
	for i = checkNum, 1, -1 do 
        	chainVector:Normalize()
        	chainVector:Scale(50 * (i))
        	local checkPos = pos + chainVector
		if #Trees.InRadius(checkPos, 50, true) < 1 then
            		return true
		end
	end

	return false

end

function AIO_Umbrella.TimberGetEscapeChainTrees(myHero)

	if not myHero then return {} end

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local myPos = Entity.GetAbsOrigin(myHero)

	local trees = Trees.InRadius(myPos, chainCastRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			local disTreeTomyHero = (Entity.GetAbsOrigin(targetTree) - Entity.GetAbsOrigin(myHero)):Length2D()
			if AIO_Umbrella.TimberPanicIsTreeInChainWay(myHero, Entity.GetAbsOrigin(targetTree)) == true then
				table.insert(returnTrees, { disTreeTomyHero, targetTree })
			end
		end
	end

	if next(returnTrees) ~= nil then
		table.sort(returnTrees, function(a, b)
        		return a[1] > b[1]
    		end)

		return returnTrees
	end
	return {}

end

function AIO_Umbrella.TimberGetEscapeChainTreesFountain(myHero)

	if not myHero then return {} end

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local myPos = Entity.GetAbsOrigin(myHero)

	local trees = Trees.InRadius(myPos, chainCastRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			local myFountainPos = AIO_Umbrella.GetMyFountainPos(myHero)
			local disTreeToFountain = (Entity.GetAbsOrigin(targetTree) - myFountainPos):Length2D()
			local dismyHeroToFountain = (myPos - myFountainPos):Length2D()
			if disTreeToFountain < dismyHeroToFountain then
				if AIO_Umbrella.TimberPanicIsTreeInChainWay(myHero, Entity.GetAbsOrigin(targetTree)) == true then
					table.insert(returnTrees, { disTreeToFountain, targetTree })
				end
			end
		end
	end

	if next(returnTrees) ~= nil then
		table.sort(returnTrees, function(a, b)
        		return a[1] < b[1]
    		end)

		return returnTrees
	end
	return {}

end

function AIO_Umbrella.TimberGetTreesFastMoveCursor(myHero)

	if not myHero then return {} end

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local myPos = Entity.GetAbsOrigin(myHero)

	local trees = Trees.InRadius(myPos, chainCastRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
		local cursorPos = Input.GetWorldCursorPos()
		local disTreeToCursor = (Entity.GetAbsOrigin(targetTree) - cursorPos):Length2D()
		local disTreeTomyHero = (Entity.GetAbsOrigin(targetTree) - myPos):Length2D()
		local dismyHeroToCursor = (myPos - cursorPos):Length2D()
			if disTreeToCursor < dismyHeroToCursor then
				if disTreeTomyHero > 500 then
					if AIO_Umbrella.TimberPanicIsTreeInChainWay(myHero, Entity.GetAbsOrigin(targetTree)) == true then
						table.insert(returnTrees, { disTreeToCursor, targetTree })
					end
				end
			end
		end
	end

	if next(returnTrees) ~= nil then
		table.sort(returnTrees, function(a, b)
        		return a[1] < b[1]
    		end)

		return returnTrees
	end
	return {}

end

function AIO_Umbrella.TargetIndicator(myHero)

	if not myHero then return end

	local curtime = GameRules.GetGameTime()	

	if Menu.GetValue(AIO_Umbrella.optionLockTargetParticle) < 2 then
		if AIO_Umbrella.LockedTarget ~= nil then
			if curtime > AIO_Umbrella.particleNextTime then
				if AIO_Umbrella.currentParticle > 0 then
					Particle.Destroy(AIO_Umbrella.currentParticle)
					AIO_Umbrella.currentParticle = 0
				end
	
				if Menu.GetValue(AIO_Umbrella.optionLockTargetParticle) == 0 then
					local sparkParticle = Particle.Create("particles/items_fx/aegis_resspawn_flash.vpcf")
					AIO_Umbrella.currentParticle = sparkParticle
			
					Particle.SetControlPoint(sparkParticle, 0, Entity.GetAbsOrigin(AIO_Umbrella.LockedTarget))
				else
					local bloodParticle = Particle.Create("particles/items2_fx/soul_ring_blood.vpcf")
					AIO_Umbrella.currentParticle = bloodParticle
					Particle.SetControlPoint(bloodParticle, 0, Entity.GetAbsOrigin(AIO_Umbrella.LockedTarget))
				end

	      		AIO_Umbrella.particleNextTime = curtime + 0.35
			end
		end
	else
		if (not AIO_Umbrella.LockedTarget or AIO_Umbrella.LockedTarget ~= AIO_Umbrella.currentParticleTarget) and AIO_Umbrella.currentParticle > 0 then
			Particle.Destroy(AIO_Umbrella.currentParticle)			
			AIO_Umbrella.currentParticle = 0
			AIO_Umbrella.currentParticleTarget = AIO_Umbrella.LockedTarget
		else
			if AIO_Umbrella.currentParticle == 0 and AIO_Umbrella.LockedTarget then
				local towerParticle = Particle.Create("particles/ui_mouseactions/range_finder_tower_aoe.vpcf", Enum.ParticleAttachment.PATTACH_INVALID, AIO_Umbrella.LockedTarget)	
				AIO_Umbrella.currentParticle = towerParticle
				AIO_Umbrella.currentParticleTarget = AIO_Umbrella.LockedTarget			
			end
			if AIO_Umbrella.currentParticle > 0 then
				Particle.SetControlPoint(AIO_Umbrella.currentParticle, 2, Entity.GetOrigin(myHero))
				Particle.SetControlPoint(AIO_Umbrella.currentParticle, 6, Vector(1, 0, 0))
				Particle.SetControlPoint(AIO_Umbrella.currentParticle, 7, Entity.GetOrigin(AIO_Umbrella.currentParticleTarget))
			end
		end
	end

end

-- dodgeIT
function AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange)

	if not myHero then return false end
	if not unit then return false end

	local angle = Entity.GetRotation(unit)

	local direction = angle:GetForward()
    	local name = NPC.GetUnitName(unit)
    		direction:SetZ(0)

    	local origin = NPC.GetAbsOrigin(unit)

	if radius == 0 then
		radius = 100
	end

    	local pointsNum = math.floor(castrange/50) + 1
    	for i = pointsNum,1,-1 do 
        	direction:Normalize()
        	direction:Scale(50*(i-1))
        	local pos = origin + direction
        	if NPC.IsPositionInRange(myHero, pos, radius + NPC.GetHullRadius(myHero), 0) then 
            		return true 
        	end
    	end 
    	return false

end

function AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)

	if not myHero then return end
	if not unit then return end

	local angle = Entity.GetRotation(unit)

	local direction = angle:GetForward()
    		direction:SetZ(0)

    	local origin = NPC.GetAbsOrigin(unit)

	if radius == 0 then
		radius = 100
	end

	local alliesAround = Entity.GetHeroesInRadius(unit, radius + castrange, Enum.TeamType.TEAM_ENEMY)
		if #alliesAround < 1 then return end

	local pointsNum = math.floor(castrange/50) + 1
	
	local targetAlly = nil
	local facing = 99999
	local lowest = 99999
	for i, v in ipairs(alliesAround) do
		if v and Entity.IsHero(v) and Entity.IsAlive(v) and v ~= myHero then
			if NPC.IsEntityInRange(unit, v, radius + castrange) and NPC.IsEntityInRange(myHero, v, 885) then
				if castrange > 1 then
					if NPC.GetTimeToFace(unit, v) < facing then
						facing = NPC.GetTimeToFace(unit, v)
						targetAlly = v
					end
				else
					if Entity.GetHealth(v) < lowest then
						lowest = Entity.GetHealth(v)
						targetAlly = v
					end
				end	
			end
		end
	end	

	return targetAlly

end

function AIO_Umbrella.dodgerEmberSkillsChecker(myHero, skillName)

	if not myHero then return false end
	if not skillName then return false end

	if skillName == "ember_spirit_sleight_of_fist" then
		local effectRange = Ability.GetLevel(NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")) * 100 + 150
		for i = 0, math.floor(700 / effectRange) do
			if #NPCs.InRadius(Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange), effectRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
				return true
			end
		end
	end

	if skillName == "ember_spirit_activate_fire_remnant" then
		if NPC.HasModifier(myHero, "modifier_ember_spirit_fire_remnant_timer") then
			return true
		end
	end

	return false

end

function AIO_Umbrella.saveIt(info)

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Entity.IsAlive(myHero) then return end
	
	if not info then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsSaver) then return end

	local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local lotus = NPC.GetItem(myHero, "item_lotus_orb", true)
	local myMana = NPC.GetMana(myHero)

	local itemCheck = glimmer or lotus or nil
		if not itemCheck then return end

	if glimmer then
		if not Ability.IsCastable(glimmer, myMana) then
			if lotus then
				if not Ability.IsCastable(lotus, myMana) then
					return
				end
			else
				return
			end
		end
	else
		if lotus then
			if not Ability.IsCastable(lotus, myMana) then
				return
			end
		else
			return
		end
	end

	if info.target and Entity.IsHero(info.target) and Entity.IsAlive(info.target) then
		if info.lotus == 1 and NPC.IsLinkensProtected(info.target) then return end
		if info.lotus == 1 and NPC.HasModifier(info.target, "modifier_item_lotus_orb_active") then return end
		if info.style == 2 and NPC.HasState(info.target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end
		if NPC.HasModifier(info.target, "modifier_item_glimmer_cape_fade") then return end
		if NPC.HasModifier(info.target, "modifier_templar_assassin_refraction_absorb") then return end
	end

	if os.clock() - AIO_Umbrella.saverTiming < 0.5 then return end

	local curTime = GameRules.GetGameTime()

	local saveObject
		if lotus then
			if Ability.IsCastable(lotus, myMana) then
				if info.lotus == 0 then
					if glimmer then
						if Ability.IsCastable(glimmer, myMana) then
							saveObject = glimmer
						else
							saveObject = nil
						end
					else
						saveObject = nil
					end
				else
					saveObject = lotus
				end
			else
				if glimmer then
					if Ability.IsCastable(glimmer, myMana) then
						saveObject = glimmer
					else
						saveObject = nil
					end
				else
					saveObject = nil
				end
			end
		else
			if glimmer then
				if Ability.IsCastable(glimmer, myMana) then
					saveObject = glimmer
				else
					saveObject = nil
				end
			else
				saveObject = nil
			end
		end
	
	if saveObject == nil then return end		

	local target = info.target

	if target and Entity.IsHero(target) and NPC.IsEntityInRange(myHero, target, 895) then
		Ability.CastTarget(saveObject, target)
		AIO_Umbrella.saverTiming = os.clock()
		AIO_Umbrella.lastDefItemPop = os.clock()
		return
	end

end

function AIO_Umbrella.dodgeIt(info)

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Entity.IsAlive(myHero) then return end
	
	if not info then return end

	if next(AIO_Umbrella.dodgeItReadyTable) == nil then return end

	if not Menu.IsEnabled(AIO_Umbrella.dodgeEnemySkillsOptionsTable[info.spellname]) then return end

	local myMana = NPC.GetMana(myHero)	

	local dodgeSelector
	local dodgeItemStyle
	local dodgeTargeting
	local dodgeTiming

	if next(AIO_Umbrella.dodgeItSkillReady) ~= nil then
		if NPC.HasAbility(myHero, AIO_Umbrella.dodgeItSkillReady[1]["skillname"]) then
			if Ability.IsReady(NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkillReady[1]["skillname"])) and Ability.IsCastable(NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkillReady[1]["skillname"]), myMana) then
				if AIO_Umbrella.dodgeItSkillReady[1]["skillstyle"] <= info.style then
					if AIO_Umbrella.dodgeItSkillReady[1]["skilloffset"] < info.delay then
						if AIO_Umbrella.dodgeItSkillReady[1]["skillname"] == "slark_dark_pact" then
							if info.type == "disable" then
								dodgeSelector = NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkillReady[1]["skillname"])
								dodgeItemStyle = AIO_Umbrella.dodgeItSkillReady[1]["skillstyle"]
								dodgeTargeting = AIO_Umbrella.dodgeItSkillReady[1]["skilltargeting"]
								dodgeTiming = AIO_Umbrella.dodgeItSkillReady[1]["skilloffset"]
							end
						else
							dodgeSelector = NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkillReady[1]["skillname"])
							dodgeItemStyle = AIO_Umbrella.dodgeItSkillReady[1]["skillstyle"]
							dodgeTargeting = AIO_Umbrella.dodgeItSkillReady[1]["skilltargeting"]
							dodgeTiming = AIO_Umbrella.dodgeItSkillReady[1]["skilloffset"]
						end
					end
				end
			end
		end
		if #AIO_Umbrella.dodgeItSkillReady > 1 then
			if dodgeSelector == nil then
				if NPC.HasAbility(myHero, AIO_Umbrella.dodgeItSkillReady[2]["skillname"]) then
					if Ability.IsReady(NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkillReady[2]["skillname"])) and Ability.IsCastable(NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkillReady[2]["skillname"]), myMana) then
						if AIO_Umbrella.dodgeItSkillReady[2]["skillstyle"] <= info.style then
							if AIO_Umbrella.dodgeItSkillReady[2]["skilloffset"] < info.delay then
								dodgeSelector = NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkillReady[2]["skillname"])
								dodgeItemStyle = AIO_Umbrella.dodgeItSkillReady[2]["skillstyle"]
								dodgeTargeting = AIO_Umbrella.dodgeItSkillReady[2]["skilltargeting"]
								dodgeTiming = AIO_Umbrella.dodgeItSkillReady[2]["skilloffset"]
							end
						end
					end
				end
			end
		end		
	end

	if dodgeSelector ~= nil and Ability.GetName(dodgeSelector) == "ember_spirit_sleight_of_fist" then
		if not AIO_Umbrella.dodgerEmberSkillsChecker(myHero, "ember_spirit_sleight_of_fist") then
			dodgeSelector = nil
		end
	end

	if dodgeSelector == nil then
		for i, v in ipairs(AIO_Umbrella.dodgeItReadyTable) do
			if info.lotus == 0 then
				if info.global == 0 then
					if v.itemname ~= "item_lotus_orb" then
						if (NPC.GetUnitName(info.source) == "npc_dota_hero_lion" and info.style == 1) or NPC.GetUnitName(info.source) == "npc_dota_hero_nyx_assassin" or NPC.GetUnitName(info.source) == "npc_dota_hero_tidehunter" then
							if v.itemname ~= "item_manta" then
								if v.itemstyle <= info.style then
									if NPC.HasItem(myHero, v.itemname) then
										if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
											dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
											dodgeItemStyle = v.itemstyle
											dodgeTargeting = v.itemtargeting
											dodgeTiming = v.itemoffset
											break
										end
									end
								end
							end

						else
							if v.itemstyle <= info.style then
								if NPC.HasItem(myHero, v.itemname) then
									if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
										dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
										dodgeItemStyle = v.itemstyle
										dodgeTargeting = v.itemtargeting
										dodgeTiming = v.itemoffset
										break
									end
								end
							end
						end
					end
				else
					if v.itemname ~= "item_blink" then
						if v.itemstyle <= info.style then
							if NPC.HasItem(myHero, v.itemname) then
								if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
									dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
									dodgeItemStyle = v.itemstyle
									dodgeTargeting = v.itemtargeting
									dodgeTiming = v.itemoffset
									break
								end
							end
						end
					end
				end			
			else
				if v.itemstyle <= info.style then
					if NPC.HasItem(myHero, v.itemname) then
						if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
							dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
							dodgeItemStyle = v.itemstyle
							dodgeTargeting = v.itemtargeting
							dodgeTiming = v.itemoffset
							break
						end
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_ember_spirit" and dodgeSelector == nil then
		if Menu.IsEnabled(AIO_Umbrella.dodgeEnemyHeroSpecialEmber) then
			if AIO_Umbrella.dodgerEmberSkillsChecker(myHero, "ember_spirit_activate_fire_remnant") then
				dodgeSelector = NPC.GetAbility(myHero, "ember_spirit_activate_fire_remnant")
				dodgeItemStyle = 0
				dodgeTargeting = "position"
				dodgeTiming = 0.1
			end
		end
	end		

	if dodgeSelector == nil then 
		return
	end


	local delay = info.delay
		if NPC.GetUnitName(info.source) == "npc_dota_hero_lina" then
			if Ability.GetName(dodgeSelector) == "item_blink" or Ability.GetName(dodgeSelector) == "item_lotus_orb" or Ability.GetName(dodgeSelector) == "nyx_assassin_spiked_carapace" or Ability.GetName(dodgeSelector) == "sandking_sand_storm" or Ability.GetName(dodgeSelector) == "templar_assassin_meld" then
				delay = info.delay - 0.225
			end
		elseif NPC.GetUnitName(info.source) == "npc_dota_hero_lion" and info.spellname == "lion_finger_of_death" then
			if Ability.GetName(dodgeSelector) == "item_blink" or Ability.GetName(dodgeSelector) == "item_lotus_orb" or Ability.GetName(dodgeSelector) == "nyx_assassin_spiked_carapace" or Ability.GetName(dodgeSelector) == "sandking_sand_storm" or Ability.GetName(dodgeSelector) == "templar_assassin_meld" then
				delay = info.delay - 0.275
			end
		end

	if info.time + delay - dodgeTiming + 0.05 < GameRules.GetGameTime() then return end

	if info.lotus == 1 and NPC.IsLinkensProtected(myHero) then return end
	if info.lotus == 1 and NPC.HasModifier(myHero, "modifier_item_lotus_orb_active") then return end
	if info.style == 2 and NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end
	if NPC.HasModifier(myHero, "modifier_item_glimmer_cape_fade") then return end
	if NPC.HasModifier(myHero, "modifier_templar_assassin_refraction_absorb") then return end
	if NPC.HasModifier(myHero, "modifier_item_blade_mail_reflect") then return end
	if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then return end
	
	if NPC.HasItem(myHero, "item_blade_mail", true) and Menu.IsEnabled(AIO_Umbrella.optionItemBlademail) and Ability.IsCastable(NPC.GetItem(myHero, "item_blade_mail", true), myMana) then return end
	if NPC.HasItem(myHero, "item_hurricane_pike", true) and Menu.IsEnabled(AIO_Umbrella.optionItemHurricane) and Ability.IsCastable(NPC.GetItem(myHero, "item_hurricane_pike", true), myMana) then return end

	if NPC.HasItem(myHero, "item_blade_mail", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) < 0.25 then return end
	if NPC.HasItem(myHero, "item_hurricane_pike", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) < 0.25 then return end
	
	local projectilespeed = 0
		if info.projectilespeed ~= nil then
			projectilespeed = info.projectilespeed
		end

	local projectileextradelay = 0
		if info.projectileextradelay ~= nil then
			projectileextradelay = info.projectileextradelay
		end

	if next(AIO_Umbrella.dodgeItTable) == nil then
		table.insert(AIO_Umbrella.dodgeItTable, {casttime = info.time, delay = delay, unit = info.source, dodgeobject = dodgeSelector, objecttargeting = dodgeTargeting, objectoffset = dodgeTiming, castpoint = info.castpoint, spellname = info.spellname, originpos = Entity.GetAbsOrigin(info.source), projectilespeed = projectilespeed, projectileextradelay = projectileextradelay})
	end

end

function AIO_Umbrella.dodgerSkillAvailable(myHero)

	if not myHero then return end

	if next(AIO_Umbrella.dodgeItSkillReady) == nil then

		for i = 1, #AIO_Umbrella.dodgeItSkills do
			if NPC.HasAbility(myHero, AIO_Umbrella.dodgeItSkills[i][1]) then
				if Menu.IsEnabled(AIO_Umbrella.dodgeEnemyHeroskillsOptionsTable[AIO_Umbrella.dodgeItSkills[i][1]]) then
					if Ability.GetLevel(NPC.GetAbility(myHero, AIO_Umbrella.dodgeItSkills[i][1])) > 0 then
						table.insert(AIO_Umbrella.dodgeItSkillReady, {skillname = AIO_Umbrella.dodgeItSkills[i][1], skillstyle = AIO_Umbrella.dodgeItSkills[i][2], skilltargeting = AIO_Umbrella.dodgeItSkills[i][3], skilloffset = AIO_Umbrella.dodgeItSkills[i][4] })
					end
				end
			end
		end
	end

end
				
function AIO_Umbrella.dodgerSelectItemorSkill(myHero)

	if not myHero then return end

	if next(AIO_Umbrella.dodgeItReadyTable) == nil then

		for i = 1, #AIO_Umbrella.dodgeItItems do
			if Menu.GetValue(AIO_Umbrella.dodgeItOptionTable[i]) > 0 then
				table.insert(AIO_Umbrella.dodgeItReadyTable, { prio = Menu.GetValue(AIO_Umbrella.dodgeItOptionTable[i]), itemname = AIO_Umbrella.dodgeItItems[i][1], itemstyle = AIO_Umbrella.dodgeItItems[i][2], itemtargeting = AIO_Umbrella.dodgeItItems[i][3], itemoffset = AIO_Umbrella.dodgeItItems[i][4] })
			end
		end
	end

	table.sort(AIO_Umbrella.dodgeItReadyTable, function(a, b)
       		return a.prio < b.prio
    	end)

end

function AIO_Umbrella.dodgerRangeOffsetter(myHero, enemy, dodgeSkillName, attackSkillName)

	if not myHero then return end

	if not dodgeSkillName and not attackSkillName then 
		return 
	end

	if dodgeSkillName == "item_blink" then 
		return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(1150)
	end

	local maxRange = 1000
		if dodgeSkillName == "morphling_waveform" then
			maxRange = 990
		elseif dodgeSkillName == "phantom_lancer_doppelwalk" then
			maxRange = 590
		elseif dodgeSkillName == "faceless_void_time_walk" then
			maxRange = 670
		elseif dodgeSkillName == "ember_spirit_sleight_of_fist" then
			maxRange = 690
		end

	local minRange = 190
		if dodgeSkillName == "morphling_waveform" or dodgeSkillName == "faceless_void_time_walk" then
			minRange = maxRange
		end


	if dodgeSkillName ~= "ember_spirit_sleight_of_fist" then
		if attackSkillName == "enigma_black_hole" or attackSkillName == "faceless_void_chronosphere" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(590)
		elseif attackSkillName == "lion_impale" or attackSkillName == "nyx_assassin_impale" or spellname == "pudge_dismember" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(350)
		elseif attackSkillName == "queenofpain_sonic_wave" or attackSkillName == "tidehunter_ravage" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(maxRange)
		else
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(minRange)
		end
	else
		local effectRange = Ability.GetLevel(NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")) * 100 + 150 - 1
		for i = 0, math.ceil(maxRange / effectRange) do
			if #NPCs.InRadius(Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange), effectRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
				return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange + 1)
			end
		end
	end

end

function AIO_Umbrella.dodgerProjectileTimingAdjuster(myHero)

	if not myHero then return end

	if next(AIO_Umbrella.dodgeItTable) == nil then return end

	if os.clock() - AIO_Umbrella.dodgerProjectileAdjustmentTick < 0.05 then return end

	for i, info in pairs(AIO_Umbrella.dodgeItTable) do
		if info.delay > info.castpoint then
			if info.spellname ~= "lion_finger_of_death" and info.spellname ~= "lina_laguna_blade" then
				local originPos = info.originpos
				local myHullSize = NPC.GetHullRadius(myHero)
				local projectileStart = info.casttime + info.castpoint
				local projectileSpeed = info.projectilespeed
				local timeElapsed = math.max((GameRules.GetGameTime() - projectileStart), 0)
				local projectilePos = originPos + (Entity.GetAbsOrigin(myHero) - originPos):Normalized():Scaled(timeElapsed*projectileSpeed)
				local myDisToOrigin = (Entity.GetAbsOrigin(myHero) - originPos):Length2D() - myHullSize
				local projectilDisToOrigin = (projectilePos - originPos):Length2D()
				local myDisToProjectile = (Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() 
				if projectilDisToOrigin < myDisToOrigin then
					if myDisToProjectile > 100 and timeElapsed > 0 then
						local remainingTravelTime = ((Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() - myHullSize) / projectileSpeed
						local adjustedDelay = math.max(info.projectileextradelay, 0.034)
							if info.projectileextradelay < 0 then
								adjustedDelay = info.projectileextradelay
							end
						local processImpactTime = info.castpoint + timeElapsed + remainingTravelTime - adjustedDelay
						if math.abs(info.delay - processImpactTime) > 0.015 then
							if AIO_Umbrella.dodgeItTable[i] ~= nil then
								AIO_Umbrella.dodgeItTable[i]["delay"] = processImpactTime
								AIO_Umbrella.dodgerProjectileAdjustmentTick = os.clock()
							end
						end
					end
				else
					AIO_Umbrella.dodgeItTable[i] = nil
				end
			end
		end
	end			

end

function AIO_Umbrella.dodger(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	if next(AIO_Umbrella.dodgeItTable) == nil then
		for i = 1, Heroes.Count() do
			local enemy = Heroes.Get(i)
			if enemy and Entity.IsHero(enemy) and not Entity.IsSameTeam(myHero, enemy) and not Entity.IsDormant(enemy) and (NPC.GetUnitName(enemy) == "npc_dota_hero_axe" or NPC.GetUnitName(enemy) == "npc_dota_hero_sand_king") and not NPC.IsIllusion(enemy) then
				if Entity.IsAlive(enemy) then
					local axe_call = NPC.GetAbility(enemy, "axe_berserkers_call")
					local call_range = 300
					if axe_call and Ability.IsInAbilityPhase(axe_call) and NPC.IsEntityInRange(myHero, enemy, call_range) then
						AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = 0.4; style = 1; source = enemy, lotus = 0, castpoint = 0.4, spellname = "axe_berserkers_call", global = 0, type = "disable"})
						break
						return
					end
					local burrowStrike = NPC.GetAbility(enemy, "sandking_burrowstrike")
					local burrowRange = 650
					local hitRange = 175
						if NPC.HasItem(enemy, "item_ultimate_scepter", true) or NPC.HasModifier(enemy, "modifier_item_ultimate_scepter_consumed") then
							burrowRange = 1300
						end
					if NPC.HasModifier(enemy, "modifier_sandking_burrowstrike") then
						if AIO_Umbrella.dodgeIsTargetMe(myHero, enemy, hitRange, burrowRange) then
							AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = 0.05; style = 2; source = enemy, lotus = 1, castpoint = 0, spellname = "sandking_burrowstrike", global = 0, type = "disable"})
							break
							return
						else
							if NPC.IsEntityInRange(myHero, enemy, hitRange+burrowRange+885) then
								local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, enemy, hitRange, burrowRange)
								if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
									AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
								end
							end
						end
					end
				end
			end
		end
	end

	if next(AIO_Umbrella.dodgeItTable) == nil then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_alchemist" then
			if NPC.HasModifier(myHero, "modifier_alchemist_unstable_concoction") then
				if Modifier.GetCreationTime(NPC.GetModifier(myHero, "modifier_alchemist_unstable_concoction")) + 5.5 - GameRules.GetGameTime() < 0.15 then
					AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = 0.15; style = 1; source = myHero, lotus = 0, castpoint = 0, spellname = "alchemist_unstable_concoction_throw", global = 0, type = "disable"})
					return
				end
			end
		end
	end

	if next(AIO_Umbrella.dodgeItTable) == nil then return end
	AIO_Umbrella.dodgerProjectileTimingAdjuster(myHero)
	local curTime = GameRules.GetGameTime()

	if not AIO_Umbrella.heroCanCastItems(myHero) then
		return
	end

	if os.clock() - AIO_Umbrella.dodgeTiming < 0.5 then return end

	local dodgeInfo = AIO_Umbrella.dodgeItTable[1]
		local casttime = dodgeInfo.casttime
		local delay = dodgeInfo.delay
		local unit = dodgeInfo.unit
		local castpoint = dodgeInfo.castpoint
		local spellname = dodgeInfo.spellname
		local dodgeobject = dodgeInfo.dodgeobject
		local objecttargeting = dodgeInfo.objecttargeting
		local objectoffset = dodgeInfo.objectoffset

		if curTime > casttime + delay + 0.05 then
			AIO_Umbrella.dodgeItTable = {}
			return
		end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sniper" then
		if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
			if NPC.HasModifier(myHero, "modifier_sniper_assassinate") then
				if objecttargeting == "no target" then
					Ability.CastNoTarget(dodgeobject)
					AIO_Umbrella.dodgeTiming = os.clock()
					AIO_Umbrella.dodgeItTable = {}
					return
				elseif objecttargeting == "position" then
					if AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
						Ability.CastPosition(dodgeobject, AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
						AIO_Umbrella.dodgeTiming = os.clock()
						AIO_Umbrella.dodgeItTable = {}
						return
					end
				elseif objecttargeting == "target" then
					Ability.CastTarget(dodgeobject, myHero)
					AIO_Umbrella.dodgeTiming = os.clock()
					AIO_Umbrella.dodgeItTable = {}
					return
				end
			end
		end
	else	
		if unit and not Entity.IsDormant(unit) then
			if curTime >= casttime + castpoint - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if not Ability.IsInAbilityPhase(NPC.GetAbility(unit, spellname)) and castpoint > 0 then
					if delay > castpoint then
						if Ability.SecondsSinceLastUse(NPC.GetAbility(unit, spellname)) == -1 and spellname ~= "alchemist_unstable_concoction_throw" then
							AIO_Umbrella.dodgeItTable = {}
							return
						else
							if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then

								if objecttargeting == "no target" then
									Ability.CastNoTarget(dodgeobject)
									AIO_Umbrella.dodgeTiming = os.clock()
									AIO_Umbrella.dodgeItTable = {}
									return
								elseif objecttargeting == "position" then
									if AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
										Ability.CastPosition(dodgeobject, AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
										AIO_Umbrella.dodgeTiming = os.clock()
										AIO_Umbrella.dodgeItTable = {}
										return
									end
								elseif objecttargeting == "target" then
									Ability.CastTarget(dodgeobject, myHero)
									AIO_Umbrella.dodgeTiming = os.clock()
									AIO_Umbrella.dodgeItTable = {}
									return
								end
							end
						end
					else
						AIO_Umbrella.dodgeItTable = {}
						return
					end
				else
					if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						if objecttargeting == "no target" then
							Ability.CastNoTarget(dodgeobject)
							AIO_Umbrella.dodgeTiming = os.clock()
							AIO_Umbrella.dodgeItTable = {}
							return
						elseif objecttargeting == "position" then
							if AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
								Ability.CastPosition(dodgeobject, AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
								AIO_Umbrella.dodgeTiming = os.clock()
								AIO_Umbrella.dodgeItTable = {}
								return
							end
						elseif objecttargeting == "target" then
							Ability.CastTarget(dodgeobject, myHero)
							AIO_Umbrella.dodgeTiming = os.clock()
							AIO_Umbrella.dodgeItTable = {}
							return
						end
					end
				end
			end
		else
			if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if objecttargeting == "no target" then
					Ability.CastNoTarget(dodgeobject)
					AIO_Umbrella.dodgeTiming = os.clock()
					AIO_Umbrella.dodgeItTable = {}
					return
				elseif objecttargeting == "position" then
					if AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
						Ability.CastPosition(dodgeobject, AIO_Umbrella.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
						AIO_Umbrella.dodgeTiming = os.clock()
						AIO_Umbrella.dodgeItTable = {}
						return
					end
				elseif objecttargeting == "target" then
					Ability.CastTarget(dodgeobject, myHero)
					AIO_Umbrella.dodgeTiming = os.clock()
					AIO_Umbrella.dodgeItTable = {}
					return
				end
			end
		end
	end

end

function AIO_Umbrella.dodgeProcessing(myHero, unit, activity, castpoint)

	if not myHero then return end
	if Entity.IsSameTeam(myHero, unit) then return end

	local distance = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(unit)):Length2D() - 25

	if NPC.GetUnitName(unit) == "npc_dota_hero_antimage" then
		local radius = 500
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "antimage_mana_void", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end



	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_alchemist" then
		local radius = 0
		local castrange = 775
		local impactTime = distance / 900
		if activity == Enum.GameActivity.ACT_DOTA_ALCHEMIST_CONCOCTION_THROW then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "alchemist_unstable_concoction_throw", global = 0, type = "disable", projectilespeed = 900, projectileextradelay = -0.001})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end		
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_bane" then
		local radius = 0
		local castrange = 800
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "bane_fiends_grip", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end		
	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_batrider" then
		local radius = 0
		local castrange = 200
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "batrider_flaming_lasso", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end	

--	if NPC.GetUnitName(unit) == "npc_dota_hero_beastmaster" then
--		local radius = 
--		local castrange = 
--		if sequenceName == "cast4_primal_roar_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_bloodseeker" then
		local radius = 0
		local castrange = 1000
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "bloodseeker_rupture", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_centaur" then
		local radius = 315
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "centaur_hoof_stomp", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, 0)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_chaos_knight" then
		local radius = 0
		local castrange = 500
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "chaos_knight_chaos_bolt", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end	
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_crystal_maiden" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "crystal_maiden_frostbite", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_death_prophet" then
		local radius = 425
		local castrange = 1000
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, 425, 1000) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "death_prophet_silence", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_doom_bringer" then
		local radius = 0
		local castrange = 550
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_6 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "doom_bringer_doom", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_drow_ranger" then
		local radius = 900
		local castrange = 250
		local impactTime = distance / 2000 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "drow_ranger_wave_of_silence", global = 0, type = "disable", projectilespeed = 2000, projectileextradelay = 0.080})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_earthshaker" then
		local radius1 = 225
		local castrange = 1400
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius1, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "earthshaker_fissure", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius1, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end

		local radius2 = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius2) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "earthshaker_enchant_totem", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius2, 0)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_enigma" then
		local radius = 420
		local castrange = 275
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "enigma_black_hole", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_faceless_void" then
		local radius = 425
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "faceless_void_chronosphere", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_juggernaut" then
		local radius = 425
		local castrange = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "juggernaut_omni_slash", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_legion_commander" then
		local radius = 0
		local castrange = 300
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "legion_commander_duel", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lich" then
		local radius = 0
		local castrange = 1000
		local impactTime = distance / 850
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lich_chain_frost", global = 0, type = "nuke", projectilespeed = 850, projectileextradelay = 0})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lina" then
		local radius = 0
		local castrange = 725
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + 0.275; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lina_laguna_blade", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lion" then
		local radius1 = 125
		local castrange1 = 725
		local impactTime = distance / 1600 - 0.2
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange1) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius1, castrange1) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "lion_impale", global = 0, type = "disable", projectilespeed = 1600, projectileextradelay = 0.2})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange1+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius1, castrange1)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end

		local radius2 = 0
		local castrange2 = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius2+castrange2) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius2, castrange2) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + 0.275; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lion_finger_of_death", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+castrange2+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius2, castrange2)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_luna" then
		local radius = 0
		local castrange = 800
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "luna_lucent_beam", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_magnataur" then
		local radius = 0
		local castrange = 460
		local instant_radius = 150 + 50
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				local delay = castpoint
					if distance <= instant_radius then delay = 0 end
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "magnataur_reverse_polarity", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end	
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_necrolyte" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "necrolyte_reapers_scythe", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_night_stalker" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+0.075; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "night_stalker_crippling_fear", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_nyx_assassin" then
		local radius = 125
		local castrange = 700
		local impactTime = distance / 1600 + 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "nyx_assassin_impale", global = 0, type = "disable", projectilespeed = 1600, projectileextradelay = -0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_ogre_magi" then
		local radius = 0
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "ogre_magi_fireblast", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_obsidian_destroyer" then
		local radius1 = 0
		local castrange1 = 450
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange1) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius1, castrange1) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "obsidian_destroyer_astral_imprisonment", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange1+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius1, castrange1)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end

		local radius2 = 575
		local castrange2 = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius2+castrange2) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius2, castrange2) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "obsidian_destroyer_sanity_eclipse", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+castrange2+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius2, castrange2)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_puck" then
		local radius = 450
		local castrange = 0
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "puck_waning_rift", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_pudge" then
		local radius = 0
		local castrange = 250
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "pudge_dismember", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_queenofpain" then
		local radius = 450
		local castrange = 900
		local impactTime = distance / 900 - 0.25
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "queenofpain_sonic_wave", global = 0, type = "nuke", projectilespeed = 900, projectileextradelay = 0.25})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_rubick" then
		local radius = 0
		local castrange = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "rubick_telekinesis", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_shadow_demon" then
		local radius = 0
		local castrange = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "shadow_demon_disruption", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_shadow_shaman" then
		local radius = 0
		local castrange = 500
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_3 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "shadow_shaman_shackles", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_silencer" then
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "silencer_global_silence", global = 1, type = "disable"})
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_skywrath_mage" then
		local radius = 0
		local castrange = 750
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_3 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "skywrath_mage_ancient_seal", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_slardar" then
		local radius = 350
		local castrange = 0
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "slardar_slithereen_crush", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sniper" then
		local radius = 0
		local castrange = 3000
		local impactTime = distance / 2500 - 0.05
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then	
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "sniper_assassinate", global = 0, type = "nuke", projectilespeed = 2500, projectileextradelay = 0.05})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end
		

--	if NPC.GetUnitName(unit) == "npc_dota_hero_spirit_breaker" then
--		local radius = 0
--		local castrange = 850
--	--	if sequenceName == "ultimate_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "spirit_breaker_nether_strike", global = 0, type = "nuke"})
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_storm_spirit" then
		local radius = 0
		local castrange = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "storm_spirit_electric_vortex", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sven" then
		local radius = 0
		local castrange = 600
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "sven_storm_bolt", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_techies" then
--		local radius = 
--		local castrange = 
--		if sequenceName == "cast_blast_off" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_terrorblade" then
		local radius = 0
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "terrorblade_sunder", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_tidehunter" then
		local radius = 0
		local castrange = 1100
		local impactTime = distance / 775 - 0.35
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				local adjust = impactTime
					if distance <= 250 then adjust = 0 end
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + adjust; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "tidehunter_ravage", global = 0, type = "disable", projectilespeed = 775, projectileextradelay = 0.35})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_tinker" then
		local radius = 0
		local castrange = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+0.1; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "tinker_laser", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_treant" then
--		local radius = 0
--		local castrange = 850
--		if sequenceName == "cast5_Overgrowth_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_vengefulspirit" then
		local radius = 0
		local castrange = 500
		local impactTime = distance / 1250 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "vengefulspirit_magic_missile", global = 0, type = "disable", projectilespeed = 1250, projectileextradelay = 0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_warlock" then
		local radius = 600
		local castrange = 1200
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+0.5; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "warlock_rain_of_chaos", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_windrunner" then
		local radius = 0
		local castrange = 800
		local impactTime = distance / 1650 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "windrunner_shackleshot", global = 0, type = "disable", projectilespeed = 1650, projectileextradelay = 0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_winter_wyvern" then
--		local radius = 500
--		local castrange = 800
--		if sequenceName == "cast04_winters_curse_flying_low_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_skeleton_king" then
		local radius = 0
		local castrange = 525
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "skeleton_king_hellfire_blast", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = AIO_Umbrella.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						AIO_Umbrella.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_zuus" then
		local radius = 375
		local castrange = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
			if AIO_Umbrella.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "zuus_lightning_bolt", global = 0, type = "nuke"})
			end
		end

		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_5 then
			if AIO_Umbrella.IsHeroInvisible(myHero) == false and not NPC.HasModifier(myHero, "modifier_smoke_of_deceit") then
				AIO_Umbrella.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "zuus_thundergods_wrath", global = 1, type = "nuke"})
			end
		end
	end

end

-- ward awareness
function AIO_Umbrella.wardProcessing(myHero)

	if not myHero then return end

	if os.clock() - AIO_Umbrella.wardCaptureTiming < 0.5 then return end

	for i = 1, Heroes.Count() do
		local heroes = Heroes.Get(i)
		if heroes and Entity.IsHero(heroes) and Entity.IsAlive(heroes) and not Entity.IsDormant(heroes) and not Entity.IsSameTeam(myHero, heroes) and not NPC.IsIllusion(heroes) then
			local sentry = NPC.GetItem(heroes, "item_ward_sentry", true)
			local observer = NPC.GetItem(heroes, "item_ward_observer", true)
			local dispenser = NPC.GetItem(heroes, "item_ward_dispenser", true)
			local sentryStack = 0
			local observerStack = 0
			local ownerID = Entity.GetIndex(heroes)
			if sentry then
				sentryStack = Item.GetCurrentCharges(sentry)
			elseif observer then
				observerStack = Item.GetCurrentCharges(observer)
			elseif dispenser then
				sentryStack = Item.GetSecondaryCharges(dispenser)
				observerStack = Item.GetCurrentCharges(dispenser)
			end

			if sentryStack == 0 and observerStack == 0 then
				if AIO_Umbrella.wardDispenserCount[ownerID] == nil then
					AIO_Umbrella.wardDispenserCount[ownerID] = nil
					AIO_Umbrella.wardCaptureTiming = os.clock()
				else
					if AIO_Umbrella.wardDispenserCount[ownerID]["sentry"] > sentryStack then
						AIO_Umbrella.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "sentry", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 240)}
						AIO_Umbrella.wardDispenserCount[ownerID] = nil
						AIO_Umbrella.wardCaptureTiming = os.clock()
					elseif AIO_Umbrella.wardDispenserCount[ownerID]["observer"] > sentryStack then
						AIO_Umbrella.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "observer", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
						AIO_Umbrella.wardDispenserCount[ownerID] = nil
						AIO_Umbrella.wardCaptureTiming = os.clock()
					end
				end
			end
						
			if AIO_Umbrella.wardDispenserCount[ownerID] == nil then
				if sentryStack > 0 or observerStack > 0 then
					AIO_Umbrella.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					AIO_Umbrella.wardCaptureTiming = os.clock()
				end
			else
				if AIO_Umbrella.wardDispenserCount[ownerID]["sentry"] < sentryStack then
					AIO_Umbrella.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					AIO_Umbrella.wardCaptureTiming = os.clock()
				elseif AIO_Umbrella.wardDispenserCount[ownerID]["observer"] < observerStack then
					AIO_Umbrella.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					AIO_Umbrella.wardCaptureTiming = os.clock()
				elseif AIO_Umbrella.wardDispenserCount[ownerID]["sentry"] > sentryStack then
					AIO_Umbrella.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "sentry", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 240)}
					AIO_Umbrella.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					AIO_Umbrella.wardCaptureTiming = os.clock()
				elseif AIO_Umbrella.wardDispenserCount[ownerID]["observer"] > observerStack then
					AIO_Umbrella.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "observer", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
					AIO_Umbrella.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					AIO_Umbrella.wardCaptureTiming = os.clock()
				end
			end
		elseif heroes and Entity.IsHero(heroes) and Entity.IsDormant(heroes) then
			local ownerID = Entity.GetIndex(heroes)
			AIO_Umbrella.wardDispenserCount[ownerID] = nil
			AIO_Umbrella.wardCaptureTiming = os.clock()
		end
	end

	for k, l in pairs(AIO_Umbrella.wardProcessingTable) do
		if l then
			if GameRules.GetGameTime() > l.dieTime then
				AIO_Umbrella.wardProcessingTable[k] = nil
			end	
		end
	end

end

function AIO_Umbrella.drawWard(myHero)

	if not myHero then return end

	if next(AIO_Umbrella.wardProcessingTable) == nil then return end

	local sentryImageHandle = AIO_Umbrella.sentryImageHandle
		if sentryImageHandle == nil then
			sentryImageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. "ward_sentry" .. ".png")
			AIO_Umbrella.sentryImageHandle = sentryImageHandle
		end
	local obsImageHandle = AIO_Umbrella.obsImageHandle
		if obsImageHandle == nil then
			obsImageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. "ward_observer" .. ".png")
			AIO_Umbrella.obsImageHandle = obsImageHandle
		end

	for i, v in pairs(AIO_Umbrella.wardProcessingTable) do
		if v then
			local type = v.type
			local pos = v.pos
			local dieTime = v.dieTime
			if dieTime > GameRules.GetGameTime() then
				local x, y, visible = Renderer.WorldToScreen(pos)
				local hoveringOver = Input.IsCursorInRect(x, y, 30, 30)
				if visible then
					if type == "sentry" then
						Renderer.SetDrawColor(255, 255, 255, 255)
						Renderer.DrawImage(sentryImageHandle, x, y, 30, 30)
						Renderer.DrawText(AIO_Umbrella.font, x, y+30, math.floor(dieTime - GameRules.GetGameTime()), 0)
					elseif type == "observer" then
						Renderer.SetDrawColor(255, 255, 255, 255)
						Renderer.DrawImage(obsImageHandle, x, y, 30, 30)
						Renderer.DrawText(AIO_Umbrella.font, x, y+30, math.floor(dieTime - GameRules.GetGameTime()), 0)
					end
					if Menu.IsEnabled(AIO_Umbrella.optionWardAwarenessClickRemove) and (os.clock() - AIO_Umbrella.wardDrawingRemove) >= 0.25 then
						if hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
							AIO_Umbrella.wardDrawingRemove = os.clock()
						end
					else
						if hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
							AIO_Umbrella.wardProcessingTable[i] = nil
						end
					end
				end
			end
		end
	end

end

-- item usage functions
function AIO_Umbrella.itemUsage(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionItemEnable) then return end
	if (os.clock() - AIO_Umbrella.lastItemTick) < AIO_Umbrella.itemDelay then return end
	if AIO_Umbrella.ItemCastStop then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Menu.GetValue(AIO_Umbrella.optionItemStyle) == 0 then 
		AIO_Umbrella.itemUsageNoOrder(myHero, enemy)
	elseif Menu.GetValue(AIO_Umbrella.optionItemStyle) == 1 then
		AIO_Umbrella.itemUsageOrder(myHero, enemy)
	elseif Menu.GetValue(AIO_Umbrella.optionItemStyle) == 2 then
		AIO_Umbrella.itemUsageSmartOrder(myHero, enemy)
	end

end

function AIO_Umbrella.itemUsageNoOrder(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local hex = NPC.GetItem(myHero, "item_sheepstick", true)
	local blood = NPC.GetItem(myHero, "item_bloodthorn", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local orchid = NPC.GetItem(myHero, "item_orchid", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)
	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)
	local abyssal = NPC.GetItem(myHero, "item_abyssal_blade", true)
	local halberd = NPC.GetItem(myHero, "item_heavens_halberd", true)
	local shivas = NPC.GetItem(myHero, "item_shivas_guard", true)
	local urn = NPC.GetItem(myHero, "item_urn_of_shadows", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local medallion = NPC.GetItem(myHero, "item_medallion_of_courage", true)
	local crest = NPC.GetItem(myHero, "item_solar_crest", true)
	local spiritVessel = NPC.GetItem(myHero, "item_spirit_vessel", true)
	local nullifier = NPC.GetItem(myHero, "item_nullifier", true)
	local diffusal = NPC.GetItem(myHero, "item_diffusal_blade", true)

	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
		
		if AIO_Umbrella.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(AIO_Umbrella.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if AIO_Umbrella.ItemSleepReady(0.05) and AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end
		end

		if AIO_Umbrella.ItemSleepReady(0.05) and abyssal and NPC.IsEntityInRange(myHero, enemy, 140) and Ability.IsCastable(abyssal, myMana) and Menu.GetValue(AIO_Umbrella.optionItemAbyssal) > 0 then 
			Ability.CastTarget(abyssal, enemy)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if AIO_Umbrella.ItemSleepReady(0.05) and shivas and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(shivas, myMana) and Menu.GetValue(AIO_Umbrella.optionItemShivas) > 0 then 
			Ability.CastNoTarget(shivas)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if AIO_Umbrella.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(AIO_Umbrella.optionItemMjollnir) > 0 then 
			Ability.CastTarget(mjollnir, myHero)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if AIO_Umbrella.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(AIO_Umbrella.optionItemManta) > 0 then 
			Ability.CastNoTarget(manta)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then

			if AIO_Umbrella.ItemSleepReady(0.05) and orchid and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(orchid, myMana) and Menu.GetValue(AIO_Umbrella.optionItemOrchid) > 0 then 
				Ability.CastTarget(orchid, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and blood and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(blood, myMana) and Menu.GetValue(AIO_Umbrella.optionItemBlood) > 0 then 
				Ability.CastTarget(blood, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and veil and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(veil, myMana) and Menu.GetValue(AIO_Umbrella.optionItemVeil) > 0 then 
				Ability.CastPosition(veil, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and hex and NPC.IsEntityInRange(myHero, enemy, 800 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(hex, myMana) and Menu.GetValue(AIO_Umbrella.optionItemHex) > 0 then 
				Ability.CastTarget(hex, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and nullifier and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(nullifier, myMana) and Menu.GetValue(AIO_Umbrella.optionItemNull) > 0 then 
				Ability.CastTarget(nullifier, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and diffusal and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(diffusal, myMana) and Menu.GetValue(AIO_Umbrella.optionItemDiffusal) > 0 then 
				Ability.CastTarget(diffusal, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and eBlade and NPC.IsEntityInRange(myHero, enemy, 800 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(eBlade, myMana) and Menu.GetValue(AIO_Umbrella.optionItemeBlade) > 0 then 
				Ability.CastTarget(eBlade, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end
	
			if AIO_Umbrella.ItemSleepReady(0.05) and atos and NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(atos, myMana) and Menu.GetValue(AIO_Umbrella.optionItemAtos) > 0 then 
				Ability.CastTarget(atos, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and halberd and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(halberd, myMana) and Menu.GetValue(AIO_Umbrella.optionItemHalberd) > 0 then
				Ability.CastTarget(halberd, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and urn and NPC.IsEntityInRange(myHero, enemy, 950 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(urn, myMana) and Item.GetCurrentCharges(urn) >= 3 and Entity.GetHealth(enemy) >= 250 and Menu.GetValue(AIO_Umbrella.optionItemUrn) > 0 then
				Ability.CastTarget(urn, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and spiritVessel and NPC.IsEntityInRange(myHero, enemy, 950 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(spiritVessel, myMana) and Item.GetCurrentCharges(spiritVessel) >= 2 and Entity.GetHealth(enemy) >= 250 and Menu.GetValue(AIO_Umbrella.optionItemSpirit) > 0 then
				Ability.CastTarget(spiritVessel, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and medallion and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(medallion, myMana) and Menu.GetValue(AIO_Umbrella.optionItemMedallion) > 0 then 
				Ability.CastTarget(medallion, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and crest and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(crest, myMana) and Menu.GetValue(AIO_Umbrella.optionItemCrest) > 0 then 
				Ability.CastTarget(crest, enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end

			if AIO_Umbrella.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) and Menu.GetValue(AIO_Umbrella.optionItemDagon) > 0 and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if eBlade then
					if Ability.SecondsSinceLastUse(eBlade) > -1 and Ability.SecondsSinceLastUse(eBlade) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
						return
					else
						Ability.CastTarget(dagon, enemy)
						AIO_Umbrella.lastItemCast = os.clock()
						return
					end
				else
					if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
						if Ability.IsReady(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								AIO_Umbrella.lastItemCast = os.clock()
								return
							end
						end
					elseif NPC.HasAbility(myHero, "witch_doctor_maledict") then
						if Ability.IsReady(NPC.GetAbility(myHero, "witch_doctor_maledict")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								AIO_Umbrella.lastItemCast = os.clock()
								return
							end
						end
					elseif NPC.HasAbility(myHero, "pugna_decrepify") then
						if Ability.IsReady(NPC.GetAbility(myHero, "pugna_decrepify")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								AIO_Umbrella.lastItemCast = os.clock()
								return
							end
						end
					else
						Ability.CastTarget(dagon, enemy)
						AIO_Umbrella.lastItemCast = os.clock()
						return
					end
				end
			end

			if Menu.GetValue(AIO_Umbrella.optionItemDagon) == -1 then

				if AIO_Umbrella.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
					local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
					local eBladeAMP = 0
						if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
							eBladeAMP = 0.4
						end
					local necroUltDMG = 0
						if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
							if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
								local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
								necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
							end
						end
					local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
					if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
						if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
							Ability.CastTarget(dagon, enemy)
							AIO_Umbrella.lastItemCast = os.clock()
							return
						end
					end
				end
			end
		end
	end
end

function AIO_Umbrella.itemUsageOrder(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
		
		if AIO_Umbrella.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(AIO_Umbrella.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if AIO_Umbrella.ItemSleepReady(0.05) and AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end
		end

		if Menu.GetValue(AIO_Umbrella.optionItemDagon) == -1 then

			if AIO_Umbrella.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
				local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
				local eBladeAMP = 0
					if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
						eBladeAMP = 0.4
					end
				local necroUltDMG = 0
					if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
						if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
							local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
							necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
						end
					end
				local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
				if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
					if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						Ability.CastTarget(dagon, enemy)
						AIO_Umbrella.lastItemCast = os.clock()
						return
					end
				end
			end
		end

		local orderItem
		local customOrder = 0
		local itemActivation

		for k, v in ipairs(AIO_Umbrella.ItemCastOrder) do

			local skipItem = 0

			if NPC.HasModifier(enemy, "modifier_black_king_bar_immune") then
				if v[2] == "item_veil_of_discord" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or
					v[2] == "item_ethereal_blade" or v[2] == "item_orchid" or v[2] == "item_rod_of_atos" or
					v[2] == "item_heavens_halberd" or v[2] == "item_urn_of_shadows" or v[2] == "item_dagon"
					or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" or v[2] == "item_medallion_of_courage" or v[2] == "item_solar_crest"
					or v[2] == "item_spirit_vessel" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if v[2] ~= "item_nullifier" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_ethereal_blade") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
				if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" then
					skipItem = v[1]
				end
			end

			if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "witch_doctor_maledict") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "pugna_decrepify") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if v[2] == "item_spirit_vessel" or v[2] == "item_urn_of_shadows" then
					if Item.GetCurrentCharges(NPC.GetItem(myHero, v[2], true)) <= 2 then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and (v[1] - skipItem) > customOrder then
					orderItem = NPC.GetItem(myHero, v[2], true)
					customOrder = v[1]
					itemActivation = v[3]
				end
			end	
		end
		
			if AIO_Umbrella.ItemSleepReady(0.05) and customOrder > 0 then
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(orderItem)) then
					if itemActivation == "target" then
						Ability.CastTarget(orderItem, enemy)
						AIO_Umbrella.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "no target" then
						Ability.CastNoTarget(orderItem)
						AIO_Umbrella.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "position" then
						Ability.CastPosition(orderItem, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastItemCast = os.clock()
						customOrder = 0
						return
					end
				end
			end

		if AIO_Umbrella.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(AIO_Umbrella.optionItemMjollnir) > 0 then
			Ability.CastTarget(mjollnir, myHero)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if AIO_Umbrella.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(AIO_Umbrella.optionItemManta) > 0 then
			Ability.CastNoTarget(manta)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end
	end
end

function AIO_Umbrella.itemUsageSmartOrder(myHero, enemy, activation)

	if not myHero then return end
	if not enemy then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local alternateActivation
	if activation == nil then
		alternateActivation = false
	else alternateActivation = activation
	end
	
	local myMana = NPC.GetMana(myHero)

	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if (Menu.IsKeyDown(AIO_Umbrella.optionComboKey) or alternateActivation) then
		
		if AIO_Umbrella.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(AIO_Umbrella.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if AIO_Umbrella.ItemSleepReady(0.05) and AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), enemy)
				AIO_Umbrella.lastItemCast = os.clock()
				return
			end
		end

		if Menu.GetValue(AIO_Umbrella.optionItemDagon) == -1 then

			if AIO_Umbrella.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
				local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
				local eBladeAMP = 0
					if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
						eBladeAMP = 0.4
					end
				local necroUltDMG = 0
					if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
						if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
							local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
							necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
						end
					end
				local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
				if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
					if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						Ability.CastTarget(dagon, enemy)
						AIO_Umbrella.lastItemCast = os.clock()
						return
					end
				end
			end
		end

		local orderItem
		local customOrder = 0
		local itemActivation

		for k, v in ipairs(AIO_Umbrella.ItemCastOrder) do

			local skipItem = 0

			if NPC.HasModifier(enemy, "modifier_black_king_bar_immune") then
				if v[2] == "item_veil_of_discord" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or
					v[2] == "item_ethereal_blade" or v[2] == "item_orchid" or v[2] == "item_rod_of_atos" or
					v[2] == "item_heavens_halberd" or v[2] == "item_urn_of_shadows" or v[2] == "item_dagon"
					or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" or v[2] == "item_medallion_of_courage" or v[2] == "item_solar_crest"
					or v[2] == "item_spirit_vessel" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if v[2] ~= "item_nullifier" then
					skipItem = v[1]
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if v[2] == "item_spirit_vessel" or v[2] == "item_urn_of_shadows" then
					if Item.GetCurrentCharges(NPC.GetItem(myHero, v[2], true)) <= 2 then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_bashed") then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_stunned") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_stunned"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_sheepstick_debuff"))
				if Menu.IsEnabled(AIO_Umbrella.optionItemStack) then
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
							skipItem = v[1]
						end
					end
				else
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
							skipItem = v[1]
						end
					end
				end
			end

			if NPC.HasItem(myHero, "item_sheepstick", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) < 0.5 then
				if Menu.IsEnabled(AIO_Umbrella.optionItemStack) then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				else
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.IsSilenced(enemy) then
				if NPC.HasModifier(enemy, "modifier_bloodthorn_debuff") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_bloodthorn_debuff"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				elseif NPC.HasModifier(enemy, "modifier_orchid_malevolence_debuff") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_orchid_malevolence_debuff"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				elseif NPC.HasModifier(enemy, "modifier_silence") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_silence"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_nullifier") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1200) + 0.25 then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_nullifier_mute") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_nullifier_mute"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if  v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_diffusal_blade_slow") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_diffusal_blade_slow"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, "item_diffusal_blade", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) < 0.5 then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_ethereal_blade") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
				if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_veil_of_discord_debuff") then
				if v[2] == "item_veil_of_discord" then
					skipItem = v[1]
				end
			end		

			if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "witch_doctor_maledict") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "pugna_decrepify") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(enemy, "item_aeon_disk", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) < 0 then
					if Entity.GetHealth(enemy) >= 0.85 * Entity.GetMaxHealth(enemy) then
						if v[2] == "item_nullifier" then
							skipItem = v[1]
						end
					end
				end
				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) <= 2.55 then
					if not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						if v[2] == "item_nullifier" then
							skipItem = v[1]
						end
					end
				end
			end

			if AIO_Umbrella.myUnitName == "npc_dota_hero_tinker" then
				if NPC.IsLinkensProtected(enemy) then
					if v[2] == "item_sheepstick" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_pudge_meat_hook") then
				if v[2] == "item_rod_of_atos" then
					skipItem = v[1]
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and (v[1] - skipItem) > customOrder then
					orderItem = NPC.GetItem(myHero, v[2], true)
					customOrder = v[1]
					itemActivation = v[3]
				end
			end	
		end
		
			if AIO_Umbrella.ItemSleepReady(0.05) and customOrder > 0 then
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(orderItem)) then
					if itemActivation == "target" then
						Ability.CastTarget(orderItem, enemy)
						AIO_Umbrella.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "no target" then
						Ability.CastNoTarget(orderItem)
						AIO_Umbrella.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "position" then
						Ability.CastPosition(orderItem, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastItemCast = os.clock()
						customOrder = 0
						return
					end
				end
			end

		if AIO_Umbrella.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(AIO_Umbrella.optionItemMjollnir) > 0 then
			Ability.CastTarget(mjollnir, myHero)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end

		if AIO_Umbrella.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(AIO_Umbrella.optionItemManta) > 0 then
			Ability.CastNoTarget(manta)
			AIO_Umbrella.lastItemCast = os.clock()
			return
		end
	end
end

-- hurricane
function AIO_Umbrella.ItemAutoHurricaneUsage(myHero, enemy)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local orbSkill = nil
	local orbSkillTable = {
		npc_dota_hero_clinkz = "clinkz_searing_arrows",
		npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
		npc_dota_hero_enchantress = "enchantress_impetus",
		npc_dota_hero_huskar = "huskar_burning_spear",
		npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
		npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
		npc_dota_hero_viper = "viper_poison_attack",
		npc_dota_hero_skywrath_mage = "skywrath_mage_arcane_bolt"
			}

		if orbSkillTable[AIO_Umbrella.myUnitName] ~= nil then
			orbSkill = NPC.GetAbility(myHero, orbSkillTable[AIO_Umbrella.myUnitName])
		end

		if orbSkill and Ability.GetLevel(orbSkill) < 1 then
			orbSkill = nil
		end

		if orbSkill then
			if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then
				if Ability.GetAutoCastState(orbSkill) == false and os.clock() - AIO_Umbrella.lastTick > 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO, nil, Vector(), orbSkill, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end


	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)
		if not hurricanePike then return end
		if not Ability.IsCastable(hurricanePike, myMana) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_item_blade_mail_reflect") then return end
	if NPC.HasItem(myHero, "item_blade_mail", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) < 0.25 then return end

	if os.clock() - AIO_Umbrella.lastDefItemPop < 0.25 then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(AIO_Umbrella.optionItemHurricaneHP) then
		for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 400, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.IsAttacking(v) then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.FindFacingNPC(v) == myHero then
							if enemy then
								if NPC.IsEntityInRange(myHero, enemy, 400) then
									Ability.CastTarget(hurricanePike, enemy)
									AIO_Umbrella.lastDefItemPop = os.clock()
									break
									return
								else
									if NPC.IsEntityInRange(myHero, v, 400) then
										Ability.CastTarget(hurricanePike, v)
										AIO_Umbrella.lastDefItemPop = os.clock()
										break
										return
									end
								end
							else
								if NPC.IsEntityInRange(myHero, v, 400) then
									Ability.CastTarget(hurricanePike, v)
									AIO_Umbrella.lastDefItemPop = os.clock()
									break
									return
								end
							end	
						end
					end
				end
				for ability, info in pairs(AIO_Umbrella.RawDamageAbilityEstimation) do
					if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
						local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
						local abilityRadius = info[3]
						if AIO_Umbrella.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							if next(AIO_Umbrella.dodgeItTable) == nil then
								if enemy then
									if NPC.IsEntityInRange(myHero, enemy, 400) then
										Ability.CastTarget(hurricanePike, enemy)
										AIO_Umbrella.lastDefItemPop = os.clock()
										break
										return
									end
								else
									if NPC.IsEntityInRange(myHero, v, 400) then
										Ability.CastTarget(hurricanePike, v)
										AIO_Umbrella.lastDefItemPop = os.clock()
										break
										return
									end
								end
							end
						end
					end
				end
			end	
		end
	end

end

-- blade mail
function AIO_Umbrella.ItemAutoBMUsage(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local bladeMail = NPC.GetItem(myHero, "item_blade_mail", true)
		if not bladeMail then return end
		if not Ability.IsCastable(bladeMail, myMana) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then return end
	if NPC.HasItem(myHero, "item_hurricane_pike", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) < 0.25 then return end

	if os.clock() - AIO_Umbrella.lastDefItemPop < 0.25 then return end

	for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			if NPC.IsAttacking(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
					if NPC.FindFacingNPC(v) == myHero then
						Ability.CastNoTarget(bladeMail)
						AIO_Umbrella.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
			for ability, info in pairs(AIO_Umbrella.RawDamageAbilityEstimation) do
				if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
					local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
					local abilityRadius = info[3]
					if AIO_Umbrella.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
						if next(AIO_Umbrella.dodgeItTable) == nil then
							Ability.CastNoTarget(bladeMail)
							AIO_Umbrella.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end	
	end
	return
	
end


-- armlet
function AIO_Umbrella.getAbilityDamageInstances(myHero)

	if not myHero then return end

	for i, v in ipairs(Entity.GetHeroesInRadius(myHero, 2000, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsNPC(v) and Entity.IsHero(v) and not Entity.IsDormant(v) then
			for ability, info in pairs(AIO_Umbrella.RawDamageAbilityEstimation) do
				if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
					local abilityStyle = info[1]
					local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
					local abilityRadius = info[3]
					local abilityDamage = math.max(Ability.GetDamage(NPC.GetAbility(v, ability)), Ability.GetLevel(NPC.GetAbility(v, ability)) * info[4] * 1.1)
					local abilityDelay = Ability.GetCastPoint(NPC.GetAbility(v, ability)) + info[6]
					local projectileInfo = info[5]
					local curTime = AIO_Umbrella.utilityRoundNumber(GameRules.GetGameTime(), 3)
					if projectileInfo < 1 then
						if AIO_Umbrella.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							if #AIO_Umbrella.armletDamageInstanceTable < 1 then
								table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = ability, time = AIO_Umbrella.utilityRoundNumber(curTime + abilityDelay, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, isProjectile = false })
							else
								local inserted = false
								for k, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
									if info.instanceindex == ability then
										inserted = true
									end
								end
								if not inserted then
									table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = ability, time = AIO_Umbrella.utilityRoundNumber(curTime + abilityDelay, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, isProjectile = false })
								end
							end
						end
					else
						if AIO_Umbrella.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							local myProjectedPosition = Entity.GetAbsOrigin(myHero)
							local projectileTiming = ((Entity.GetAbsOrigin(v) - myProjectedPosition):Length2D() - NPC.GetHullRadius(myHero)) / projectileInfo
								if ability == "beastmaster_wild_axes" then
									projectileTiming = math.min(projectileTiming, 1)
								end
							if #AIO_Umbrella.armletDamageInstanceTable < 1 then
								table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = ability, time = AIO_Umbrella.utilityRoundNumber(curTime + abilityDelay + projectileTiming - 0.035, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, projectileorigin = Entity.GetAbsOrigin(v), projectilestarttime = GameRules.GetGameTime() + abilityDelay - 0.035, projectilespeed = projectileInfo, isProjectile = true })
							else
								local inserted = false
								for k, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
									if info.instanceindex == ability then
										inserted = true
									end
								end
								if not inserted then
									table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = ability, time = AIO_Umbrella.utilityRoundNumber(curTime + abilityDelay + projectileTiming - 0.035, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, projectileorigin = Entity.GetAbsOrigin(v), projectilestarttime = GameRules.GetGameTime() + abilityDelay - 0.035, projectilespeed = projectileInfo, isProjectile = true })
								end
							end
						end
					end
				end
			end
		end
	end

	return

end

function AIO_Umbrella.armletProcessInstanceTable(myHero)

	if not myHero then
		AIO_Umbrella.armletDamageInstanceTable = {}
		return
	end

	if #AIO_Umbrella.armletDamageInstanceTable < 1 then return end
	if #AIO_Umbrella.armletDamageInstanceTable > 1 then
		table.sort(AIO_Umbrella.armletDamageInstanceTable, function(a, b)
       			return a.time < b.time
    		end)
	end

	for i, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
		if info then	
			if info.isProjectile == true then
				local originPos = info.projectileorigin
				local myHullSize = NPC.GetHullRadius(myHero)
				local projectileStart = info.projectilestarttime
				local projectileSpeed = info.projectilespeed
				local timeElapsed = math.max((GameRules.GetGameTime() - projectileStart), 0)
				local projectilePos = originPos + (Entity.GetAbsOrigin(myHero) - originPos):Normalized():Scaled(timeElapsed*projectileSpeed)
				local myDisToOrigin = (Entity.GetAbsOrigin(myHero) - originPos):Length2D() - myHullSize
				local projectilDisToOrigin = (projectilePos - originPos):Length2D()
				if projectilDisToOrigin < myDisToOrigin and timeElapsed > 0 then
					local myDisToProjectile = (Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() - myHullSize
					if myDisToProjectile > 1 then
						local remainingTravelTime = math.max(myDisToProjectile / projectileSpeed, 0)
						local processImpactTime = GameRules.GetGameTime() + remainingTravelTime
						if math.abs(info.time - processImpactTime) > 0.01 then
							local insert = table.remove(AIO_Umbrella.armletDamageInstanceTable, i)
							insert.time = AIO_Umbrella.utilityRoundNumber(processImpactTime, 3)
							table.insert(AIO_Umbrella.armletDamageInstanceTable, insert)
							break
							return
						end
					end
				end
			end
			if GameRules.GetGameTime() > info.time then
				local backSwingCheck = 0
					if info.backswingend ~= nil then
						backSwingCheck = info.backswingend - info.time
					end
				if GameRules.GetGameTime() > info.time + math.max(backSwingCheck, 0) + 0.25 then
					table.remove(AIO_Umbrella.armletDamageInstanceTable, i)
					break
					return
				end
			end
		end
	end
	
	return	

end

function AIO_Umbrella.getDotDamageTicks(myHero)

	if not myHero then return end

	for dotMod, tickRate in pairs(AIO_Umbrella.armletDotTickTable) do
		if NPC.HasModifier(myHero, dotMod) then
			local creationTime = AIO_Umbrella.utilityRoundNumber(Modifier.GetCreationTime(NPC.GetModifier(myHero, dotMod)), 3) + 0.035
			local nextTick = creationTime + math.max(math.ceil((GameRules.GetGameTime() - creationTime) / tickRate), 1) * tickRate
			if #AIO_Umbrella.armletDamageInstanceTable < 1 then
				table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = dotMod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
			else
				local inserted = false
				for k, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
					if info and info.instanceindex == dotMod and info.time == nextTick then
						inserted = true
					end
				end
				if not inserted then
					table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = dotMod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
				end
			end
		else
			for i, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
				if info.instanceindex == dotMod then
					table.remove(AIO_Umbrella.armletDamageInstanceTable, i)
				end
			end	

		end
	end

	for i, v in ipairs(Entity.GetHeroesInRadius(myHero, 1351, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsNPC(v) and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			for mod, info in pairs(AIO_Umbrella.armletDotTickTableAOE) do
				if NPC.HasModifier(v, mod) then
					local effectRadius = info[1]
					local tickRate = info[2]
					if NPC.IsEntityInRange(myHero, v, effectRadius) then
						local creationTime = AIO_Umbrella.utilityRoundNumber(Modifier.GetCreationTime(NPC.GetModifier(v, mod)), 2) + 0.035
						local nextTick = creationTime + math.ceil((GameRules.GetGameTime() - creationTime) / tickRate) * tickRate
						if #AIO_Umbrella.armletDamageInstanceTable < 1 then
							table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = mod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
						else
							local inserted = false
							for k, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
								if info.instanceindex == mod then
									inserted = true
								end
							end
							if not inserted then
								table.insert(AIO_Umbrella.armletDamageInstanceTable, { instanceindex = mod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
							end
						end
					else
						for i, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
							if info.instanceindex == mod then
								table.remove(AIO_Umbrella.armletDamageInstanceTable, i)
							end
						end	
					end
				else
					for i, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
						if info.instanceindex == mod then
							table.remove(AIO_Umbrella.armletDamageInstanceTable, i)
						end
					end
				end
			end
		end
	end

	return 

end

function AIO_Umbrella.getAdjustedMaxTrueDamage(unit, target)

	if not unit then return 0 end
	if not target then return 0 end

	if Entity.IsDormant(unit) then return 0 end
	if Entity.IsDormant(target) then return 0 end

	local maxDamage = NPC.GetTrueMaximumDamage(unit)
	local maxTrueDamage = NPC.GetDamageMultiplierVersus(unit, target) * maxDamage * NPC.GetArmorDamageMultiplier(target)

	local bonusDamage = 0
	if NPC.HasModifier(unit, "modifier_storm_spirit_overload") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		local overload = NPC.GetAbility(unit, "storm_spirit_overload")
		local bonus = 0
		if overload and Ability.GetLevel(overload) > 0 then
			bonus = Ability.GetDamage(overload)
		end
		local bonusTrue = (1 - NPC.GetMagicalArmorValue(target)) * bonus + bonus * (Hero.GetIntellectTotal(unit) / 14 / 100)
		bonusDamage = bonusDamage + bonusTrue
	end

	if NPC.HasAbility(unit, "clinkz_searing_arrows") then
		local orb = NPC.GetAbility(unit, "clinkz_searing_arrows")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = 20 + 10 * Ability.GetLevel(orb)
				if NPC.HasAbility(unit, "special_bonus_unique_clinkz_1") then
					if Ability.GetLevel(NPC.GetAbility(unit, "special_bonus_unique_clinkz_1")) > 0 then
						bonus = bonus + 30
					end
				end
			local bonusTrue = NPC.GetDamageMultiplierVersus(unit, target) * bonus * NPC.GetArmorDamageMultiplier(target)
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "obsidian_destroyer_arcane_orb") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		local orb = NPC.GetAbility(unit, "obsidian_destroyer_arcane_orb")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = (0.05 + (0.01 * Ability.GetLevel(orb))) * NPC.GetMana(unit)
			local bonusTrue = bonus
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "silencer_glaives_of_wisdom") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		local orb = NPC.GetAbility(unit, "silencer_glaives_of_wisdom")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = 0.15 * Ability.GetLevel(orb) * Hero.GetIntellectTotal(unit)
				if NPC.HasAbility(unit, "special_bonus_unique_silencer_3") then
					if Ability.GetLevel(NPC.GetAbility(unit, "special_bonus_unique_silencer_3")) > 0 then
						bonus = (0.2 + 0.15 * Ability.GetLevel(orb)) * Hero.GetIntellectTotal(unit)
					end
				end
			local bonusTrue = bonus
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "kunkka_tidebringer") then
		local orb = NPC.GetAbility(unit, "kunkka_tidebringer")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = Ability.GetLevelSpecialValueFor(orb, "damage_bonus")
			local bonusTrue = NPC.GetDamageMultiplierVersus(unit, target) * bonus * NPC.GetArmorDamageMultiplier(target)
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "enchantress_impetus") then
		local orb = NPC.GetAbility(unit, "enchantress_impetus")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local distance = (Entity.GetAbsOrigin(unit) - Entity.GetAbsOrigin(target)):Length2D() * 1.35
				if distance > 1750 then
					distance = 1750
				end
			local distanceDamage = Ability.GetLevelSpecialValueForFloat(orb, "distance_damage_pct")
				if NPC.HasAbility(unit, "special_bonus_unique_enchantress_4") then
					if Ability.GetLevel(NPC.GetAbility(unit, "special_bonus_unique_enchantress_4")) > 0 then
						distanceDamage = distanceDamage + 8
					end
				end
			local bonus = distance * (distanceDamage / 100)
			local bonusTrue = bonus
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if Entity.IsSameTeam(unit, target) then
		bonusDamage = 0
	end

	if NPC.IsStructure(target) then
		bonusDamage = 0
	end
	
	return math.ceil(maxTrueDamage + bonusDamage)

end

function AIO_Umbrella.armletShouldBeToggledOff(myHero)

	if not myHero then return true end

	if AIO_Umbrella.isArmletActive == false then return false end
	if AIO_Umbrella.armletCurrentHPGain < 250 then return false end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmletManuallyOverride) then
		if AIO_Umbrella.isArmletManuallyToggled == true then 
			return false 
		end
	end

	local hpTreshold = Menu.GetValue(AIO_Umbrella.optionItemArmletHPTreshold)
	local curTime = GameRules.GetGameTime()

	if #AIO_Umbrella.armletDamageInstanceTable < 1 then
		if Menu.IsEnabled(AIO_Umbrella.optionItemArmletCombo) then
			if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
				return false
			end
		end
		if Menu.IsEnabled(AIO_Umbrella.optionItemArmletRightClick) then
			if AIO_Umbrella.armletRightClickToggle then
				return false
			end
		end
		local gettingFaced = false
		for i, v in ipairs(Entity.GetUnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsRanged(v) then
						if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 145) then
							gettingFaced = true
						end
					else
						if NPC.IsEntityInRange(myHero, v, 285) then
							gettingFaced = true
						end
					end
				end
			end
		end
		if gettingFaced then
			if Entity.GetHealth(myHero) > hpTreshold then
				return false
			end
		end
		return true
	else
		local nextDamageInstance = 9999
			for i, v in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
				if v and v.time - GameRules.GetGameTime() > 0.0 then
					if i < nextDamageInstance then
						nextDamageInstance = i
					end
				end
			end
		if nextDamageInstance > 999 then
			if Menu.IsEnabled(AIO_Umbrella.optionItemArmletCombo) then
				if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
					if Entity.GetHealth(myHero) > hpTreshold then
						return false
					end
				end
			end
			if Menu.IsEnabled(AIO_Umbrella.optionItemArmletRightClick) then
				if AIO_Umbrella.armletRightClickToggle then
					if Entity.GetHealth(myHero) > hpTreshold then
						return false
					end
				end
			end
			local gettingFaced = false
			for i, v in ipairs(Entity.GetUnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
				if v and Entity.IsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
					if NPC.FindFacingNPC(v) == myHero then
						if NPC.IsRanged(v) then
							if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 145) then
								gettingFaced = true
							end
						else
							if NPC.IsEntityInRange(myHero, v, 285) then
								gettingFaced = true
							end
						end
					end
				end
			end
			if gettingFaced then
				if Entity.GetHealth(myHero) > hpTreshold then
					return false
				end
			end
			
			local inBackSwing = true
				for k, l in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
					if l.backswingstart ~= nil and l.backswingend ~= nil then
						if GameRules.GetGameTime() < l.backswingstart or GameRules.GetGameTime() > l.backswingend - 0.15 then
							inBackSwing = false
							break
						end
					end
				end

			if not inBackSwing then
				return false
			end

			local lastDamageInstanceTime = AIO_Umbrella.armletDamageInstanceTable[#AIO_Umbrella.armletDamageInstanceTable]["time"]
			if GameRules.GetGameTime() > lastDamageInstanceTime + 0.075 then
				return true
			end
		else
			local safeToggle = false
			local emergencyToggle = false
			for i, instance in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
				local instanceTiming = instance.time
				local instanceDamage = instance.damage + math.ceil((instanceTiming - curTime) / 0.11) * 6	
				local toggleTreshold = math.max(instanceDamage, hpTreshold)
				if instanceDamage > Entity.GetHealth(myHero) then
					if i > 1 then
						if GameRules.GetGameTime() - AIO_Umbrella.armletDamageInstanceTable[i-1]["time"] > 0.075 then
							emergencyToggle = true
							break
						end
					else
						emergencyToggle = true
						break
					end
				else
					if Entity.GetHealth(myHero) <= toggleTreshold then
						if instanceTiming - GameRules.GetGameTime() > 0.42 then
							local inBackSwing = true
								for k, l in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
									if l.backswingstart ~= nil and l.backswingend ~= nil then
										if GameRules.GetGameTime() < l.backswingstart or GameRules.GetGameTime() > l.backswingend - 0.15 then
											if l.casttime < 0.25 then
												inBackSwing = false
												break
											end
										end
									end
								end
							if inBackSwing then
								if i > 1 then
									if GameRules.GetGameTime() - AIO_Umbrella.armletDamageInstanceTable[i-1]["time"] > 0.075 then
										safeToggle = true
										break
									end
								else
									safeToggle = true
									break
								end	
							end
						end
					else
						local adjustedHP = math.max((Entity.GetHealth(myHero) - AIO_Umbrella.armletCurrentHPGain), 1)
						if adjustedHP > toggleTreshold and (not Menu.IsKeyDown(AIO_Umbrella.optionComboKey) or AIO_Umbrella.armletRightClickToggle) then
							safeToggle = true
						end
					end
				end	
			end

			if emergencyToggle then
				return true
			end

			if safeToggle then
				return true
			end
		end
	end

	return false
end
				
function AIO_Umbrella.armletShouldBeToggledOn(myHero)

	if not myHero then return false end

	if AIO_Umbrella.isArmletActive == true then return false end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmletManuallyOverride) then
		if AIO_Umbrella.isArmletManuallyToggled == true then 
			return false 
		end
	end

	if NPC.HasModifier(myHero, "modifier_ice_blast") then
		return false
	end

	local hpTreshold = Menu.GetValue(AIO_Umbrella.optionItemArmletHPTreshold)
	local myHP = Entity.GetHealth(myHero)

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmletCombo) then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
			if AIO_Umbrella.LockedTarget ~= nil then
				return true
			end
		end
	end

	if myHP < hpTreshold then
		for i, v in ipairs(Entity.GetUnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsRanged(v) then
						if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 145) then
							return true
						end
					else
						if NPC.IsEntityInRange(myHero, v, 285) then
							return true
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmletRightClick) then
		if AIO_Umbrella.armletRightClickToggle then
			return true
		end
	end

	for i, info in ipairs(AIO_Umbrella.armletDamageInstanceTable) do
		if info then
			local nextInstance = info.time
			local nextDamage = info.damage
			local triggerTreshold = math.max(hpTreshold, nextDamage)
			if nextInstance > GameRules.GetGameTime() then
				if nextInstance - GameRules.GetGameTime() <= 1.0 then
					if myHP <= triggerTreshold then	
						return true
					end
				end
			end
		end
	end

	return false
end

function AIO_Umbrella.armletHandler(myHero)

	if not myHero then return end

	local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if not armlet then return end

	AIO_Umbrella.armletProcessInstanceTable(myHero)
	AIO_Umbrella.getDotDamageTicks(myHero)
	AIO_Umbrella.getAbilityDamageInstances(myHero)

	if Ability.GetToggleState(armlet) then
		if os.clock() - AIO_Umbrella.armletToggleTimePingAdjuster <= (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)) / 2 + 0.05 then
			AIO_Umbrella.isArmletActive = AIO_Umbrella.isArmletActive
		else
			AIO_Umbrella.isArmletActive = true
		end
	else
		if os.clock() - AIO_Umbrella.armletToggleTimePingAdjuster <= (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)) / 2 + 0.05 then
			AIO_Umbrella.isArmletActive = AIO_Umbrella.isArmletActive
		else
			AIO_Umbrella.isArmletActive = false
		end
		if AIO_Umbrella.isArmletManuallyToggled == true and GameRules.GetGameTime() - AIO_Umbrella.isArmletManuallyToggledTime >= 0.1 then
			AIO_Umbrella.isArmletManuallyToggled = false
		end
	end

	local armletModifier = NPC.GetModifier(myHero, "modifier_item_armlet_unholy_strength")
	local maxHPGain = 464
	if armletModifier ~= nil then
		local armletStartTime = Modifier.GetCreationTime(armletModifier)
		if GameRules.GetGameTime() - armletStartTime > 0.6 then
			AIO_Umbrella.armletCurrentHPGain = maxHPGain
		else
			if GameRules.GetGameTime() - armletStartTime > 0 then
				AIO_Umbrella.armletCurrentHPGain = math.floor((GameRules.GetGameTime() - armletStartTime) * (maxHPGain/0.6))
			end
		end
	else
		AIO_Umbrella.armletCurrentHPGain = 0
	end

	if os.clock() < AIO_Umbrella.armletDelayer then return end

	if Menu.IsEnabled(AIO_Umbrella.optionItemArmletManuallyOverride) then
		if AIO_Umbrella.isArmletManuallyToggled then 
			return 
		end
	end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if os.clock() < AIO_Umbrella.armletToggleTime then return end

	if AIO_Umbrella.armletShouldBeToggledOn(myHero) then
		Ability.Toggle(armlet)
		AIO_Umbrella.isArmletActive = true
		AIO_Umbrella.armletToggleTime = os.clock() + 0.65 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
		AIO_Umbrella.armletToggleTimePingAdjuster = os.clock()
		return
	end

	if AIO_Umbrella.armletShouldBeToggledOff(myHero) then
		if os.clock() - AIO_Umbrella.armletToggleTime > 0.04 then
			Ability.Toggle(armlet)
			AIO_Umbrella.isArmletActive = false
			AIO_Umbrella.armletToggleTime = os.clock() + 0.01
			AIO_Umbrella.armletToggleTimePingAdjuster = os.clock()
			return
		end
	end

end

-- linkens breaker functions
function AIO_Umbrella.LinkensBreakerNew(myHero)

	if not myHero then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionLinkensEnable) then return end

	local myMana = NPC.GetMana(myHero)

 	local prioItem
	local prioOrder = 0

	for k, v in ipairs(AIO_Umbrella.LinkensBreakerItemOrder) do
	
		if NPC.HasItem(myHero, v[2], true) then
			if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and v[1] > prioOrder then
					prioItem = v[2]
					prioOrder = v[1]
				
			end
		end	
	
	end
	return prioItem	
end
	
-- utility item usage functions
function AIO_Umbrella.utilityItemUsage(myHero)

	if not myHero then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local stick = NPC.GetItem(myHero, "item_magic_stick", true)
	local wand = NPC.GetItem(myHero, "item_magic_wand", true)
	local mekansm = NPC.GetItem(myHero, "item_mekansm", true)
	local greaves = NPC.GetItem(myHero, "item_guardian_greaves", true)
	local arcane = NPC.GetItem(myHero, "item_arcane_boots", true)
	local midas = NPC.GetItem(myHero, "item_hand_of_midas", true)
	local cheese = NPC.GetItem(myHero, "item_cheese", true)
	local faerie = NPC.GetItem(myHero, "item_faerie_fire", true)
	local bottle = NPC.GetItem(myHero, "item_bottle", true)

	local myMana = NPC.GetMana(myHero)

	if (stick or wand or cheese or faerie) and Menu.IsEnabled(AIO_Umbrella.optionUtilityStick) then
		AIO_Umbrella.utilityItemStick(myHero, stick, wand, cheese, faerie)
	end
	if mekansm and Menu.IsEnabled(AIO_Umbrella.optionUtilityMek) then
		AIO_Umbrella.utilityItemMek(myHero, mekansm, myMana)
	end
	if greaves and Menu.IsEnabled(AIO_Umbrella.optionUtilityGreaves) then
		AIO_Umbrella.utilityItemGreaves(myHero, greaves)
	end
	if arcane and Menu.IsEnabled(AIO_Umbrella.optionUtilityArcane) then
		AIO_Umbrella.utilityItemArcane(myHero, arcane)
	end
	if midas and Menu.IsEnabled(AIO_Umbrella.optionUtilityMidas) then
		AIO_Umbrella.utilityItemMidas(myHero, midas)
	end
	if bottle and Menu.IsEnabled(AIO_Umbrella.optionUtilityBottle) then
		AIO_Umbrella.utilityItemBottle(myHero, bottle)
	end

end

function AIO_Umbrella.utilityItemStick(myHero, stick, wand, cheese, faerie)

	if not myHero then return end
	if (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.GetMyFountainPos(myHero)):Length2D() < 1500 then return end
	
	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	
	if Entity.IsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then
		if stick and myHealthPerc <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth) and Ability.IsReady(stick) then
			if Item.GetCurrentCharges(stick) >= 1 then 
				Ability.CastNoTarget(stick)
				return
			end
		end
		if wand and myHealthPerc <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth) and Ability.IsReady(wand) then 
			if Item.GetCurrentCharges(wand) >= 1 then 
				Ability.CastNoTarget(wand)
				return
			end
		end
		if cheese and myHealthPerc <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth) and Ability.IsReady(cheese) then 
			Ability.CastNoTarget(cheese)
			return
		end
		if faerie and myHealthPerc <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth) and Ability.IsReady(faerie) then 
			Ability.CastNoTarget(faerie)
			return
		end
	end
end

function AIO_Umbrella.utilityItemBottle(myHero, bottle)

	if not myHero then return end
	if not bottle then return end
		if Item.GetCurrentCharges(bottle) < 2 then return end

	if Ability.SecondsSinceLastUse(bottle) > -1 and Ability.SecondsSinceLastUse(bottle) < 0.5 then return end
	if os.clock() < AIO_Umbrella.lastTick then return end

	for i = 1, Abilities.Count() do 
		local abilities = Abilities.Get(i)
		if Entity.GetOwner(abilities) == myHero then
			if Ability.SecondsSinceLastUse(abilities) > -1 and Ability.SecondsSinceLastUse(abilities) < 0.5 then 
				return
			end
		end
	end

	if NPC.HasModifier(myHero, "modifier_bottle_regeneration") then return end
	if not NPC.HasModifier(myHero, "modifier_item_empty_bottle") then return end

	local hpGap = Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)
	local manaGap = NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)

	for i, v in ipairs(Entity.GetUnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsNPC(v) and Entity.IsAlive(v) and not Entity.IsDormant(v) then
			if Entity.IsHero(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 250) then
					return
				end
			else
				if NPC.GetUnitName(v) == "npc_dota_roshan" then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 375) then
						return
					end
				end
			end	
		end
	end
			
	if hpGap < 0.75 then
		Ability.CastNoTarget(bottle)
		return
	end

	if manaGap < 0.75 then
		Ability.CastNoTarget(bottle)
		return
	end

	return

end

function AIO_Umbrella.utilityItemMek(myHero, mekansm, myMana)

	if not myHero then return end
	if not mekansm then return end

	if (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Ability.IsCastable(mekansm, myMana) then
		if Entity.IsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then	
			if (myHealthPerc <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth)) and Ability.IsCastable(mekansm, myMana) then 
				Ability.CastNoTarget(mekansm) 
				return
			end
		end

		for _, teamMates in ipairs(NPC.GetHeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Entity.IsAlive(myHero) and Entity.IsAlive(teamMates) and not NPC.HasModifier(teamMates, "modifier_ice_blast") then	
					if (Entity.GetHealth(teamMates) / Entity.GetMaxHealth(teamMates)) * 100 <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth) and Ability.IsCastable(mekansm, myMana) then
						for _, v in ipairs(Entity.GetHeroesInRadius(teamMates, 1000, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
								if NPC.FindFacingNPC(v) == teamMates then
									Ability.CastNoTarget(mekansm) 
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
end

function AIO_Umbrella.utilityItemGreaves(myHero, greaves)

	if not myHero then return end
	if not greaves then return end

	if (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Ability.IsReady(greaves) then
		if Entity.IsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then	
			if greaves and (myHealthPerc <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth)) and Ability.IsReady(greaves) then 
				Ability.CastNoTarget(greaves) 
				return
			end
		end

		for _, teamMates in ipairs(NPC.GetHeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Entity.IsAlive(myHero) and Entity.IsAlive(teamMates) and not NPC.HasModifier(teamMates, "modifier_ice_blast") then	
					if greaves and (Entity.GetHealth(teamMates) / Entity.GetMaxHealth(teamMates)) * 100 <= Menu.GetValue(AIO_Umbrella.optionUtilityHealth) and Ability.IsReady(greaves) then
						for _, v in ipairs(Entity.GetHeroesInRadius(teamMates, 1000, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
								if NPC.FindFacingNPC(v) == teamMates then
									Ability.CastNoTarget(greaves) 
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
end

function AIO_Umbrella.utilityItemArcane(myHero, arcane)

	if not myHero then return end
	if not arcane then return end

	if (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.GetMyFountainPos(myHero)):Length2D() < 3000 then return end

	local myManaMissing = NPC.GetMaxMana(myHero) - NPC.GetMana(myHero)

	if Ability.IsReady(arcane) then
		if Entity.IsAlive(myHero) then
			if arcane and myManaMissing >= 200 then 
				Ability.CastNoTarget(arcane)
				return 
			end
		end


		for _, teamMates in ipairs(NPC.GetHeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Entity.IsAlive(myHero) and Entity.IsAlive(teamMates) then
					if arcane and (NPC.GetMana(teamMates) / NPC.GetMaxMana(teamMates)) * 100 <= 40 and Ability.IsReady(arcane) then 
						Ability.CastNoTarget(arcane)
						break
						return
					end
				end 
			end
		end
	end
end

function AIO_Umbrella.utilityItemMidas(myHero, midas)

	if not myHero then return end
	if not midas then return end
	if not Ability.IsReady(midas) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_spirit_breaker_charge_of_darkness") then return end

	local targetCreep
	local maxXP = 0

	for _, creeps in ipairs(NPC.GetUnitsInRadius(myHero, 600, Enum.TeamType.TEAM_ENEMY)) do
		if creeps and not Entity.IsHero(creeps) then
			local bounty = NPC.GetBountyXP(creeps)
			if AIO_Umbrella.IsCreepAncient(creeps) == false then
				if (NPC.IsLaneCreep(creeps) or NPC.IsCreep(creeps)) and not NPC.IsDormant(creeps) then
					if bounty > maxXP then
						targetCreep = creeps
						maxXP = bounty
					end	
				end
			end
		end
	end

	if targetCreep ~= nil and maxXP > 0 then
		Ability.CastTarget(midas, targetCreep)
		return
	end

end

function AIO_Umbrella.useDefensiveItems(myHero, enemy)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionDefensiveItems) then return end

	if (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	if os.clock() - AIO_Umbrella.lastDefItemPop < 0.25 then return end

	if AIO_Umbrella.ItemCastStop then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local myMana = NPC.GetMana(myHero)

	local glimmerCape = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local lotusOrb = NPC.GetItem(myHero, "item_lotus_orb", true)
	local crimsonGuard = NPC.GetItem(myHero, "item_crimson_guard", true)
	local pipe = NPC.GetItem(myHero, "item_pipe", true)
	local solarCrest = NPC.GetItem(myHero, "item_solar_crest", true)
	local BKB = NPC.GetItem(myHero, "item_black_king_bar", true)
	local satanic = NPC.GetItem(myHero, "item_satanic", true)
	local medallion = NPC.GetItem(myHero, "item_medallion_of_courage", true)
	local ghost = NPC.GetItem(myHero, "item_ghost", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)

	local channellingTable = {
		"bane_fiends_grip",
		"crystal_maiden_freezing_field",
		"enigma_black_hole",
		"pudge_dismember",
		"pugna_life_drain",
		"sandking_epicenter",
		"shadow_shaman_shackles",
		"warlock_upheaval",
		"witch_doctor_death_ward"
				}

	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsGlimmer) then
		if glimmerCape and Ability.IsCastable(glimmerCape, myMana) then
			if AIO_Umbrella.IsNPCinDanger(myHero, myHero) then
				Ability.CastTarget(glimmerCape, myHero)
				AIO_Umbrella.lastDefItemPop = os.clock()
				return
			end
			if NPC.IsChannellingAbility(myHero) then
				for _, ability in ipairs(channellingTable) do
					if NPC.HasAbility(myHero, ability) and Ability.IsChannelling(NPC.GetAbility(myHero, ability)) then
						Ability.CastTarget(glimmerCape, myHero)
						AIO_Umbrella.lastDefItemPop = os.clock()
						return
					end
				end
			end
			if NPC.HasModifier(myHero, "modifier_teleporting") then
				local myFountain = AIO_Umbrella.GetMyFountainPos(myHero)
				if not NPC.IsPositionInRange(myHero, myFountain, 2500, 0) then
					Ability.CastTarget(glimmerCape, myHero)
					AIO_Umbrella.lastDefItemPop = os.clock()
					return
				end
			end
			if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsAlly) then
				local teamMatesAround = NPC.GetHeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(glimmerCape, ally)
							AIO_Umbrella.lastDefItemPop = os.clock()
							break
							return
						end
						if NPC.IsChannellingAbility(ally) then
							for _, ability in ipairs(channellingTable) do
								if NPC.HasAbility(ally, ability) and Ability.IsChannelling(NPC.GetAbility(ally, ability)) then
									Ability.CastTarget(glimmerCape, ally)
									AIO_Umbrella.lastDefItemPop = os.clock()
									return
								end
							end
						end
					end
				end
			end
		end
	end

	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end

	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsGhost) then
		if ghost and Ability.IsReady(ghost) then
			if Entity.GetHealth(myHero) <= Menu.GetValue(AIO_Umbrella.optionDefensiveItemsThreshold)/100 * Entity.GetMaxHealth(myHero) then
				for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
					if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
						if NPC.FindFacingNPC(v) == myHero then
							if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
								if NPC.IsAttacking(v) then
									Ability.CastNoTarget(ghost)
									AIO_Umbrella.lastDefItemPop = os.clock()
									break
									return
								end
							end
						end
					end
				end	
			end
		end
	end
				
	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemslotusOrb) then
		if lotusOrb and Ability.IsCastable(lotusOrb, myMana) then
			if AIO_Umbrella.IsNPCinDanger(myHero, myHero) then
				Ability.CastTarget(lotusOrb, myHero)
				AIO_Umbrella.lastDefItemPop = os.clock()
				return
			end
			if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsAlly) then
				local teamMatesAround = NPC.GetHeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(lotusOrb, ally)
							AIO_Umbrella.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end
	
	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsCrimson) then
		if crimsonGuard and Ability.IsCastable(crimsonGuard, myMana) then
			if AIO_Umbrella.IsNPCinDanger(myHero, myHero) then
				Ability.CastNoTarget(crimsonGuard)
				AIO_Umbrella.lastDefItemPop = os.clock()
				return
			end
			local teamMatesAround = NPC.GetHeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
					if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
						Ability.CastNoTarget(crimsonGuard)
						AIO_Umbrella.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsCrest) then
		if solarCrest and Ability.IsCastable(solarCrest, myMana) then
			if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsAlly) then
				local teamMatesAround = NPC.GetHeroesInRadius(myHero, 975, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(solarCrest, ally)
							AIO_Umbrella.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsMedallion) then
		if medallion and Ability.IsCastable(medallion, myMana) then
			if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsAlly) then
				local teamMatesAround = NPC.GetHeroesInRadius(myHero, 975, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
						if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(medallion, ally)
							AIO_Umbrella.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsPipe) then
		if pipe and Ability.IsCastable(pipe, myMana) then
			if AIO_Umbrella.IsNPCinDanger(myHero, myHero) then
				Ability.CastNoTarget(pipe)
				AIO_Umbrella.lastDefItemPop = os.clock()
				return
			end
			local teamMatesAround = NPC.GetHeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
					if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
						Ability.CastNoTarget(pipe)
						AIO_Umbrella.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsBKB) then
		if BKB and Ability.IsReady(BKB) then
			if AIO_Umbrella.shouldCastBKB(myHero) == true then
				Ability.CastNoTarget(BKB)
				AIO_Umbrella.lastDefItemPop = os.clock()
				return
			end
		end
	end
	
	if Menu.IsEnabled(AIO_Umbrella.optionDefensiveItemsSatanic) then
		if satanic and Ability.IsCastable(satanic, myMana) then			
			if AIO_Umbrella.shouldCastSatanic(myHero, enemy) == true then
				Ability.CastNoTarget(satanic)
				AIO_Umbrella.lastDefItemPop = os.clock()
				return
			end
		end
	end
end

function AIO_Umbrella.IsNPCinDanger(myHero, npc)

	if not myHero then return false end
	if not npc or NPC.IsIllusion(npc) or not Entity.IsAlive(npc) then return false end

	if NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end
	if NPC.HasModifier(npc, "modifier_item_lotus_orb_active") then return false end

	if NPC.HasModifier(npc, "modifier_dazzle_shallow_grave") then return false end
	if AIO_Umbrella.IsHeroInvisible(npc) == true then return false end
	if NPC.HasModifier(npc, "modifier_fountain_aura_buff") then return false end

	if #Entity.GetHeroesInRadius(npc, 1500, Enum.TeamType.TEAM_ENEMY) < 1 then return false end
	if #Entity.GetHeroesInRadius(myHero, 1500, Enum.TeamType.TEAM_ENEMY) < 1 then return false end
	if (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	if NPC.GetUnitName(npc) == "npc_dota_hero_monkey_king" then
		if NPC.GetAbilityByIndex(npc, 1) ~= nil then
			if Ability.SecondsSinceLastUse(NPC.GetAbilityByIndex(npc, 1)) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbilityByIndex(npc, 1)) < 2 then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_nyx_assassin" then
		if NPC.GetAbility(npc, "nyx_assassin_burrow") ~= nil and Ability.GetLevel(NPC.GetAbility(npc, "nyx_assassin_burrow")) > 0 then
			if Ability.IsInAbilityPhase(NPC.GetAbility(npc, "nyx_assassin_burrow")) then
				return false
			elseif not Ability.IsHidden(NPC.GetAbility(npc, "nyx_assassin_unburrow")) then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_sand_king" then
		if NPC.GetAbility(npc, "sandking_burrowstrike") ~= nil then
			local burrow = NPC.GetAbility(npc, "sandking_burrowstrike")
			if Ability.SecondsSinceLastUse(burrow) > -1 and Ability.SecondsSinceLastUse(burrow) < 1 then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_earth_spirit" then
		if NPC.GetAbility(npc, "earth_spirit_rolling_boulder") ~= nil then
			local boulder = NPC.GetAbility(npc, "earth_spirit_rolling_boulder")
			if Ability.SecondsSinceLastUse(boulder) > -1 and Ability.SecondsSinceLastUse(boulder) < 2 then
				return false
			end
		end
	end
	
	local momSilenced = false
	if NPC.HasItem(npc, "item_mask_of_madness", true) then
		local mom = NPC.GetItem(npc, "item_mask_of_madness", true)
		if Ability.SecondsSinceLastUse(mom) > -1 and Ability.SecondsSinceLastUse(mom) < 8 then
			momSilenced = true
		end
	end

	if NPC.HasModifier(npc, "modifier_nyx_assassin_burrow") then return false end
	if NPC.HasModifier(npc, "modifier_monkey_king_tree_dance_activity") then return false end

	if AIO_Umbrella.TargetGotDisableModifier(myHero, npc) == true or (NPC.IsSilenced(npc) and not momSilenced) or
		NPC.HasModifier(npc, "modifier_item_nullifier_mute") or NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_HEXED) then

		if Entity.GetHealth(npc) / Entity.GetMaxHealth(npc) <= (Menu.GetValue(AIO_Umbrella.optionDefensiveItemsThresholdDisable) / 100) then
			for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
				if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
					if NPC.FindFacingNPC(v) == npc or NPC.IsEntityInRange(npc, v, NPC.GetAttackRange(v) + 150) then
						return true
					end
				end
			end
		end
	end

	if Entity.GetHealth(npc) <= Menu.GetValue(AIO_Umbrella.optionDefensiveItemsThreshold)/100 * Entity.GetMaxHealth(npc) then
		for _, v in ipairs(Entity.GetHeroesInRadius(npc, 1000, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
				if NPC.FindFacingNPC(v) == npc then
					return true
				end
			end
		end
	end

	return false

end

function AIO_Umbrella.IsHeroInvisible(myHero)

	if not myHero then return false end
	if not Entity.IsAlive(myHero) then return false end

	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVISIBLE) then return true end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return true end
	if NPC.HasAbility(myHero, "invoker_ghost_walk") then
		if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 1 then 
			return true
		end
	end

	if NPC.HasItem(myHero, "item_invis_sword", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) < 1 then 
			return true
		end
	end
	if NPC.HasItem(myHero, "item_silver_edge", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) < 1 then 
			return true
		end
	end

	return false
		
end

function AIO_Umbrella.TargetGotDisableModifier(myHero, npc)

	if not myHero then return false end
	if not npc then return false end

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_item_rod_of_atos_debuff",
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(npc, modifier) then
			searchMod = NPC.GetModifier(npc, modifier)
			break
		end
	end

	local timeleft = 0
	if searchMod then
		if NPC.HasModifier(npc, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				timeleft = Modifier.GetCreationTime(searchMod) + 4
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				timeleft = Modifier.GetCreationTime(searchMod) + 4.5
			else
				timeleft = Modifier.GetDieTime(searchMod)
			end
		else
			timeleft = 0
		end
	else
		timeleft = 0
	end

	if timeleft > 0.75 then
		return true
	end

	return false

end

function AIO_Umbrella.heroCanCastSpells(myHero, enemy)

	if not myHero then return false end
	if not Entity.IsAlive(myHero) then return false end

	if NPC.IsSilenced(myHero) then return false end 
	if NPC.IsStunned(myHero) then return false end
	if NPC.HasModifier(myHero, "modifier_bashed") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	
	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end
	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	
	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end
	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end
	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end
	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end
	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end
	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end
	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end
	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end
	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end
	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end
	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end

	if enemy then
		if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then return false end
	end

	return true	

end

function AIO_Umbrella.heroCanCastItems(myHero)

	if not myHero then return false end
	if not Entity.IsAlive(myHero) then return false end

	if NPC.IsStunned(myHero) then return false end
	if NPC.HasModifier(myHero, "modifier_bashed") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	
	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end
	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	
	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end
	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end
	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end
	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end
	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end
	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end
	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end
	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end
	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end
	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end
	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end

	return true	

end

function AIO_Umbrella.isHeroChannelling(myHero)

	if not myHero then return true end

	if NPC.IsChannellingAbility(myHero) then return true end
	if NPC.HasModifier(myHero, "modifier_teleporting") then return true end

	return false

end

function AIO_Umbrella.shouldCastBKB(myHero)

	if not myHero then return end

	local dangerousRangeTable = {
		alchemist_unstable_concoction_throw = 775,
		beastmaster_primal_roar = 600,
		centaur_hoof_stomp = 315,
		chaos_knight_chaos_bolt = 500,
		crystal_maiden_frostbite = 525,
		dragon_knight_dragon_tail = 400,
		drow_ranger_wave_of_silence = 900,
		earth_spirit_boulder_smash = 300,
		earthshaker_fissure = 1400,
		ember_spirit_searing_chains = 400,
		invoker_tornado = 1000,
		jakiro_ice_path = 1200,
		lion_impale = 500,
		lion_voodoo = 500,
		naga_siren_ensnare = 650,
		nyx_assassin_impale = 700,
		puck_dream_coil = 750,
		rubick_telekinesis = 625,
		sandking_burrowstrike = 650,
		shadow_shaman_shackles = 400,
		shadow_shaman_voodoo = 500,
		skeleton_king_hellfire_blast = 525,
		slardar_slithereen_crush = 400,
		storm_spirit_electric_vortex = 400,
		sven_storm_bolt = 600,
		tidehunter_ravage = 1025,
		tiny_avalanche = 600,
		vengefulspirit_magic_missile = 500,
		warlock_rain_of_chaos = 1200,
		windrunner_shackleshot = 800,
		slark_pounce = 700,
		ogre_magi_fireblast = 475,
		meepo_poof = 400
			}

	local enemyTable = {}
	local enemiesAround = Entity.GetHeroesInRadius(myHero, Menu.GetValue(AIO_Umbrella.optionDefensiveItemsBKBRadius), Enum.TeamType.TEAM_ENEMY)
		for _, enemy in ipairs(enemiesAround) do
			if enemy then
				if not Entity.IsDormant(enemy) and not NPC.IsIllusion(enemy) and not NPC.IsStunned(enemy) and not NPC.IsSilenced(enemy) then
					table.insert(enemyTable, enemy)
				end
			end
		end

	if next(enemyTable) == nil then return false end

	local tempTable = {}
	for i = 1, #AIO_Umbrella.preemptiveBKBtable do
		if Menu.IsEnabled(AIO_Umbrella.preemptiveBKB[i]) then
			table.insert(tempTable, AIO_Umbrella.preemptiveBKBtable[i])
		end
	end

	if next(tempTable) == nil then return false end

	local searchAbility
	for _, enemy in ipairs(enemyTable) do
		for _, ability in ipairs(tempTable) do
			if NPC.HasAbility(enemy, ability) then
				if NPC.GetAbility(enemy, ability) ~= nil and Ability.IsReady(NPC.GetAbility(enemy, ability)) then
					if Ability.GetLevel(NPC.GetAbility(enemy, ability)) > 0 and Ability.GetCooldownTimeLeft(NPC.GetAbility(enemy, ability)) < 1 and not Ability.IsHidden(NPC.GetAbility(enemy, ability)) then
						if dangerousRangeTable[ability] > (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() then
							searchAbility = ability
							break
						end
					end
				end
			end
		end
	end

	if searchAbility ~= nil and #enemyTable >= Menu.GetValue(AIO_Umbrella.optionDefensiveItemsBKBEnemies) then
		return true
	end

	return false

end

function AIO_Umbrella.shouldCastSatanic(myHero, enemy)

	if not myHero then return end
	if not enemy then return false end
	if Entity.GetHealth(myHero) > Entity.GetMaxHealth(myHero) * 0.3 then return false end

	if enemy then
		if NPC.IsAttacking(myHero) and Entity.GetHealth(enemy) >= Entity.GetMaxHealth(enemy) * 0.25 then
			return true
		end
	end

	return false

end

-- hero functions
function AIO_Umbrella.axeCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroAxe) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local call = NPC.GetAbilityByIndex(myHero, 0)
	local hunger = NPC.GetAbilityByIndex(myHero, 1)
	local culling = NPC.GetAbility(myHero, "axe_culling_blade")

	local blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	local myMana = NPC.GetMana(myHero)

	local callRange = 300
		if NPC.HasAbility(myHero, "special_bonus_unique_axe_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_axe_2")) > 0 then
				callRange = 400
			end
		end
		if NPC.IsRunning(enemy) then
			if not blink then
				callRange = callRange - 100
			else
				if Ability.SecondsSinceLastUse(blink) > 0.75 then
					callRange = callRange - 100
				end
			end	
		end	

	if Menu.IsEnabled(AIO_Umbrella.optionHeroAxeCulling) then
		if culling and Ability.IsCastable(culling, myMana) and AIO_Umbrella.isHeroChannelling(myHero) == false and AIO_Umbrella.IsHeroInvisible(myHero) == false then
			local cullingEnemy = NPC.GetHeroesInRadius(myHero, 150 + NPC.GetCastRangeBonus(myHero), Enum.TeamType.TEAM_ENEMY)
			for i, v in ipairs(cullingEnemy) do
				if v then
					if not NPC.IsDormant(v) and not NPC.IsIllusion(v) and Entity.IsAlive(v) then
						if Entity.GetHealth(v) + NPC.GetHealthRegen(v) < Ability.GetLevelSpecialValueFor(culling, "kill_threshold") and not NPC.IsLinkensProtected(v) then
							Ability.CastTarget(culling, v)
							break
						end
					end
				end
			end
		end
	end

	local cursorCheck
	if Menu.IsEnabled(AIO_Umbrella.optionHeroAxeForceBlink) then
		if NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionHeroAxeForceBlinkRange)-1, 0) then
			cursorCheck = true
		else
			cursorCheck = false
		end
	else
		cursorCheck = true
	end
	
	AIO_Umbrella.itemUsage(myHero, enemy)
	
	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and cursorCheck then
		if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, callRange) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150) then
						if Menu.GetValue(AIO_Umbrella.optionHeroAxeJump) == 0 then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
							return
						else
							local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), callRange * 2, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), callRange)
							if bestPos ~= nil then
								Ability.CastPosition(blink, bestPos)
								return
							end
						end
					end
				end
			end

			if os.clock() > AIO_Umbrella.lastTick then

				if culling and Ability.IsCastable(culling, myMana) and NPC.IsEntityInRange(myHero, enemy, 150) then
					if Entity.GetHealth(enemy) + NPC.GetHealthRegen(enemy) < Ability.GetLevelSpecialValueFor(culling, "kill_threshold") and not NPC.IsLinkensProtected(enemy) then 
						Ability.CastTarget(culling, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.3 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return 
					end
				end

				if call and Ability.IsCastable(call, myMana) and NPC.IsEntityInRange(myHero, enemy, callRange) then 
					Ability.CastNoTarget(call)
					AIO_Umbrella.lastTick = os.clock() + 0.4 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end

				if blademail and Ability.IsCastable(blademail, myMana) and NPC.HasModifier(enemy, "modifier_axe_berserkers_call") then 
					Ability.CastNoTarget(blademail)
					AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end

				if hunger and Ability.IsCastable(hunger, myMana - 120) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(hunger)) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then 
					Ability.CastTarget(hunger, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.3 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end
		end

	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end

end

function AIO_Umbrella.centaurCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroCentaur) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local hoofStomp = NPC.GetAbilityByIndex(myHero, 0)
	local doubleEdge = NPC.GetAbilityByIndex(myHero, 1)

	local blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	local myMana = NPC.GetMana(myHero)

	local cursorCheck
	if Menu.IsEnabled(AIO_Umbrella.optionHeroCentaurForceBlink) then
		if NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), Menu.GetValue(AIO_Umbrella.optionHeroCentaurForceBlinkRange)-1, 0) then
			cursorCheck = true
		else
			cursorCheck = false
		end
	else
		cursorCheck = true
	end
	
	AIO_Umbrella.itemUsage(myHero, enemy)

	local stunRange = 315
		if NPC.IsRunning(enemy) then
			if not blink then
				stunRange = 175
			else
				if Ability.SecondsSinceLastUse(blink) > 0.75 then
					stunRange = 175
				end
			end
		end	
	
	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and cursorCheck then
		if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, stunRange) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150) then
						if Menu.GetValue(AIO_Umbrella.optionHeroCentaurJump) == 0 then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
							return
						else
							local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), stunRange * 2, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), stunRange)
							if bestPos ~= nil then
								Ability.CastPosition(blink, bestPos)
								return
							end
						end
					end
				end
			end

			if os.clock() > AIO_Umbrella.lastTick then
			
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then

					if hoofStomp and Ability.IsCastable(hoofStomp, myMana) and NPC.IsEntityInRange(myHero, enemy, stunRange) then 
						Ability.CastNoTarget(hoofStomp)
						AIO_Umbrella.lastTick = os.clock() + 0.5 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 
						return
					end

					if blademail and Ability.IsCastable(blademail, myMana) and NPC.HasModifier(enemy, "modifier_stunned") then 
						Ability.CastNoTarget(blademail)
						AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return
					end

					if doubleEdge and Ability.IsCastable(doubleEdge, myMana) and NPC.IsEntityInRange(myHero, enemy, 150) and not NPC.IsLinkensProtected(enemy) then 
						Ability.CastTarget(doubleEdge, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.5 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return
					end
				end
			end
		end

	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end

end

function AIO_Umbrella.PudgeCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroPudge) then return end

	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "pudge_dismember")

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local force = NPC.GetItem(myHero, "item_force_staff", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.PudgeHookTargetIndicatorDel(myHero)

	local maxInitRange = 0
		if blink and Ability.IsReady(blink) and Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeBlink) then
			maxInitRange = maxInitRange + 1200
		end
		if force and Ability.IsCastable(force, myMana) and Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeStaff) then
			maxInitRange = maxInitRange + 600
		end
		if enemy then
			if NPC.HasModifier(enemy, "modifier_pudge_meat_hook") then
				maxInitRange = 0
			end
		end
		if Q and Ability.SecondsSinceLastUse(Q) > -1 and Ability.SecondsSinceLastUse(Q) < 0.5 then
			maxInitRange = 0
		end

	if AIO_Umbrella.PudgeRotComboActivation and not Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
		if Ability.GetToggleState(W) then
			local checkEnemies = false
				for i, v in ipairs(Entity.GetHeroesInRadius(myHero, 250, Enum.TeamType.TEAM_ENEMY)) do
					if v and Entity.IsHero(v) and Entity.IsAlive(v) and not NPC.IsIllusion(v) then
						checkEnemies = true
						break
					end
				end

				if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < 0.2 then
					checkEnemies = false
				end

			if not checkEnemies then		
				if os.clock() > AIO_Umbrella.PudgeRotComboDeactivation then
					Ability.Toggle(W)
					AIO_Umbrella.PudgeRotComboActivation = false
					AIO_Umbrella.PudgeRotComboDeactivation = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING) + 0.05
					return
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHook) then
		if Menu.IsKeyDown(AIO_Umbrella.optionHeroPudgeHookKey) then
			local target = AIO_Umbrella.PudgeHookGetTarget(myHero)
			if AIO_Umbrella.PudgeHookTarget == nil then
				AIO_Umbrella.PudgeHookTarget = target
			end
			if AIO_Umbrella.PudgeHookTarget ~= nil then
				if Entity.IsHero(AIO_Umbrella.PudgeHookTarget) and Entity.IsAlive(AIO_Umbrella.PudgeHookTarget) then
					AIO_Umbrella.PudgeHookCombo(myHero, myMana, AIO_Umbrella.PudgeHookTarget, Q, W, ult)
				else
					AIO_Umbrella.PudgeHookTarget = nil
				end	
			end
		else
			if AIO_Umbrella.PudgeHookTarget ~= nil then
				AIO_Umbrella.PudgeHookTarget = nil
			end
		end
	end					

	if enemy and NPC.IsEntityInRange(myHero, enemy, 3000) then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 			if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				if maxInitRange > 1200 then
					if not NPC.IsEntityInRange(myHero, enemy, 1200) then
						if NPC.IsEntityInRange(myHero, enemy, 1750) then
							local pred = 600/1500 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							local predPos = AIO_Umbrella.castPrediction(myHero, enemy, pred)
							if AIO_Umbrella.AmIFacingPos(myHero, predPos, 10) then
								Ability.CastTarget(force, myHero)
								return
							else
								AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, predPos)
								return
							end
						end
					else
						if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(AIO_Umbrella.optionHeroPudgeBlinkMinRange)) then
							if not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then
								Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(75)))
								AIO_Umbrella.lastTick = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
					end
				end
				if maxInitRange == 1200 then
					if NPC.IsEntityInRange(myHero, enemy, 1200) then
						if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(AIO_Umbrella.optionHeroPudgeBlinkMinRange)) then
							if not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then
								Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(75)))
								AIO_Umbrella.lastTick = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
					end
				end
				if maxInitRange == 600 then
					if NPC.IsEntityInRange(myHero, enemy, 725) then
						if not NPC.IsEntityInRange(myHero, enemy, 550) then
							local pred = 600/1500 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							local predPos = AIO_Umbrella.castPrediction(myHero, enemy, pred)
							if AIO_Umbrella.AmIFacingPos(myHero, predPos, 5) then
								Ability.CastTarget(force, myHero)
								AIO_Umbrella.lastTick = os.clock() + 600/1500 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							else
								AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, predPos)
								return
							end
						end
					end
				end

				if AIO_Umbrella.PudgeHookCanceller(myHero, enemy) then
					Player.HoldPosition(Players.GetLocal(), myHero, false)
					AIO_Umbrella.PudgeHookStartTimer = 0
					AIO_Umbrella.lastTick = 0
					AIO_Umbrella.PudgeHookTargetedPos = nil
					return
				end	

				if W and Ability.IsReady(W) and NPC.IsEntityInRange(myHero, enemy, 245) and not Ability.GetToggleState(W) then
					if os.clock() > AIO_Umbrella.PudgeHookRotDelayer then	
						Ability.Toggle(W)
						AIO_Umbrella.PudgeRotComboActivation = true
						AIO_Umbrella.PudgeHookRotDelayer = os.clock() + 0.2
						return
					end
				end
	
				if os.clock() > AIO_Umbrella.lastTick then

					if ult and Ability.IsCastable(ult, myMana) then
						if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(ult)) then
							if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_HEXED) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_STUNNED) then
								Ability.CastTarget(ult, enemy)
								AIO_Umbrella.lastTick = os.clock() + 0.5
								return
							end
						end	
					end

					local check = false
						if maxInitRange == 600 then
							if NPC.IsEntityInRange(myHero, enemy, 725) then
								if not NPC.IsEntityInRange(myHero, enemy, 550) then
									check = true
								end
							end
						end
						if ult and Ability.IsCastable(ult, myMana) then
							if force and Ability.SecondsSinceLastUse(force) > -1 and Ability.SecondsSinceLastUse(force) < 1 then
								check = true
							end
							if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.5 then
								check = true
							end
						end

					if Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHookCombo) and not check and not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then
						if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(AIO_Umbrella.optionHeroPudgeHookComboMaxRange)) and not NPC.IsChannellingAbility(myHero) then
							if AIO_Umbrella.PudgeHookCollisionChecker(myHero, enemy) and not AIO_Umbrella.PudgeHookJukingChecker(myHero, enemy) then
								local hookPrediction = Ability.GetCastPoint(Q) + NPC.GetTimeToFace(myHero, enemy) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								local hookPredictedPos = AIO_Umbrella.castPrediction(myHero, enemy, hookPrediction)
								Ability.CastPosition(Q, Entity.GetAbsOrigin(myHero) + (hookPredictedPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
								AIO_Umbrella.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, hookPredictedPos)
								AIO_Umbrella.PudgeHookTargetedPos = hookPredictedPos
								AIO_Umbrella.lastTick = os.clock() + 0.3
								return
							end
						end
					end
				end
			end

			local attCheck = false
				if ult and Ability.IsCastable(ult, myMana) then
					if force and Ability.SecondsSinceLastUse(force) > -1 and Ability.SecondsSinceLastUse(force) < 1 then
						check = true
					end
					if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.5 then
						check = true
					end
				end

			if not NPC.HasModifier(enemy, "modifier_pudge_meat_hook") and not attCheck then
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeFarm) then
		AIO_Umbrella.PudgeAutoFarm(myHero, myMana, W)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeSuicide) then
		AIO_Umbrella.PudgeAutoSuicide(myHero, myMana, W)
	end

	return

end

function AIO_Umbrella.PudgeAutoSuicide(myHero, myMana, rot)

	if not myHero then return end
	if not rot then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if os.clock() < AIO_Umbrella.PudgeRotFarmToggledTime then return end

	if NPC.HasItem(myHero, "item_armlet", true) then return end

	local rotDamage = Ability.GetLevelSpecialValueFor(rot, "rot_damage")
		if NPC.HasAbility(myHero, "special_bonus_unique_pudge_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pudge_2")) > 0 then
				rotDamage = rotDamage + 35
			end
		end

	rotDamage = ((1 - NPC.GetMagicalArmorValue(myHero)) * rotDamage + rotDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) / 4

	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
		if soulRing and Ability.IsReady(soulRing) and AIO_Umbrella.heroCanCastItems(myHero) then
			rotDamage = rotDamage + 150
		end

	local myHP = Entity.GetHealth(myHero)

	if myHP <= rotDamage then
		for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.IsAttacking(v) then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.FindFacingNPC(v) == myHero then
							if soulRing and Ability.IsReady(soulRing) and AIO_Umbrella.heroCanCastItems(myHero) then
								Ability.CastNoTarget(soulRing)
								if not Ability.GetToggleState(rot) then
									Ability.Toggle(rot)
								end
								AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								break
								return
							else
								if not Ability.GetToggleState(rot) then
									Ability.Toggle(rot)
								end
								AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								break
								return
							end		
						end
					end
				end
				for ability, info in pairs(AIO_Umbrella.RawDamageAbilityEstimation) do
					if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
						local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
						local abilityRadius = info[3]
						if AIO_Umbrella.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							if next(AIO_Umbrella.dodgeItTable) == nil then
								if soulRing and Ability.IsReady(soulRing) and AIO_Umbrella.heroCanCastItems(myHero) then
									Ability.CastNoTarget(soulRing)
									if not Ability.GetToggleState(rot) then
										Ability.Toggle(rot)
									end
									AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
									break
									return
								else
									if not Ability.GetToggleState(rot) then
										Ability.Toggle(rot)
									end
									AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
									break
									return
								end
							end
						end
					end
				end
			end	
		end
	end

	return	

end

function AIO_Umbrella.PudgeAutoFarm(myHero, myMana, rot)

	if not myHero then return end
	if not rot then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if os.clock() < AIO_Umbrella.PudgeRotFarmToggledTime then return end

	if AIO_Umbrella.PudgeRotFarmToggled and not Ability.GetToggleState(rot) then
		AIO_Umbrella.PudgeRotFarmToggled = false
		return
	end

	if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(AIO_Umbrella.optionHeroPudgeFarmHP) / 100 then
		if Ability.GetToggleState(rot) and AIO_Umbrella.PudgeRotFarmToggled then
			Ability.Toggle(rot)
			AIO_Umbrella.PudgeRotFarmToggled = false
			AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
			return
		else
			return
		end
	end

	local rotDamage = Ability.GetLevelSpecialValueFor(rot, "rot_damage")
		if NPC.HasAbility(myHero, "special_bonus_unique_pudge_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pudge_2")) > 0 then
				rotDamage = rotDamage + 35
			end
		end

	if #Entity.GetUnitsInRadius(myHero, 240, Enum.TeamType.TEAM_ENEMY) < 1 then
		if Ability.GetToggleState(rot) and AIO_Umbrella.PudgeRotFarmToggled then
			Ability.Toggle(rot)
			AIO_Umbrella.PudgeRotFarmToggled = false
			AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
			return
		end
	end	

	
	for _, creeps in ipairs(Entity.GetUnitsInRadius(myHero, 240, Enum.TeamType.TEAM_ENEMY)) do
		if creeps and Entity.IsNPC(creeps) and not Entity.IsHero(creeps) and Entity.IsAlive(creeps) and not Entity.IsDormant(creeps) and not NPC.IsWaitingToSpawn(creeps) and NPC.GetUnitName(creeps) ~= "npc_dota_neutral_caster" and NPC.IsCreep(creeps) and NPC.GetUnitName(creeps) ~= nil and NPC.IsKillable(creeps) then
			local rotTrueDamage = ((1 - NPC.GetMagicalArmorValue(creeps)) * rotDamage + rotDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) / 4
			if Entity.GetHealth(creeps) < rotTrueDamage then
				if not Ability.GetToggleState(rot) then
					Ability.Toggle(rot)
					AIO_Umbrella.PudgeRotFarmToggled = true
					AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			else
				if Ability.GetToggleState(rot) and AIO_Umbrella.PudgeRotFarmToggled then
					Ability.Toggle(rot)
					AIO_Umbrella.PudgeRotFarmToggled = false
					AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end
		else
			if Ability.GetToggleState(rot) and AIO_Umbrella.PudgeRotFarmToggled then
				Ability.Toggle(rot)
				AIO_Umbrella.PudgeRotFarmToggled = false
				AIO_Umbrella.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
				return
			end
		end
	end
	
	return
		
end

function AIO_Umbrella.PudgeHookCombo(myHero, myMana, npc, hook, rot, ult)

	if not myHero then return end
	if not npc then return end

	if not hook then return end
		if Ability.GetLevel(hook) < 1 then return end

	AIO_Umbrella.PudgeHookTargetIndicator(myHero, npc)
	AIO_Umbrella.PudgeHookHitTracker(myHero, hook)

	if not Entity.IsSameTeam(myHero, npc) then
		if ult and Ability.IsCastable(ult, myMana) and Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHookUlt) then
			if not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_HEXED) and not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_STUNNED) then
				if os.clock() > AIO_Umbrella.PudgeHookDelayer then
					if NPC.IsEntityInRange(myHero, AIO_Umbrella.PudgeHookTarget, Ability.GetCastRange(ult)) then
						Ability.CastTarget(ult, AIO_Umbrella.PudgeHookTarget)
						AIO_Umbrella.PudgeHookDelayer = os.clock() + 0.3
						return
					end
				end
			end
		end

		if rot and Ability.IsReady(rot) and NPC.IsEntityInRange(myHero, AIO_Umbrella.PudgeHookTarget, 250) and not Ability.GetToggleState(rot) and Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHookRot) then
			if os.clock() > AIO_Umbrella.PudgeHookRotDelayer then
				Ability.Toggle(rot)
				AIO_Umbrella.PudgeHookRotDelayer = os.clock() + 0.25
				return
			end
		end

		if AIO_Umbrella.PudgeHookHit then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHookItems) then
				AIO_Umbrella.itemUsageSmartOrder(myHero, npc, true)
			end
			if not NPC.HasModifier(npc, "modifier_pudge_meat_hook") then
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", npc, nil)
			end
		end	
	end

	local hookRange = Ability.GetCastRange(hook)
	local pred = Ability.GetCastPoint(hook) + NPC.GetTimeToFace(myHero, npc) + (Entity.GetAbsOrigin(npc):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
	local predPos = AIO_Umbrella.castPrediction(myHero, npc, pred)

	if not NPC.IsPositionInRange(myHero, predPos, hookRange + 100, 20) then return end

	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)

	if hook and Ability.IsCastable(hook, myMana) and not NPC.IsChannellingAbility(myHero) then

		if AIO_Umbrella.PudgeHookCanceller(myHero, npc) then
			Player.HoldPosition(Players.GetLocal(), myHero, false)
			AIO_Umbrella.PudgeHookTarget = nil
			AIO_Umbrella.PudgeHookStartTimer = 0
			AIO_Umbrella.PudgeHookDelayer = 0
			AIO_Umbrella.PudgeHookTargetedPos = nil
			return
		end
			
		if os.clock() > AIO_Umbrella.PudgeHookDelayer then
			if not AIO_Umbrella.PudgeHookJukingChecker(myHero, npc) then
				if AIO_Umbrella.PudgeHookCollisionChecker(myHero, npc) then
					if AIO_Umbrella.PudgeHookTiming(myHero, npc) > 0 then
						local modTiming = AIO_Umbrella.PudgeHookTiming(myHero, npc) + 0.1
						local hookTiming = Ability.GetCastPoint(hook) + NPC.GetTimeToFace(myHero, npc) + ((Entity.GetAbsOrigin(npc):__sub(Entity.GetAbsOrigin(myHero)):Length2D() - 125) / 1450) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						if GameRules.GetGameTime() > modTiming - hookTiming then
							Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
							AIO_Umbrella.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, predPos)
							AIO_Umbrella.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, predPos)
							return	
						end
					else
						if atos and Ability.IsCastable(atos, myMana) and NPC.IsEntityInRange(myHero, npc, 1150) and not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(npc) then
							Ability.CastTarget(atos, npc)
							AIO_Umbrella.PudgeHookTarget = npc
							return
						else
							if atos and Ability.SecondsSinceLastUse(atos) > -1 and Ability.SecondsSinceLastUse(atos) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(npc)):Length2D() / 1500) + 0.55 then
								local atosTiming = GameRules.GetGameTime() - math.max(Ability.SecondsSinceLastUse(atos), 0) + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(npc)):Length2D() / 1500) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) - 0.1
								if GameRules.GetGameTime() >= atosTiming then
									Ability.CastPosition(hook, Entity.GetAbsOrigin(npc))
									AIO_Umbrella.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, predPos)
									AIO_Umbrella.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, predPos)
									return
								end	
							else
								Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
								AIO_Umbrella.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, predPos)
								AIO_Umbrella.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, predPos)
								AIO_Umbrella.PudgeHookTargetedPos = predPos
								return
							end
						end
					end
				else
					if AIO_Umbrella.PudgeHookForceStaffFun(myHero, myMana, npc, hook) then
						local targetRotation = Entity.GetRotation(npc):GetForward()
						local targetForcedPos = Entity.GetAbsOrigin(npc) + targetRotation:Normalized():Scaled(600)
						Ability.CastTarget(NPC.GetItem(myHero, "item_force_staff", true), npc)
						AIO_Umbrella.PudgeHookTarget = npc
						Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (targetForcedPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500), true)
						AIO_Umbrella.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, targetForcedPos)
						AIO_Umbrella.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + AIO_Umbrella.TimeToFacePosition(myHero, targetForcedPos)
						return	
					end
				end
							
			end
		end

	end

end

function AIO_Umbrella.PudgeHookCollisionChecker(myHero, target)

	if not myHero then return false end
	if not target then return false end

	local pred = 0.3 + NPC.GetTimeToFace(myHero, target) + (Entity.GetAbsOrigin(target):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
	local predPos = AIO_Umbrella.castPrediction(myHero, target, pred)

	local searchRadius = 125
	local distance = (Entity.GetAbsOrigin(myHero) - predPos):Length2D()

	for i = 1, math.floor(distance / searchRadius) do
		local checkVec = (predPos - Entity.GetAbsOrigin(myHero)):Normalized()
		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius)
		local unitsAround = NPCs.InRadius(checkPos, searchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH)
		local check = false
			for _, unit in ipairs(unitsAround) do
				if unit and Entity.IsNPC(unit) and unit ~= target and unit ~= myHero and Entity.IsAlive(unit) and not Entity.IsDormant(unit) and not NPC.IsStructure(unit) and not NPC.IsBarracks(unit) and not NPC.IsWaitingToSpawn(unit) and NPC.GetUnitName(unit) ~= "npc_dota_neutral_caster" and NPC.GetUnitName(unit) ~= nil then
					check = true
					break
				end
			end

		if check then
			return false
		end	

	end

	return true

end

function AIO_Umbrella.PudgeHookCanceller(myHero, target)

	if not myHero then return false end
	if not target then return false end

	local hook = NPC.GetAbilityByIndex(myHero, 0)
		if not hook then return false end
			if Ability.GetLevel(hook) < 1 then return false end

	local hookRange = Ability.GetCastRange(hook)

	if AIO_Umbrella.PudgeHookTargetedPos == nil then return false end

	if os.clock() > AIO_Umbrella.PudgeHookStartTimer + 0.3 then return false end
	if os.clock() < AIO_Umbrella.PudgeHookStartTimer + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then return false end

	local timePassed = math.min(os.clock() - AIO_Umbrella.PudgeHookStartTimer, 0.3)

	local pred = (0.3 - timePassed) + (Entity.GetAbsOrigin(target):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
	local predPos = AIO_Umbrella.castPrediction(myHero, target, pred)
	
	if (predPos - Entity.GetAbsOrigin(myHero)):Length2D() > hookRange + 100 then return true end

	local searchRadius = 120
	local distance = (Entity.GetAbsOrigin(myHero) - predPos):Length2D()

	local check = false
		for i = 1, math.ceil(distance / searchRadius) do
			local checkVec = (AIO_Umbrella.PudgeHookTargetedPos - Entity.GetAbsOrigin(myHero)):Normalized()
			local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius)
			if (checkPos - predPos):Length2D() < searchRadius then
				check = true
				break
			end
		end

	if not check then
		return true
	end

	return false

end

function AIO_Umbrella.PudgeHookJukingChecker(myHero, target)

	if not myHero then return false end
	if not target then return false end

	if not NPC.IsRunning(target) then return false end

	local turning = Entity.IsTurning(target)

	if NPC.IsRunning(target) then
		if NPC.IsRunning(target) then
			table.insert(AIO_Umbrella.rotationTable, turning)
			if #AIO_Umbrella.rotationTable > Menu.GetValue(AIO_Umbrella.optionHeroPudgeHookJuke) then
				table.remove(AIO_Umbrella.rotationTable, 1)
			end
		end
	end

	if #AIO_Umbrella.rotationTable < Menu.GetValue(AIO_Umbrella.optionHeroPudgeHookJuke) then 
		return true
	else
		local check = false
		for i = 1, #AIO_Umbrella.rotationTable do
			if AIO_Umbrella.rotationTable[i] == true then
				check = true
				break
			end
		end

		if check then
			return true
		end
	end

	return false
 
end

function AIO_Umbrella.PudgeHookGetTarget(myHero)

	if not myHero then return end

	local targetingRange = Menu.GetValue(AIO_Umbrella.optionHeroPudgeHookAcquiRange)
	local mousePos = Input.GetWorldCursorPos()

	
	local enemyTable = Heroes.InRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)
		if Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHookAllies) then
			enemyTable = Heroes.InRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH)
		end
		if #enemyTable < 1 then return end

	local nearestTarget = nil
	local distance = 99999

	for i, v in ipairs(enemyTable) do
		if v and Entity.IsHero(v) and Entity.IsAlive(v) and v ~= myHero then
			if AIO_Umbrella.targetChecker(v) ~= nil then
				local enemyDist = (Entity.GetAbsOrigin(v) - mousePos):Length2D()
				if enemyDist < distance then
					nearestTarget = v
					distance = enemyDist
				end
			end
		end
	end

	return nearestTarget or nil

end

function AIO_Umbrella.PudgeHookTiming(myHero, target)

	if not myHero then return 0 end
	if not target then return 0 end

	local invulnerabilityList = {
		"modifier_eul_cyclone",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption",
		"modifier_invoker_tornado"
			}
	
	local searchMod
	for _, modifier in ipairs(invulnerabilityList) do
		if NPC.HasModifier(target, modifier) then
			searchMod = NPC.GetModifier(target, modifier)
			break
		end
	end

	if not searchMod then return 0 end

	local timing = 0
	if searchMod then
		local dieTime = Modifier.GetDieTime(searchMod)
		timing = dieTime
	end

	return timing

end

function AIO_Umbrella.PudgeHookHitTracker(myHero, hook)

	if not myHero then return end
	if not hook then return end

	if Ability.SecondsSinceLastUse(hook) == -1 and AIO_Umbrella.PudgeHookHit then
		AIO_Umbrella.PudgeHookHit = false
	end

	if AIO_Umbrella.PudgeHookTarget == nil and AIO_Umbrella.PudgeHookHit then
		AIO_Umbrella.PudgeHookHit = false
	end

	if AIO_Umbrella.PudgeHookTarget then
		if NPC.HasModifier(AIO_Umbrella.PudgeHookTarget, "modifier_pudge_meat_hook") then
			AIO_Umbrella.PudgeHookHit = true
		end
	end
	
	return

end

function AIO_Umbrella.PudgeHookForceStaffFun(myHero, myMana, target, hook)

	if not myHero then return false end
	if not target then return false end
		if NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return false end

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHookStaff) then return false end
	if not hook then return false end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return false end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return false end 

	if not NPC.IsEntityInRange(myHero, target, 750) then return false end
	if AIO_Umbrella.PudgeHookJukingChecker(myHero, target) then return false end

	local force = NPC.GetItem(myHero, "item_force_staff", true)
		if not force then return false end
		if not Ability.IsCastable(force, myMana) then return false end

	local targetTurnTime90 = (0.03 * math.pi) / NPC.GetTurnRate(target) / 3.5
	if NPC.GetTimeToFace(target, myHero) > targetTurnTime90 then return false end

	local targetRotation = Entity.GetRotation(target):GetForward()
	local targetForcedPos = Entity.GetAbsOrigin(target) + targetRotation:Normalized():Scaled(600)

	if not AIO_Umbrella.PudgeHookCollisionCheckerPosition(myHero, targetForcedPos) then return false end
	local hookRange = Ability.GetCastRange(hook)
		if (Entity.GetAbsOrigin(myHero) - targetForcedPos):Length2D() > hookRange then return false end

	return true

end

function AIO_Umbrella.PudgeHookCollisionCheckerPosition(myHero, pos)

	if not myHero then return false end
	if not pos then return false end

	local searchRadius = 125
	local distance = (Entity.GetAbsOrigin(myHero) - pos):Length2D()

	for i = 1, math.floor(distance / searchRadius) do
		local checkVec = (pos - Entity.GetAbsOrigin(myHero)):Normalized()
		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius)
		local unitsAround = NPCs.InRadius(checkPos, searchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH)
		local check = false
			for _, unit in ipairs(unitsAround) do
				if unit and Entity.IsNPC(unit) and unit ~= target and unit ~= myHero and Entity.IsAlive(unit) and not Entity.IsDormant(unit) and not NPC.IsStructure(unit) and not NPC.IsBarracks(unit) and not NPC.IsWaitingToSpawn(unit) and NPC.GetUnitName(unit) ~= "npc_dota_neutral_caster" and NPC.GetUnitName(unit) ~= nil then
					check = true
					break
				end
			end

		if check then
			return false
		end	

	end

	return true

end
			
function AIO_Umbrella.PudgeHookTargetIndicatorDel(myHero)

	if not myHero then return end

	local curtime = GameRules.GetGameTime()

	if not Menu.IsKeyDown(AIO_Umbrella.optionHeroPudgeHookKey) or AIO_Umbrella.PudgeHookTarget == nil then
		if AIO_Umbrella.PudgecurrentParticle > 0 then
			Particle.Destroy(AIO_Umbrella.PudgecurrentParticle)			
			AIO_Umbrella.PudgecurrentParticle = 0
		end
	end

	return

end

function AIO_Umbrella.PudgeHookTargetIndicator(myHero, target)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroPudgeHook) then return end

	local curtime = GameRules.GetGameTime()
		
	if (not target or target ~= AIO_Umbrella.PudgecurrentParticleTarget) and AIO_Umbrella.PudgecurrentParticle > 0 then
		Particle.Destroy(AIO_Umbrella.PudgecurrentParticle)			
		AIO_Umbrella.PudgecurrentParticle = 0
		AIO_Umbrella.PudgecurrentParticleTarget = target
	else
		if AIO_Umbrella.PudgecurrentParticle == 0 and target then
			local Particle = Particle.Create("particles/ui_mouseactions/range_finder_tower_aoe.vpcf", Enum.ParticleAttachment.PATTACH_INVALID, target)	
			AIO_Umbrella.PudgecurrentParticle = Particle
			AIO_Umbrella.PudgecurrentParticleTarget = target			
		end
		if AIO_Umbrella.PudgecurrentParticle > 0 then
			Particle.SetControlPoint(AIO_Umbrella.PudgecurrentParticle, 2, Entity.GetOrigin(myHero))
			Particle.SetControlPoint(AIO_Umbrella.PudgecurrentParticle, 6, Vector(1, 0, 0))
			Particle.SetControlPoint(AIO_Umbrella.PudgecurrentParticle, 7, Entity.GetOrigin(AIO_Umbrella.PudgecurrentParticleTarget))
		end
	end

end

function AIO_Umbrella.OgreCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroOgre) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
 	local S = NPC.GetAbility(myHero, "ogre_magi_unrefined_fireblast")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroOgreBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.45
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.45
					return
				end

				if S and Ability.IsCastable(S, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(S)) then
					Ability.CastTarget(S, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.45
					return
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.VSCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroVS) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroVSBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroVSBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroVSBlinkRange))))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then

				if not Menu.IsEnabled(AIO_Umbrella.optionHeroVSStun) then
		
					if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) and not NPC.IsLinkensProtected(enemy) then
						Ability.CastTarget(Q, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.35
						return
					end

					if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
						if not NPC.HasModifier(enemy, "modifier_vengefulspirit_wave_of_terror") then
							local pred = 0.3 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							Ability.CastPosition(W, AIO_Umbrella.castPrediction(myHero, enemy, pred))
							AIO_Umbrella.lastTick = os.clock() + 0.35
							return
						end
					end

				else

					if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) and not NPC.IsLinkensProtected(enemy) then
						Ability.CastTarget(Q, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.35
						return
					end

					local check = false
						if Q and Ability.IsCastable(Q, myMana) then
							check = true
						end

					if not check then
						if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
							if not NPC.HasModifier(enemy, "modifier_vengefulspirit_wave_of_terror") then
								local pred = 0.3 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								local predPos = AIO_Umbrella.castPrediction(myHero, enemy, pred)
								Ability.CastPosition(W, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
								AIO_Umbrella.lastTick = os.clock() + 0.35
								return
							end
						end
					end
				end	
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.AACombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroAA) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroAABlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroAABlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroAABlinkRange))))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.05
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					if not NPC.HasModifier(enemy, "modifier_ice_vortex") then
						local pred = 0.87 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(W, AIO_Umbrella.castPrediction(myHero, enemy, pred))
						AIO_Umbrella.lastTick = os.clock() + 0.05
						return
					end
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.CMCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroCM) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 800) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroCMBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroCMBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroCMBlinkRange))))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					if AIO_Umbrella.TargetGotDisableModifier(myHero, enemy) == false then
						Ability.CastTarget(W, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.3
						return
					end
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 820, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 410)
					if bestPos ~= nil then
						Ability.CastPosition(Q, bestPos)
						AIO_Umbrella.lastTick = os.clock() + 0.3
						return
					end
				end

			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroCMUlt) then
		local ult = NPC.GetAbility(myHero, "crystal_maiden_freezing_field")
		local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
		local bkb = NPC.GetItem(myHero, "item_black_king_bar", true)
			if not ult or (ult and not Ability.IsCastable(ult, myMana)) then return end
			if not blink or (blink and not Ability.IsReady(blink)) then return end
			if os.clock() < AIO_Umbrella.lastTick then return end

		if Menu.IsKeyDown(AIO_Umbrella.optionHeroCMUltKey) and Entity.IsAlive(enemy) and NPC.IsEntityInRange(myHero, enemy, 1150 + 450) then
 			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 1220, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 600)
				if bestPos ~= nil and #Heroes.InRadius(bestPos, 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(AIO_Umbrella.optionHeroCMUltMin) then
					if #Heroes.InRadius(bestPos, 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) == 1 then
						if NPC.IsPositionInRange(myHero, bestPos, 1150 + 350, 0) then
							if bkb and Ability.IsCastable(bkb, myMana) then
								Ability.CastNoTarget(bkb)
								AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end
							if glimmer and Ability.IsCastable(glimmer, myMana) then
								Ability.CastTarget(glimmer, myHero)
								AIO_Umbrella.lastTick = os.clock() + 0.55 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(350)))
							Ability.CastNoTarget(ult, true)
							AIO_Umbrella.lastTick = os.clock() + 0.5
							return
						else
							AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
							return
						end
					else
						if NPC.IsPositionInRange(myHero, bestPos, 1150, 0) then
							if bkb and Ability.IsCastable(bkb, myMana) then
								Ability.CastNoTarget(bkb)
								AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end
							if glimmer and Ability.IsCastable(glimmer, myMana) then
								Ability.CastTarget(glimmer, myHero)
								AIO_Umbrella.lastTick = os.clock() + 0.55 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end

							local savePos = bestPos
								if #Heroes.InRadius(savePos, 350, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
									local myPos = Entity.GetAbsOrigin(myHero)
									local dist = (myPos - savePos):Length2D()
									for k = 1, math.floor(dist/25) do
										local searchPos = savePos + (myPos - savePos):Normalized():Scaled(k*25)
										if #Heroes.InRadius(searchPos, 350, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
											savePos = searchPos
											break
										end
									end		
								end

							Ability.CastPosition(blink, savePos)
							Ability.CastNoTarget(ult, true)
							AIO_Umbrella.lastTick = os.clock() + 0.5
							return
						else
							AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
							return
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.DPCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroDP) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local E = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroDPBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroDPBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroDPBlinkRange))))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					local carrionPrediction = 0.5 + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predictedPos = Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.castLinearPrediction(myHero, enemy, carrionPrediction) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250)
					Ability.CastPosition(Q, predictedPos)
					AIO_Umbrella.lastTick = os.clock() + 0.5
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 820, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 410)
					if bestPos ~= nil then
						Ability.CastPosition(W, bestPos)
						AIO_Umbrella.lastTick = os.clock() + 0.5
						return
					end
				end

				if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(E)) then
					Ability.CastTarget(E, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.1
					return
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.ViperCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroViper) then return end

	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "viper_viper_strike")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if enemy and NPC.IsEntityInRange(myHero, enemy, 3000) then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 925) then
					if Menu.IsEnabled(AIO_Umbrella.optionHeroViperBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroViperBlinkRange)) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroViperBlinkRange))))
						return
					end
				end		

				if os.clock() > AIO_Umbrella.lastTick then

					if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) and not NPC.HasModifier(enemy, "modifier_viper_nethertoxin") then
						local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 570, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 285)
						if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, Ability.GetCastRange(W), 0) then
							Ability.CastPosition(W, bestPos)
							AIO_Umbrella.lastTick = os.clock() + 0.2
							return
						end
					end

					if ult and Ability.IsCastable(ult, myMana) then
						if Menu.IsEnabled(AIO_Umbrella.optionHeroViperForceUlt) then
							if not NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(ult)) then
								AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
								return
							else
								Ability.CastTarget(ult, enemy)
								AIO_Umbrella.lastTick = os.clock() + 0.3
								return
							end

						else
							if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(ult)) then
								Ability.CastTarget(ult, enemy)
								AIO_Umbrella.lastTick = os.clock() + 0.3
								return
							end
						end
					end
				end
			end

			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			return
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroViperHarass) then
		if Menu.IsKeyDown(AIO_Umbrella.optionHeroViperHarassKey) then
			AIO_Umbrella.ViperAutoHarass(myHero, myMana, Q)
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroViperFarm) then
		AIO_Umbrella.ViperFarmHelper(myHero, myMana, W)
	end

end

function AIO_Umbrella.ViperAutoHarass(myHero, myMana, Q)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroViperHarass) then return end

	if not Q then return end
		if Ability.GetLevel(Q) < 1 then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local harassTarget = nil
		for _, hero in ipairs(NPC.GetHeroesInRadius(myHero, NPC.GetAttackRange(myHero), Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
				if Entity.IsAlive(hero) and not NPC.HasState(hero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
        				harassTarget = hero
					break
				end
      			end			
		end

	local mousePos = Input.GetWorldCursorPos()
	if harassTarget ~= nil then
		if not AIO_Umbrella.lastHitBackswingChecker(myHero) then
			Ability.CastTarget(Q, harassTarget)
			return
		else
			if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
				return
			end
		end
	else
		if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
			return
		end
	end

	return

end

function AIO_Umbrella.ViperFarmHelper(myHero, myMana, W)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroViperFarm) then return end
	local myManaPerc = math.floor((myMana / NPC.GetMaxMana(myHero)) * 100)
		if myManaPerc < Menu.GetValue(AIO_Umbrella.optionHeroViperFarmMana) then return end

	if not W then return end
		if not Ability.IsCastable(W, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	for _, creeps in ipairs(Entity.GetUnitsInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
		if creeps and Entity.IsNPC(creeps) and not Entity.IsHero(creeps) and Entity.IsAlive(creeps) and not Entity.IsDormant(creeps) and not NPC.IsWaitingToSpawn(creeps) and NPC.GetUnitName(creeps) ~= "npc_dota_neutral_caster" and NPC.IsCreep(creeps) and NPC.GetUnitName(creeps) ~= nil then
			if creeps ~= nil and not NPC.IsRunning(creeps) and NPC.IsAttacking(creeps) and not NPC.IsRanged(creeps) and not NPC.HasModifier(creeps, "modifier_viper_nethertoxin") and #Entity.GetUnitsInRadius(creeps, 290, Enum.TeamType.TEAM_FRIEND) >= Menu.GetValue(AIO_Umbrella.optionHeroViperFarmCount) - 1 then
				local bestPos = AIO_Umbrella.getBestPosition(NPCs.InRadius(Entity.GetAbsOrigin(creeps), 580, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 290)
				if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, Ability.GetCastRange(W), 0) then

					Ability.CastPosition(W, bestPos)
					break
					return
				end
			end
		end
	end
	return

end

function AIO_Umbrella.PugnaCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroPugna) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local E = NPC.GetAbilityByIndex(myHero, 2)
	local ult = NPC.GetAbility(myHero, "pugna_life_drain")
		if ult and Ability.SecondsSinceLastUse(ult) > -1 and Ability.SecondsSinceLastUse(ult) < 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)) then
			return
		end

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 700) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroPugnaBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroPugnaBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroPugnaBlinkRange))))
					return
				end
			end

			if os.clock() > AIO_Umbrella.lastTick and not NPC.IsChannellingAbility(myHero) then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.2
					return
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q) + 300) then
					local pred = 1.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predPos = AIO_Umbrella.castPrediction(myHero, enemy, pred)
					if not NPC.IsPositionInRange(myHero, predPos, Ability.GetCastRange(Q), 0) then
						local myPos = Entity.GetAbsOrigin(myHero)
						local dist = (myPos - predPos):Length2D()
						local saveCastPos = predPos
						for k = 1, math.floor(dist/25) do
							local searchPos = predPos + (myPos - predPos):Normalized():Scaled(k*25)
							if NPC.IsPositionInRange(myHero, searchPos, Ability.GetCastRange(Q), 0) then
								saveCastPos = searchPos
								break
							end
						end
						if NPC.IsPositionInRange(myHero, saveCastPos, Ability.GetCastRange(Q), 0) then	
							Ability.CastPosition(Q, saveCastPos)
							AIO_Umbrella.lastTick = os.clock() + 0.2
							return
						end
					else
						Ability.CastPosition(Q, predPos)
						AIO_Umbrella.lastTick = os.clock() + 0.2
						return
					end

				end

				if Menu.IsEnabled(AIO_Umbrella.optionHeroPugnaWard) then
					if #Entity.GetHeroesInRadius(myHero, 1200, Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(AIO_Umbrella.optionHeroPugnaWardCount) then
						if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, 700) then
							Ability.CastPosition(E, Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(100))
							AIO_Umbrella.lastTick = os.clock() + 0.2
							return
						end
					end
				end

				if Menu.IsEnabled(AIO_Umbrella.optionHeroPugnaInvis) then
					local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
					local blade = NPC.GetItem(myHero, "item_invis_sword", true)
					local silver = NPC.GetItem(myHero, "item_silver_edge", true)
					if ult and Ability.IsCastable(ult, myMana - 90) and not AIO_Umbrella.IsHeroInvisible(myHero) then
						if glimmer and Ability.IsCastable(glimmer, myMana) then
							Ability.CastTarget(glimmer, myHero)
							return
						end

						if blade and Ability.IsCastable(blade, myMana) then
							Ability.CastNoTarget(blade)
							return
						end

						if silver and Ability.IsCastable(silver, myMana) then
							Ability.CastNoTarget(silver)
							return
						end
					end
				end

				if ult and Ability.IsCastable(ult, myMana) then
					local castRangeAdjustment = Ability.GetCastRange(ult)
					local dagon = NPC.GetItem(myHero, "item_dagon", true)
						if not dagon then
							for i = 2, 5 do
								dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
								if dagon then 
									break 
								end
							end
						end

						if dagon then
							if Ability.GetCastRange(dagon) < Ability.GetCastRange(ult) then
								castRangeAdjustment = Ability.GetCastRange(dagon)
							end
						end

					if not Ability.IsChannelling(ult) then
						if NPC.IsEntityInRange(myHero, enemy, castRangeAdjustment) then
							Ability.CastTarget(ult, enemy)
							AIO_Umbrella.lastTick = os.clock() + 0.2
							return
						else
							if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_ATTACK_IMMUNE) then
								AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
								return
							end
						end	
					end
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.NSCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNS) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroNSBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.3
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.3
					return
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.UndyingCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroUndying) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "undying_flesh_golem")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsEnabled(AIO_Umbrella.optionHeroUndyingSoulKS) then
		AIO_Umbrella.UndyingSoulKS(myHero, myMana, W)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroUndyingBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 620, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 310)
					if bestPos ~= nil then
						Ability.CastPosition(Q, bestPos)
						AIO_Umbrella.lastTick = os.clock() + 0.45
						return
					end
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					local saving = false
					local savingUnit = nil
						if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(AIO_Umbrella.optionHeroUndyingSoulTreshold) / 100 then
							saving = true
							savingUnit = myHero
						elseif #Entity.GetHeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND) > 0 then
							for _, ally in ipairs(Entity.GetHeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND)) do
								if ally and Entity.IsAlive(ally) and not NPC.IsIllusion(ally) then
									if Entity.GetHealth(ally) / Entity.GetMaxHealth(ally) < Menu.GetValue(AIO_Umbrella.optionHeroUndyingSoulTreshold) / 100 then
										saving = true
										savingUnit = ally
									end
								end
							end
						end

					if not saving then
						if #Entity.GetUnitsInRadius(myHero, 1290, Enum.TeamType.TEAM_BOTH) >= Menu.GetValue(AIO_Umbrella.optionHeroUndyingSoulCount) then
							Ability.CastTarget(W, enemy)
							AIO_Umbrella.lastTick = os.clock() + 0.45
							return
						end
					else
						if savingUnit ~= nil then
							Ability.CastTarget(W, savingUnit)
							AIO_Umbrella.lastTick = os.clock() + 0.45
							return
						end
					end	
				end
				
				if Menu.IsEnabled(AIO_Umbrella.optionHeroUndyingUlt) then
					if #Entity.GetHeroesInRadius(myHero, 700, Enum.TeamType.TEAM_BOTH) >= Menu.GetValue(AIO_Umbrella.optionHeroUndyingUltCount) then
						if ult and Ability.IsCastable(ult, myMana) and NPC.IsEntityInRange(myHero, enemy, 700) then
							Ability.CastNoTarget(ult)
							AIO_Umbrella.lastTick = os.clock() + 0.15
							return
						end
					end
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

	if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(AIO_Umbrella.optionHeroUndyingSoulTreshold) / 100 then
		if W and Ability.IsCastable(W, myMana) then
			Ability.CastTarget(W, myHero)
			AIO_Umbrella.lastTick = os.clock() + 0.45
			return
		end
	end

	if #Entity.GetHeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND) > 0 then
		for _, ally in ipairs(Entity.GetHeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND)) do
			if ally and Entity.IsAlive(ally) and not NPC.IsIllusion(ally) then
				if Entity.GetHealth(ally) / Entity.GetMaxHealth(ally) < Menu.GetValue(AIO_Umbrella.optionHeroUndyingSoulTreshold) / 100 then
					Ability.CastTarget(W, ally)
					AIO_Umbrella.lastTick = os.clock() + 0.45
					return
				end
			end
		end
	end

	return

end

function AIO_Umbrella.UndyingSoulKS(myHero, myMana, soulrip)

	if not myHero then return end
	if not soulrip then return end
		if not Ability.IsReady(soulrip) then return end
		if not Ability.IsCastable(soulrip, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local damagePerUnit = Ability.GetLevelSpecialValueFor(soulrip, "damage_per_unit")
	local maxUnits = Ability.GetLevelSpecialValueFor(soulrip, "max_units")
	local radius = Ability.GetLevelSpecialValueFor(soulrip, "radius")

	local unitsAround = 0
		for _, v in ipairs(Entity.GetUnitsInRadius(myHero, radius - 25, Enum.TeamType.TEAM_BOTH)) do
			if v and Entity.IsNPC(v) and Entity.IsAlive(v) then
				if Entity.IsSameTeam(myHero, v) then
					unitsAround = unitsAround + 1
				else
					if not NPC.HasState(v, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
						unitsAround = unitsAround + 1
					end
				end
			end
		end

	local adjustedUnitsAround = math.min(unitsAround, maxUnits)

	local damage = adjustedUnitsAround * damagePerUnit

	for _, targets in ipairs(Entity.GetHeroesInRadius(myHero, Ability.GetCastRange(soulrip), Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = AIO_Umbrella.targetChecker(targets)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
					local targetHP = Entity.GetHealth(target) + NPC.GetHealthRegen(target)
					local soulripTrueDamage = (1 - NPC.GetMagicalArmorValue(target)) * (damage + damage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
					if targetHP < soulripTrueDamage then
						Ability.CastTarget(soulrip, target)
						break
						return
					end
				end
			end
		end
	end

	return

end

function AIO_Umbrella.CKCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroCK) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "chaos_knight_phantasm")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroCKBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.4
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.3
					return
				end

				if Menu.IsEnabled(AIO_Umbrella.optionHeroCKUlt) then
					if ult and Ability.IsCastable(ult, myMana) and NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(AIO_Umbrella.optionHeroCKUltTrigger)) then
						Ability.CastNoTarget(ult)
						AIO_Umbrella.lastTick = os.clock() + 0.4
						return
					end
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		AIO_Umbrella.GenericControllableAttackIssuer("ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.NyxCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNyx) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true and not NPC.HasModifier(myHero, "modifier_nyx_assassin_vendetta") then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroNyxBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q) - 50) then
					local pred = 0.4 + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1600) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predPos = AIO_Umbrella.castLinearPrediction(myHero, enemy, pred)
					local predPosAdjusted = Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(200)
					Ability.CastPosition(Q, predPosAdjusted)
					AIO_Umbrella.lastTick = os.clock() + 0.4
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.4
					return
				end
			end
		end

		if not NPC.HasModifier(myHero, "modifier_nyx_assassin_burrow") then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			return
		end
	end

end

function AIO_Umbrella.LionCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroLion) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 800) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroLionBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroLionBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroLionBlinkRange))))
					AIO_Umbrella.lastTick = os.clock() + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) and not NPC.IsStunned(enemy) then
					local specialBonus = NPC.GetAbility(myHero, "special_bonus_unique_lion_4")
					local specialCheck = false
						if specialBonus and Ability.GetLevel(specialBonus) > 0 then
							specialCheck = true
						end
					if not specialCheck then
						Ability.CastTarget(W, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return
					else
						local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 620, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 310)
						if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, Ability.GetCastRange(W), 0) then
							Ability.CastPosition(W, bestPos)
							AIO_Umbrella.lastTick = os.clock() + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
							return
						end
					end
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q) - 50) then
					local pred = 0.3 + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1600) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predPos = AIO_Umbrella.castLinearPrediction(myHero, enemy, pred)
					local predPosAdjusted = Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(200)

					local hexMod = NPC.GetModifier(enemy, "modifier_lion_voodoo")
					local dieTime = 0
						if hexMod then
							dieTime = Modifier.GetDieTime(hexMod)
						end

					if dieTime > 0 then
						local timingOffset = ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() - 125) / 1600
						if dieTime - GameRules.GetGameTime() <= 0.35 + timingOffset then
							Ability.CastPosition(Q, predPosAdjusted)
							AIO_Umbrella.lastTick = os.clock() + 0.3
							return
						end
					else
						Ability.CastPosition(Q, predPosAdjusted)
						AIO_Umbrella.lastTick = os.clock() + 0.3
						return
					end
				end	
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.WDCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroWD) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local E = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroWDBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroWDBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroWDBlinkRange))))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.35
					return
				end

				if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(E)) then
					local pred = 0.4 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(E, AIO_Umbrella.castPrediction(myHero, enemy, pred))
					AIO_Umbrella.lastTick = os.clock() + 0.35
					return
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.SSCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSS) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
	local W = NPC.GetAbilityByIndex(myHero, 1)
 	local E = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroSSBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroSSBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroSSBlinkRange))))
					return
				end
			end	

			if os.clock() > AIO_Umbrella.lastTick then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.05
					return
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					AIO_Umbrella.lastTick = os.clock() + 0.3
					return
				end

				if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(E)) then
					local hexMod = NPC.GetModifier(enemy, "modifier_shadow_shaman_voodoo")
					local dieTime = 0
						if hexMod then
							dieTime = Modifier.GetDieTime(hexMod)
						end
					if dieTime > 0 then
						if dieTime - GameRules.GetGameTime() <= 0.45 then
							Ability.CastTarget(E, enemy)
							AIO_Umbrella.lastTick = os.clock() + 0.3
							return
						end
					else
						Ability.CastTarget(E, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.3
						return
					end
				end
			end
		end

		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function AIO_Umbrella.clockwerkCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroClock) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end
	
	local BatteryAssault = NPC.GetAbilityByIndex(myHero, 0)
	local PowerCogs = NPC.GetAbilityByIndex(myHero, 1)
	local RocketFlair = NPC.GetAbilityByIndex(myHero, 2)
	local HookShot = NPC.GetAbility(myHero, "rattletrap_hookshot")

	local Blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local myMana = NPC.GetMana(myHero)
	
	AIO_Umbrella.itemUsage(myHero, enemy)

	local cogsTargeter
	if NPC.IsRunning(enemy) then
		cogsTargeter = 100
	else
		cogsTargeter = 200
	end

	if AIO_Umbrella.clockwerkHookshotChecker(myHero, myMana, enemy, HookShot) == true then
		AIO_Umbrella.clockwerkHookUpValue = true
	else
		AIO_Umbrella.clockwerkHookUpValue = false
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, cogsTargeter) then
			if HookShot and Ability.IsCastable(HookShot, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(HookShot)) and AIO_Umbrella.clockwerkHookUpValue == true then
				local hookshotPrediction = Ability.GetCastPoint(HookShot) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / Ability.GetLevelSpecialValueFor(HookShot, "speed")) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(HookShot, AIO_Umbrella.castLinearPrediction(myHero, enemy, hookshotPrediction))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		else
			if PowerCogs and Ability.IsCastable(PowerCogs, myMana) then 
				Ability.CastNoTarget(PowerCogs)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.2) and BatteryAssault and Ability.IsCastable(BatteryAssault, myMana) then 
				Ability.CastNoTarget(BatteryAssault)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.3) and Blademail and Ability.IsCastable(Blademail, myMana) then 
				Ability.CastNoTarget(Blademail)
				return
			end			
			if AIO_Umbrella.SleepReady(0.3) and RocketFlair and Ability.IsCastable(RocketFlair, myMana) then 
				Ability.CastPosition(RocketFlair, Entity.GetAbsOrigin(enemy))
				return 
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function AIO_Umbrella.clockwerkHookshotChecker(myHero, myMana, enemy, HookShot)

	if not myHero then return false end
	if not enemy then return false end

	if not HookShot then return false end
		if not Ability.IsReady(HookShot) or not Ability.IsCastable(HookShot, myMana) then return false end

	local latchRadius = 135
	local distance = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() - 125
		if distance < 75 then return false end
		if distance + 150 > Ability.GetCastRange(HookShot) then return false end

	if #Entity.GetUnitsInRadius(myHero, 125, Enum.TeamType.TEAM_BOTH) > 0 then return false end

	for i = 2, math.floor(distance / latchRadius) do
		local checkVec = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized()
		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i*latchRadius)
		if #NPCs.InRadius(checkPos, latchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH) > 0 then
			return false
		end
	end

	return true
			
end

function AIO_Umbrella.clockwerkDrawHookIndicator(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroClockDrawIndicator) then return end
	
	if AIO_Umbrella.clockwerkHookUpValue == false then return end

	local enemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if visible then
		Renderer.SetDrawColor(50,205,50,255)
		Renderer.DrawText(AIO_Umbrella.font, x-40, y-80, "hookable", 0)
	end
		
end

function AIO_Umbrella.huskarCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroHuskar) then return end

	local burningspear = NPC.GetAbilityByIndex(myHero, 1)
	local innerVitality = NPC.GetAbilityByIndex(myHero, 0)
	local lifeBreak = NPC.GetAbility(myHero, "huskar_life_break")

	local myMana = NPC.GetMana(myHero)

	local Blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	AIO_Umbrella.itemUsage(myHero, enemy)

	local attackRange = NPC.GetAttackRange(myHero)
	local lifeBreakRange = Ability.GetCastRange(lifeBreak)

	if enemy and Menu.IsKeyDown(AIO_Umbrella.optionHeroHuskarHarassKey) then
		if burningspear and Ability.GetLevel(burningspear) > 0 then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			Engine.ExecuteCommand("dota_range_display " .. attackRange)
		end
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if enemy and Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, lifeBreakRange) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1650) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(500)))
					return
				end
			end
		else
			if innerVitality and Ability.IsCastable(innerVitality, myMana) then
				if Menu.GetValue(AIO_Umbrella.optionHeroHuskarInnerVit) > 0 then
					if Menu.GetValue(AIO_Umbrella.optionHeroHuskarInnerVit) < 2 then
						Ability.CastTarget(innerVitality, myHero)
						AIO_Umbrella.lastTick = os.clock()
						return 
					else
						if Entity.GetHealth(myHero) <= Entity.GetMaxHealth(myHero) * (Menu.GetValue(AIO_Umbrella.optionHeroHuskarHPThreshold) / 100) then
							Ability.CastTarget(innerVitality, myHero)
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			end 
			if AIO_Umbrella.SleepReady(0.2) and lifeBreak and Ability.IsCastable(lifeBreak, myMana) and Menu.IsEnabled(AIO_Umbrella.optionHeroHuskarUlt) then 
				Ability.CastTarget(lifeBreak, enemy)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.2) and Blademail and Ability.IsCastable(Blademail, myMana) then 
				Ability.CastNoTarget(Blademail)
				return
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroHuskarAutoVit) then
		AIO_Umbrella.huskarAutoBerserkersBlood(myHero, myMana, innerVitality)
	end

end

function AIO_Umbrella.huskarAutoBerserkersBlood(myHero, myMana, innerVitality)

	if not myHero then return end
	if not innerVitality then return end
		if not Ability.IsCastable(innerVitality, myMana) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local myHealth = Entity.GetHealth(myHero)

	if myHealth <= Entity.GetMaxHealth(myHero) * (Menu.GetValue(AIO_Umbrella.optionHeroHuskarHPThreshold) / 100) then
		Ability.CastTarget(innerVitality, myHero)
		return
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroHuskarAutoVitAlly) then
		local teamMatesAround = NPC.GetHeroesInRadius(myHero, 790, Enum.TeamType.TEAM_FRIEND)
		if next(teamMatesAround) ~= nil then
			for _, ally in ipairs(teamMatesAround) do
				if ally and Entity.IsHero(ally) and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
					if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
						Ability.CastTarget(innerVitality, ally)
						break
						return
					end
				end
			end
		end
	end

end

function AIO_Umbrella.skywrathCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSky) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local arcaneBolt = NPC.GetAbilityByIndex(myHero, 0)
    	local concussiveShot = NPC.GetAbilityByIndex(myHero, 1)
    	local ancientSeal = NPC.GetAbilityByIndex(myHero, 2)
    	local mysticFlare = NPC.GetAbility(myHero, "skywrath_mage_mystic_flare")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	
	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.skywrathComboTotalDamage(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)
	AIO_Umbrella.skywrathComboKillableWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroSkyHarassKey) then
		AIO_Umbrella.skywrathComboHarass(myHero, myMana, arcaneBolt)
		Engine.ExecuteCommand("dota_range_display 875")
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroSkyBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroSkyBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroSkyBlinkRange))))
					return
				end
			end

			if Menu.GetValue(AIO_Umbrella.optionHeroSkyStyle) < 1 then
				AIO_Umbrella.skywrathComboWithUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)
			else
				if AIO_Umbrella.skywrathComboSelect == true then
					AIO_Umbrella.skywrathComboWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)
				else
					AIO_Umbrella.skywrathComboWithUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)
				end
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function AIO_Umbrella.skywrathComboWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)

	if not myHero then return end
	if not enemy then return end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) and NPC.IsEntityInRange(myHero, enemy, 1550) then
		Ability.CastNoTarget(concussiveShot)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	if AIO_Umbrella.SleepReady(0.15) and arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) and NPC.IsEntityInRange(myHero, enemy, 850) then
		Ability.CastTarget(arcaneBolt, enemy)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	if AIO_Umbrella.SleepReady(0.15) and ancientSeal and Ability.IsCastable(ancientSeal, myMana) and NPC.IsEntityInRange(myHero, enemy, 685) then
		Ability.CastTarget(ancientSeal, enemy)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

end

function AIO_Umbrella.skywrathComboWithUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)

	if not myHero then return end
	if not enemy then return end

	local aghanimsBuffed = false
		if NPC.HasItem(myHero, "item_ultimate_scepter", true) or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			aghanimsBuffed = true
		end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) and NPC.IsEntityInRange(myHero, enemy, 1550) then
		Ability.CastNoTarget(concussiveShot)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	if AIO_Umbrella.SleepReady(0.15) and arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) and NPC.IsEntityInRange(myHero, enemy, 850) then
		Ability.CastTarget(arcaneBolt, enemy)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	if AIO_Umbrella.SleepReady(0.15) and ancientSeal and Ability.IsCastable(ancientSeal, myMana) and NPC.IsEntityInRange(myHero, enemy, 685) then
		Ability.CastTarget(ancientSeal, enemy)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	if AIO_Umbrella.SleepReady(0.15) and mysticFlare and Ability.IsCastable(mysticFlare, myMana) then
		if AIO_Umbrella.TargetDisableTimer(myHero, enemy) > 1.5 then
			if not aghanimsBuffed then
				Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(95))
				return
			else
				Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(175))
				return
			end
		elseif NPC.HasItem(myHero, "item_rod_of_atos", true) then
			if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) > ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1500) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) < (((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1500) + 2) then
				if not aghanimsBuffed then
					Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(95))
					return
				else
					Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(175))
					return
				end
			end
		elseif NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_HEXED) then
			if not aghanimsBuffed then
				local flarePrediction = Ability.GetCastPoint(mysticFlare) + 0.2 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(mysticFlare, AIO_Umbrella.castPrediction(myHero, enemy, flarePrediction))
			else
				Ability.CastPosition(mysticFlare, AIO_Umbrella.skywrathComboPredictDoubleUltWhileHexed(myHero, enemy))
				return
			end
		else
			if not aghanimsBuffed then
				local flarePrediction = Ability.GetCastPoint(mysticFlare) + 0.2 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(mysticFlare, AIO_Umbrella.castPrediction(myHero, enemy, flarePrediction))
			else
				Ability.CastPosition(mysticFlare, AIO_Umbrella.skywrathComboPredictDoubleUltWhileHexed(myHero, enemy))
				return
			end
		end
	end

end

function AIO_Umbrella.skywrathComboKillableWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)

	if not myHero then return end
	if not enemy then return end

	if Ability.SecondsSinceLastUse(ancientSeal) > -1 and Ability.SecondsSinceLastUse(ancientSeal) < Ability.GetCooldownLength(arcaneBolt) + 0.5 then return end
	if Ability.SecondsSinceLastUse(concussiveShot) > -1 and Ability.SecondsSinceLastUse(concussiveShot) < Ability.GetCooldownLength(arcaneBolt) + 0.5 then return end
	if Ability.SecondsSinceLastUse(arcaneBolt) > -1 and Ability.SecondsSinceLastUse(arcaneBolt) < Ability.GetCooldownLength(arcaneBolt) + 0.5 then return end

	local totalDamage = 0
	local veilAmp = 0
	local silenceAmp = 0
	local ebladeAmp = 0
	local reqMana = 0

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if veil and Ability.IsCastable(veil, myMana) then
		veilAmp = 0.25
		reqMana = reqMana + Ability.GetManaCost(veil)
	end	

	if ancientSeal and Ability.IsCastable(ancientSeal, myMana) then
		silenceAmp = (Ability.GetLevel(ancientSeal) * 5 + 30) / 100
		reqMana = reqMana + Ability.GetManaCost(ancientSeal)
	end

	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local ebladedamage = Hero.GetIntellectTotal(myHero) * 2 + 75
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (ebladedamage + ebladedamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		ebladeAmp = 0.4
		reqMana = reqMana + Ability.GetManaCost(eBlade)
	end	

	if dagon and Ability.IsCastable(dagon, Ability.GetManaCost(dagon)) then
		local dagondmg = Ability.GetLevelSpecialValueFor(dagon, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (dagondmg + dagondmg * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(dagon)
	end
                
	if arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) then
		local boltdamage = Ability.GetLevelSpecialValueFor(arcaneBolt, "bolt_damage") + Hero.GetIntellectTotal(myHero) * 1.6
		if Ability.GetLevel(arcaneBolt) < 3 then
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt)                    
		else
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) * 2
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt) * 2
		end
	end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) then
		local slowdamage = Ability.GetLevelSpecialValueFor(concussiveShot, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (slowdamage + slowdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(concussiveShot)
	end

	if reqMana < NPC.GetMana(myHero) and Entity.GetHealth(enemy) < totalDamage and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		AIO_Umbrella.skywrathComboSelect = true
	else		
		AIO_Umbrella.skywrathComboSelect = false
	end

end

function AIO_Umbrella.skywrathComboTotalDamage(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)

	if not myHero then return end
	if not enemy then return end
	if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end 

	local totalDamage = 0
	local totalDamageUlt = 0
	local veilAmp = 0
	local silenceAmp = 0
	local ebladeAmp = 0
	local reqMana = 0
	local reqManaUlt = 0

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if veil and Ability.IsCastable(veil, myMana) then
		veilAmp = 0.25
		reqMana = reqMana + Ability.GetManaCost(veil)
	end	

	if ancientSeal and Ability.IsCastable(ancientSeal, myMana) then
		silenceAmp = (Ability.GetLevel(ancientSeal) * 5 + 30) / 100
		reqMana = reqMana + Ability.GetManaCost(ancientSeal)
	end

	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local ebladedamage = Hero.GetIntellectTotal(myHero) * 2 + 75
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (ebladedamage + ebladedamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		ebladeAmp = 0.4
		reqMana = reqMana + Ability.GetManaCost(eBlade)
	end	

	if dagon and Ability.IsCastable(dagon, Ability.GetManaCost(dagon)) then
		local dagondmg = Ability.GetLevelSpecialValueFor(dagon, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (dagondmg + dagondmg * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(dagon)
	end
                
	if arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) then
		local boltdamage = Ability.GetLevelSpecialValueFor(arcaneBolt, "bolt_damage") + Hero.GetIntellectTotal(myHero) * 1.6
		if Ability.GetLevel(arcaneBolt) < 3 then
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt)                    
		else
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) * 2
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt) * 2
		end
	end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) then
		local slowdamage = Ability.GetLevelSpecialValueFor(concussiveShot, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (slowdamage + slowdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(concussiveShot)
	end

	if mysticFlare and Ability.IsCastable(mysticFlare, myMana) then
		local mysticDamage
		if atos and Ability.IsCastable(atos, myMana) then
			mysticDamage = Ability.GetLevelSpecialValueFor(mysticFlare, "damage") * 2 / 2.4
		end
		if not atos or (atos and not Ability.IsCastable(atos, myMana)) then
			mysticDamage = Ability.GetLevelSpecialValueFor(mysticFlare, "damage") * 1 / 2.4
		end
		totalDamageUlt = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (mysticDamage + mysticDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqManaUlt = reqMana + Ability.GetManaCost(mysticFlare)
	else
		totalDamageUlt = totalDamage
	end

	if reqManaUlt > NPC.GetMana(myHero) and reqMana < NPC.GetMana(myHero) then
		totalDamageUlt = totalDamage
	end

	if reqMana < NPC.GetMana(myHero) then
		AIO_Umbrella.skywrathDMGwithoutUlt = totalDamage
		AIO_Umbrella.skywrathDMGwithUlt = totalDamageUlt
	end

end

function AIO_Umbrella.skywrathComboDrawDamage(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSkyDrawDMG) then return end
	
	if AIO_Umbrella.skywrathDMGwithoutUlt == 0 then return end
	if AIO_Umbrella.skywrathDMGwithUlt == 0 then return end

	local enemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if AIO_Umbrella.skywrathDMGwithoutUlt > 0 and AIO_Umbrella.skywrathDMGwithUlt > 0 then
		if visible then
			if Entity.GetHealth(enemy) > AIO_Umbrella.skywrathDMGwithoutUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(AIO_Umbrella.skywrathFont, x-50, y-90, "DMG w/o Ult: " .. math.floor(AIO_Umbrella.skywrathDMGwithoutUlt), 0)
			if Entity.GetHealth(enemy) > AIO_Umbrella.skywrathDMGwithUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(AIO_Umbrella.skywrathFont, x-50, y-75, "DMG w/ Ult: " .. math.floor(AIO_Umbrella.skywrathDMGwithUlt), 0)
		end
	end		

end

function AIO_Umbrella.skywrathComboHarass(myHero, myMana, arcaneBolt)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSkyHarass) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not arcaneBolt then return end
		if not Ability.IsCastable(arcaneBolt, myMana) then return end

	for _, hero in ipairs(NPC.GetHeroesInRadius(myHero, 875, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
			if Entity.IsAlive(hero) then
        			Ability.CastTarget(arcaneBolt, hero)
				break
        			return
			end
      		end		
	end	

end

function AIO_Umbrella.skywrathComboPredictDoubleUltWhileHexed(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy)
    	local enemyOrigin = NPC.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)

	if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin + enemyRotation:GetForward():Normalized():Scaled(175)
			else return enemyOrigin:__add(enemyRotation:GetForward():Normalized():Scaled(AIO_Umbrella.GetMoveSpeed(enemy) * (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING) + 0.15) + 175))
			end
	end
end

function AIO_Umbrella.magnusCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroMagnus) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local shockwave = NPC.GetAbilityByIndex(myHero, 0)
    	local empower = NPC.GetAbilityByIndex(myHero, 1)
    	local skewer = NPC.GetAbilityByIndex(myHero, 2)
	local reversePolarity = NPC.GetAbility(myHero, "magnataur_reverse_polarity")

	local myMana = NPC.GetMana(myHero)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.magnusAutoUlt(myHero, myMana, skewer, reversePolarity, shockwave, blink, refresher)
	AIO_Umbrella.magnusSkewerCombo(myHero, myMana, enemy, skewer, blink)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true and not Menu.IsKeyDown(AIO_Umbrella.optionHeroMagnuscomboKeyAltSkewer) and not Menu.IsKeyDown(AIO_Umbrella.optionHeroMagnuscomboKeyAltRP) then
		if not NPC.IsEntityInRange(myHero, enemy, 600) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end
			if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusInitiateSkewer) then
				if not blink or (blink and not Ability.IsReady(blink)) then
					if skewer and Ability.IsCastable(skewer, myMana) then
						if NPC.IsEntityInRange(myHero, enemy, Ability.GetLevelSpecialValueFor(skewer, "range")) then
							Ability.CastPosition(skewer, Entity.GetAbsOrigin(enemy))
							return
						end
					end
				end
			end
		end

		if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
			AIO_Umbrella.magnusAutoEmpower(myHero)
			return
		end
		if shockwave and Ability.IsCastable(shockwave, myMana) and Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusShockwaveInCombo) then
			if NPC.IsEntityInRange(myHero, enemy, 800) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local shockwavePrediction = Ability.GetCastPoint(shockwave) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1050) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(shockwave, AIO_Umbrella.castLinearPrediction(myHero, enemy, shockwavePrediction))
				return
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Menu.IsKeyDown(AIO_Umbrella.optionHeroMagnuscomboKeyAltSkewer) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if blink and not NPC.IsEntityInRange(myHero, enemy, 125) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1120) then
					if Menu.GetValue(AIO_Umbrella.optionHeroMagnusJump) == 0 then
						AIO_Umbrella.magnusLastPos = Entity.GetAbsOrigin(myHero)
						local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D()
							if distance > 1100 then
								distance = 1100
							end
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(distance + 55))
						return
					else
						AIO_Umbrella.magnusLastPos = Entity.GetAbsOrigin(myHero)
						local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 280, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 140)
						if bestPos ~= nil then
							local distance = (bestPos - Entity.GetAbsOrigin(myHero)):Length2D()
								if distance > 1100 then
									distance = 1100
								end
							Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (bestPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(distance + 55))
							return
						end
					end
				end
			end
		else
			if skewer and Ability.IsCastable(skewer, myMana) then
				if Menu.GetValue(AIO_Umbrella.optionHeroMagnusReturn) == 0 then
					if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.25 then
						Ability.CastPosition(skewer, AIO_Umbrella.magnusLastPos)
						return
					else
						local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(math.floor(Ability.GetLevelSpecialValueFor(skewer, "range")*0.9))
						Ability.CastPosition(skewer, pos)
						return
					end
				else
					local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(math.floor(Ability.GetLevelSpecialValueFor(skewer, "range")*0.9))
					Ability.CastPosition(skewer, pos)
					return
				end
			end
		end

		if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
			AIO_Umbrella.magnusAutoEmpower(myHero)
			return
		end
		if shockwave and Ability.IsCastable(shockwave, myMana) and Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusShockwaveInCombo) then
			if NPC.IsEntityInRange(myHero, enemy, 800) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local shockwavePrediction = Ability.GetCastPoint(shockwave) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1050) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(shockwave, AIO_Umbrella.castLinearPrediction(myHero, enemy, shockwavePrediction))
				return
			end
		end

	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
					
	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Menu.IsKeyDown(AIO_Umbrella.optionHeroMagnuscomboKeyAltRP) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		local gapCloser = blink
			if gapCloser and not Ability.IsReady(gapCloser) then
				if Ability.SecondsSinceLastUse(gapCloser) > 1.5 then
					if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusInitiateSkewer) then
						gapCloser = skewer
					end
				end
			end
			if not gapCloser then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusInitiateSkewer) then
					gapCloser = skewer
				end
			end
		local gapCloserRange = 1150
			if gapCloser then
				if Ability.GetName(gapCloser) == "magnataur_skewer" then
					gapCloserRange = Ability.GetLevelSpecialValueFor(gapCloser, "range") - 25
				end
			end

		if not NPC.IsEntityInRange(myHero, enemy, 400) then
			if gapCloser and Ability.IsCastable(gapCloser, myMana) then
				local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 820, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 410)
				if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, gapCloserRange, 0) then
					if Ability.IsCastable(reversePolarity, myMana) and not Ability.IsInAbilityPhase(reversePolarity) then
						if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
							AIO_Umbrella.magnusAutoEmpower(myHero)
							return
						end
						if Ability.IsReady(gapCloser) and Ability.IsCastable(gapCloser, myMana) then
							AIO_Umbrella.magnusLastPos = Entity.GetAbsOrigin(myHero)
							Ability.CastPosition(gapCloser, bestPos)
							return
						end
					end
				end
			end
		else
			if reversePolarity and Ability.IsCastable(reversePolarity, myMana) then
				if Menu.GetValue(AIO_Umbrella.optionHeroMagnusReturn) == 0 then
					if not AIO_Umbrella.AmIFacingPos(myHero, AIO_Umbrella.magnusLastPos, 15) and gapCloser and Ability.GetName(gapCloser) == "item_blink" and Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusSkewerInCombo) then
						NPC.MoveTo(myHero, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.magnusLastPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5), false, false)
						return
					else
						Ability.CastNoTarget(reversePolarity)
						return
					end
				end
				if Menu.GetValue(AIO_Umbrella.optionHeroMagnusReturn) == 1 then
					if not AIO_Umbrella.AmIFacingPos(myHero, Input.GetWorldCursorPos(), 15) and gapCloser and Ability.GetName(gapCloser) == "item_blink" and Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusSkewerInCombo) then
						NPC.MoveTo(myHero, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5), false, false)
						return
					else
						Ability.CastNoTarget(reversePolarity)
						return
					end
				end
			end
			if reversePolarity and not Ability.IsReady(reversePolarity) then
				if gapCloser and Ability.GetName(gapCloser) == "item_blink" and Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusSkewerInCombo) then
					if Ability.SecondsSinceLastUse(reversePolarity) > -1 and Ability.SecondsSinceLastUse(reversePolarity) < 1.5 then
						if skewer and Ability.IsCastable(skewer, myMana) and not Ability.IsReady(reversePolarity) and (not refresher or (refresher and Ability.IsReady(refresher))) then
							if Menu.GetValue(AIO_Umbrella.optionHeroMagnusReturn) == 0 then
								Ability.CastPosition(skewer, AIO_Umbrella.magnusLastPos)
								return
							else
								local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(math.floor(Ability.GetLevelSpecialValueFor(skewer, "range")*0.9))
								Ability.CastPosition(skewer, pos)
								return
							end
						end
					end
				end
				if shockwave and Ability.IsCastable(shockwave, myMana) and Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusShockwaveInCombo) then
					Ability.CastPosition(shockwave, Entity.GetAbsOrigin(enemy))
					return
				end
				if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusComboRefresher) then
					if refresher and Ability.IsCastable(refresher, myMana) and myMana > (Ability.GetManaCost(reversePolarity) + Ability.GetManaCost(refresher)) then
						local stunTime = Ability.GetLevelSpecialValueForFloat(reversePolarity, "hero_stun_duration")
						if Ability.SecondsSinceLastUse(reversePolarity) > (stunTime - 0.5) and Ability.SecondsSinceLastUse(reversePolarity) < stunTime then
							Ability.CastNoTarget(refresher)
							Ability.CastNoTarget(reversePolarity)
							return
						end
					end
				end
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	

	


end

function AIO_Umbrella.magnusSkewerCombo(myHero, myMana, enemy, skewer, blink)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusSkewerCombo) then return end

	if not blink then return end

	if not skewer then return end
		if not Ability.IsCastable(skewer, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroMagnusSkewerComboKey) and Entity.GetHealth(enemy) > 0 then
		if NPC.IsEntityInRange(myHero, enemy, 1100) then
			if blink and Ability.IsReady(blink) then
				AIO_Umbrella.magnusLastPos = Entity.GetAbsOrigin(myHero)
				local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D()
					if distance > 1100 then
						distance = 1100
					end
				Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(distance + 95))
				return
			end
			if Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.25 then
				Ability.CastPosition(skewer, AIO_Umbrella.magnusLastPos)
				return
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end
			
function AIO_Umbrella.magnusAutoEmpower(myHero)

	if not myHero then return end
	local myMana = NPC.GetMana(myHero)

	local empower = NPC.GetAbilityByIndex(myHero, 1)
		if not empower then return end
		if not Ability.IsCastable(empower, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_magnataur_empower") then return end

	Ability.CastTarget(empower, myHero)
	return
	
end

function AIO_Umbrella.magnusAutoUlt(myHero, myMana, skewer, reversePolarity, shockwave, blink, refresher)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusAutoUlt) then return end

	if not reversePolarity then return end

	local shivas = NPC.GetItem(myHero, "item_shivas_guard", true)

	local gapCloser = blink
		if gapCloser and not Ability.IsReady(gapCloser) then
			if Ability.SecondsSinceLastUse(gapCloser) > 1.5 then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusAutoUltSkewer) then
					gapCloser = skewer
				end
			end
		end
		if not gapCloser then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusAutoUltSkewer) then
				gapCloser = skewer
			end
		end
		
	if not gapCloser then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end

	local reverseRadius = 410

	local gapCloserRange = 1150
		if Ability.GetName(gapCloser) == "magnataur_skewer" then
			gapCloserRange = Ability.GetLevelSpecialValueFor(gapCloser, "range") - 25
		end

	local tempTableHittableTargets = {}
	for _, targets in ipairs(Entity.GetHeroesInRadius(myHero, gapCloserRange + reverseRadius, Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = AIO_Umbrella.targetChecker(targets)
			if target then
				if #Entity.GetHeroesInRadius(target, reverseRadius, Enum.TeamType.TEAM_FRIEND) > -1 then
					table.insert(tempTableHittableTargets, target)
				end
			end
		end
	end

	if #tempTableHittableTargets >= 1 then
		local bestPos = AIO_Umbrella.getBestPosition(tempTableHittableTargets, reverseRadius)
		if bestPos ~= nil and #Heroes.InRadius(bestPos, reverseRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(AIO_Umbrella.optionHeroMagnusAutoUltCount) then
			if NPC.IsPositionInRange(myHero, bestPos, gapCloserRange, 0) then
				if Ability.IsCastable(reversePolarity, myMana) and not Ability.IsInAbilityPhase(reversePolarity) then
					if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
						AIO_Umbrella.magnusAutoEmpower(myHero)
						return
					end
					if Ability.IsReady(gapCloser) and Ability.IsCastable(gapCloser, myMana) then
						AIO_Umbrella.magnusLastPos = Entity.GetAbsOrigin(myHero)
						Ability.CastPosition(gapCloser, bestPos)
						return
					end
					if not AIO_Umbrella.AmIFacingPos(myHero, AIO_Umbrella.magnusLastPos, 15) and Ability.GetName(gapCloser) == "item_blink" then
						NPC.MoveTo(myHero, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.magnusLastPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5), false, false)
						return
					else
						Ability.CastNoTarget(reversePolarity)
						return
					end
				else
					if Ability.GetName(gapCloser) == "item_blink" then
						if Ability.SecondsSinceLastUse(reversePolarity) > -1 and Ability.SecondsSinceLastUse(reversePolarity) < 1.5 then
							if shivas and Ability.IsCastable(shivas, myMana) then
								Ability.CastNoTarget(shivas)
								return
							end
							if skewer and Ability.IsCastable(skewer, myMana) and not Ability.IsReady(reversePolarity) and (not refresher or (refresher and Ability.IsReady(refresher))) then
								Ability.CastPosition(skewer, AIO_Umbrella.magnusLastPos)
								return
							end
							if shockwave and Ability.IsCastable(shockwave, myMana) then
								Ability.CastPosition(shockwave, Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(50), true)
								return
							end
							AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, Entity.GetAbsOrigin(myHero))
							return
						end
					else
						if Ability.SecondsSinceLastUse(reversePolarity) > -1 and Ability.SecondsSinceLastUse(reversePolarity) < 1.5 then
							if shivas and Ability.IsCastable(shivas, myMana) then
								Ability.CastNoTarget(shivas)
								return
							end
							if shockwave and Ability.IsCastable(shockwave, myMana) and not Ability.IsReady(skewer) then
								Ability.CastPosition(shockwave, Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(50), true)
								return
							end
							AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, Entity.GetAbsOrigin(myHero))
							return
						end
					end
					if Menu.IsEnabled(AIO_Umbrella.optionHeroMagnusAutoUltRefresher) then
						if refresher and Ability.IsCastable(refresher, myMana) and myMana > (Ability.GetManaCost(reversePolarity) + Ability.GetManaCost(refresher)) then
							local stunTime = Ability.GetLevelSpecialValueForFloat(reversePolarity, "hero_stun_duration")
							if Ability.SecondsSinceLastUse(reversePolarity) > (stunTime - 0.5) and Ability.SecondsSinceLastUse(reversePolarity) < stunTime then
								Ability.CastNoTarget(refresher)
								Ability.CastNoTarget(reversePolarity)
								return
							end
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.AmIFacingPos(myHero, pos, allowedDeviation)

	if not myHero then return false end

	local myPos = Entity.GetAbsOrigin(myHero)
	local myRotation = Entity.GetRotation(myHero):GetForward():Normalized()

	local baseVec = (pos - myPos):Normalized()

	local tempProcessing = baseVec:Dot2D(myRotation) / (baseVec:Length2D() * myRotation:Length2D())
		if tempProcessing > 1 then
			tempProcessing = 1
		end	

	local checkAngleRad = math.acos(tempProcessing)
	local checkAngle = (180 / math.pi) * checkAngleRad

	if checkAngle < allowedDeviation then
		return true
	end

	return false

end

function AIO_Umbrella.DazzleHelper(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroDazzle) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local poisonTouch = NPC.GetAbilityByIndex(myHero, 0)
    	local grave = NPC.GetAbilityByIndex(myHero, 1)
    	local shadowWave = NPC.GetAbilityByIndex(myHero, 2)
	local weave = NPC.GetAbility(myHero, "dazzle_weave")

	local myMana = NPC.GetMana(myHero)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.DazzleHelperAutoGrave(myHero, myMana, grave)
	AIO_Umbrella.DazzleHelperAutoWeave(myHero, myMana, weave)
	AIO_Umbrella.DazzleHelperAutoHeal(myHero, myMana, shadowWave)
	AIO_Umbrella.DazzleHelperHealKillsteal(myHero, myMana, shadowWave)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then

		if not NPC.IsEntityInRange(myHero, enemy, 999) then
			if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1550) then
				Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(400)))
				return
			end
		end

		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if poisonTouch and Ability.IsCastable(poisonTouch, myMana) then
				Ability.CastTarget(poisonTouch, enemy)
				return
			end
		end

	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function AIO_Umbrella.DazzleHelperHealKillsteal(myHero, myMana, shadowWave)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroDazzleHealKS) then return end

	if not shadowWave then return end
		if not Ability.IsCastable(shadowWave, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local bounces = 2 + Ability.GetLevel(shadowWave)
	local bounceDamage = Ability.GetLevelSpecialValueFor(shadowWave, "damage")
		if NPC.HasAbility(myHero, "special_bonus_unique_dazzle_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_dazzle_2")) > 0 then
				bounceDamage = bounceDamage + 60
			end
		end

	local waveRange = Ability.GetCastRange(shadowWave) + NPC.GetCastRangeBonus(myHero) - 10

	for _, targets in ipairs(Entity.GetHeroesInRadius(myHero, waveRange, Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = AIO_Umbrella.targetChecker(targets)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
					local targetHP = Entity.GetHealth(target) + NPC.GetHealthRegen(target)
					local unitsAround = #Entity.GetUnitsInRadius(target, 175, Enum.TeamType.TEAM_ENEMY)
						if unitsAround > bounces then
							unitsAround = bounces
						end
					local waveDamage = unitsAround * bounceDamage
					local waveTrueDamage = (1 - NPC.GetMagicalArmorValue(target)) * (waveDamage + waveDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
					if targetHP < waveTrueDamage then
						for _, v in ipairs(Entity.GetUnitsInRadius(target, 175, Enum.TeamType.TEAM_ENEMY)) do
							if v then
								if NPC.IsEntityInRange(myHero, v, waveRange) then
									Ability.CastTarget(shadowWave, v)
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
					
end

function AIO_Umbrella.DazzleHelperAutoHeal(myHero, myMana, shadowWave)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroDazzleAutoHeal) then return end

	if not shadowWave then return end
		if not Ability.IsCastable(shadowWave, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	local waveRange = Ability.GetCastRange(shadowWave) + NPC.GetCastRangeBonus(myHero) - 10

	if AIO_Umbrella.TargetIsInvulnarable(myHero, myHero) <= 0 then
		if myHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroDazzleAutoHealHP) then
			Ability.CastTarget(shadowWave, myHero)
			return
		end
	end

	for _, ally in ipairs(Entity.GetHeroesInRadius(myHero, waveRange, Enum.TeamType.TEAM_FRIEND)) do
		if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) and AIO_Umbrella.TargetIsInvulnarable(myHero, ally) <= 0 and AIO_Umbrella.TargetIsInvulnarable(myHero, myHero) <= 0 then
			local allyHPperc = (Entity.GetHealth(ally) / Entity.GetMaxHealth(ally)) * 100
			if allyHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroDazzleAutoHealHP) then
				Ability.CastTarget(shadowWave, ally)
				break
				return
			end
		end
	end

end

function AIO_Umbrella.DazzleHelperAutoWeave(myHero, myMana, weave)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroDazzleAutoWeave) then return end

	if not weave then return end
		if not Ability.IsCastable(weave, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local weaveRange = Ability.GetCastRange(weave) + NPC.GetCastRangeBonus(myHero) - 10
	local weaveRadius = 550

	local tempTableHittableTargets = {}
	for _, targets in ipairs(Entity.GetHeroesInRadius(myHero, 2000, Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = AIO_Umbrella.targetChecker(targets)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					if NPC.IsEntityInRange(myHero, target, weaveRange + weaveRadius) then
						if #Entity.GetHeroesInRadius(target, weaveRadius, Enum.TeamType.TEAM_FRIEND) > -1 then
							table.insert(tempTableHittableTargets, target)
						end
					end
				end
			end
		end
	end

	if #tempTableHittableTargets >= 1 then
		local bestPos = AIO_Umbrella.getBestPosition(tempTableHittableTargets, weaveRadius)
		if bestPos ~= nil and #Heroes.InRadius(bestPos, weaveRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(AIO_Umbrella.optionHeroDazzleAutoWeaveCount) then
			if NPC.IsPositionInRange(myHero, bestPos, weaveRange, 0) then
				Ability.CastPosition(weave, bestPos)
				return
			end
		end
	end

end

function AIO_Umbrella.DazzleHelperAutoGrave(myHero, myMana, grave)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroDazzleAutoGrave) then return end

	if not grave then return end
		if not Ability.IsCastable(grave, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	local graveRange = Ability.GetCastRange(grave) + NPC.GetCastRangeBonus(myHero) - 10

	if AIO_Umbrella.TargetIsInvulnarable(myHero, myHero) <= 0 then
		if myHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroDazzleHP) then
			if AIO_Umbrella.IsAttackedByDangerousSpell(myHero, myHero, 1000) == true then
				Ability.CastTarget(grave, myHero)
				return
			else
				for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
					if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
						if NPC.IsAttacking(v) then
							if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
								if NPC.FindFacingNPC(v) == myHero then
									Ability.CastTarget(grave, myHero)
									break
									return
								end
							end
						else
							if myHPperc <= 7 then
								if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
									if NPC.FindFacingNPC(v) == myHero then
										Ability.CastTarget(grave, myHero)
										break
										return
									end
								end
							end
						end	
					end	
				end
			end	
		end
	end

	for _, ally in ipairs(Entity.GetHeroesInRadius(myHero, graveRange, Enum.TeamType.TEAM_FRIEND)) do
		if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) and AIO_Umbrella.TargetIsInvulnarable(myHero, ally) <= 0 and AIO_Umbrella.TargetIsInvulnarable(myHero, myHero) <= 0 then
			local allyHPperc = (Entity.GetHealth(ally) / Entity.GetMaxHealth(ally)) * 100
			if allyHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroDazzleHP) then
				if AIO_Umbrella.IsAttackedByDangerousSpell(myHero, ally, 800) == true then
					Ability.CastTarget(grave, ally)
					break
					return
				else
					for _, v in ipairs(Entity.GetHeroesInRadius(ally, 800, Enum.TeamType.TEAM_ENEMY)) do
						if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
							if NPC.IsAttacking(v) then
								if NPC.IsEntityInRange(ally, v, NPC.GetAttackRange(v) + 140) then
									if NPC.FindFacingNPC(v) == ally then
										Ability.CastTarget(grave, ally)
										break
										return
									end
								end
							else
								if allyHPperc <= 7 then
									if NPC.IsEntityInRange(ally, v, NPC.GetAttackRange(v) + 140) then
										if NPC.FindFacingNPC(v) == ally then
											Ability.CastTarget(grave, ally)
											break
											return
										end
									end
								end
							end	
						end
					end
				end
			else
				if NPC.HasModifier(ally, "modifier_necrolyte_reapers_scythe") then
					if allyHPperc < 60 then
						Ability.CastTarget(grave, ally)
						break
						return
					end
				end
			end
		end
	end

end

function AIO_Umbrella.IsAttackedByDangerousSpell(myHero, target, searchRange)

	if not myHero then return false end
	if not target then return false end
	if AIO_Umbrella.TargetIsInvulnarable(myHero, target) > 0 then return false end

	for _, enemy in ipairs(Entity.GetHeroesInRadius(target, searchRange, Enum.TeamType.TEAM_ENEMY)) do
		if enemy and Entity.IsHero(enemy) and not Entity.IsDormant(enemy) and not NPC.IsIllusion(enemy) then
			if NPC.FindFacingNPC(enemy) == target then
				for _, info in ipairs(AIO_Umbrella.AbilityList) do
					if info[1] == NPC.GetUnitName(enemy) then
						if info[3] == "nuke" or info[3] == "disable" then
							if NPC.HasAbility(enemy, info[2]) then
								if Ability.IsInAbilityPhase(NPC.GetAbility(enemy, info[2])) then
									local castRange = Ability.GetCastRange(NPC.GetAbility(enemy, info[2])) + NPC.GetCastRangeBonus(enemy) + 25
									if NPC.IsEntityInRange(enemy, target, castRange) then
										return true
									end
								end
							end
						end
					end
				end
			end
		end
	end

	return false

end

function AIO_Umbrella.SFCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSF) then return end

	local razeShort = NPC.GetAbilityByIndex(myHero, 0)
    	local razeMid = NPC.GetAbilityByIndex(myHero, 1)
    	local razeLong = NPC.GetAbilityByIndex(myHero, 2)
	local requiem = NPC.GetAbility(myHero, "nevermore_requiem")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local eul = NPC.GetItem(myHero, "item_cyclone", true)

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.SFComboDrawRazeCircles(myHero)

	if enemy then
		if eul and requiem and Ability.IsCastable(requiem, myMana) then
			if Menu.IsKeyDown(AIO_Umbrella.optionHeroSFEulCombo) and Entity.GetHealth(enemy) > 0 then
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
					local possibleRange = 0.80 * NPC.GetMoveSpeed(myHero)
					if not NPC.IsEntityInRange(myHero, enemy, possibleRange) then
						if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1175 + 0.75 * possibleRange) then
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(0.75 * possibleRange)))
							return
						else
							AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
							return
						end
					else
						if NPC.IsLinkensProtected(enemy) then
							if AIO_Umbrella.ItemSleepReady(0.05) and AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
								Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), enemy)
								return
							end
						end

						if Ability.IsCastable(eul, myMana) then
							Ability.CastTarget(eul, enemy)
							return
						end
						if NPC.HasModifier(enemy, "modifier_eul_cyclone") then
							if not NPC.IsEntityInRange(myHero, enemy, 20) then
								AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
								return
							else
								local cycloneDieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone"))
								if cycloneDieTime - GameRules.GetGameTime() <= 1.66 then
									Ability.CastNoTarget(requiem)
									return
								end
							end
						end
					end	
				end
			end
		end
	end

	if enemy then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 999) then
					if Menu.IsEnabled(AIO_Umbrella.optionHeroSFBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroSFBlinkRange)) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroSFBlinkRange))))
						return
					end
				end

				if Menu.IsEnabled(AIO_Umbrella.optionHeroSFComboRaze) then
					if razeShort and Ability.IsCastable(razeShort, myMana) then
						local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(200)
						local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
						local predictedPos = AIO_Umbrella.castPrediction(myHero, enemy, razePrediction)
						local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
						if disRazePOSpredictedPOS <= 200 and not Entity.IsTurning(myHero) then
							if os.clock() - AIO_Umbrella.lastTick >= 0.55 then
								Ability.CastNoTarget(razeShort)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
					if razeMid and Ability.IsCastable(razeMid, myMana) then
						local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(450)
						local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
						local predictedPos = AIO_Umbrella.castPrediction(myHero, enemy, razePrediction)
						local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
						if disRazePOSpredictedPOS <= 200 and not Entity.IsTurning(myHero) then
							if os.clock() - AIO_Umbrella.lastTick >= 0.55 then
								Ability.CastNoTarget(razeMid)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
					if razeLong and Ability.IsCastable(razeLong, myMana) then
						local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(700)
						local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
						local predictedPos = AIO_Umbrella.castPrediction(myHero, enemy, razePrediction)
						local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
						if disRazePOSpredictedPOS <= 200 and not Entity.IsTurning(myHero) then
							if os.clock() - AIO_Umbrella.lastTick >= 0.55 then
								Ability.CastNoTarget(razeLong)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
				end
			end
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
		end
	end

end

function AIO_Umbrella.SFComboDrawRazeCircles(myHero)

	if not myHero then return end

	local curtime = GameRules.GetGameTime()	

	if Menu.IsEnabled(AIO_Umbrella.optionHeroSFDrawRazeCircle) then
		
		if AIO_Umbrella.SFcurrentParticle1 == 0 then
			local circle1 = Particle.Create("particles/econ/generic/generic_progress_meter/generic_progress_circle_b.vpcf")
			AIO_Umbrella.SFcurrentParticle1 = circle1
			Particle.SetControlPoint(circle1, 1, Vector(250, 1, 1))
			Particle.SetControlPoint(circle1, 15, Vector(0, 255, 0))
			Particle.SetControlPoint(circle1, 16, Vector(1, 0, 0))
		end
		if AIO_Umbrella.SFcurrentParticle2 == 0 then
			local circle2 = Particle.Create("particles/econ/generic/generic_progress_meter/generic_progress_circle_b.vpcf")
			AIO_Umbrella.SFcurrentParticle2 = circle2
			Particle.SetControlPoint(circle2, 1, Vector(250, 1, 1))
			Particle.SetControlPoint(circle2, 15, Vector(255, 255, 0))
			Particle.SetControlPoint(circle2, 16, Vector(1, 0, 0))
		end
		if AIO_Umbrella.SFcurrentParticle3 == 0 then
			local circle3 = Particle.Create("particles/econ/generic/generic_progress_meter/generic_progress_circle_b.vpcf")
			AIO_Umbrella.SFcurrentParticle3 = circle3
			Particle.SetControlPoint(circle3, 1, Vector(250, 1, 1))
			Particle.SetControlPoint(circle3, 15, Vector(255, 100, 0))
			Particle.SetControlPoint(circle3, 16, Vector(1, 0, 0))
		end

		if os.clock() - AIO_Umbrella.SFParticleUpdateTime >= 0.033 then
			Particle.SetControlPoint(AIO_Umbrella.SFcurrentParticle1, 0, (Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(200)))
			Particle.SetControlPoint(AIO_Umbrella.SFcurrentParticle2, 0, (Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(450)))
			Particle.SetControlPoint(AIO_Umbrella.SFcurrentParticle3, 0, (Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(700)))
			AIO_Umbrella.SFParticleUpdateTime = os.clock()
		end
			
	else
		if AIO_Umbrella.SFcurrentParticle1 > 0 then
			Particle.Destroy(AIO_Umbrella.SFcurrentParticle1)
			Particle.Destroy(AIO_Umbrella.SFcurrentParticle2)
			Particle.Destroy(AIO_Umbrella.SFcurrentParticle3)
			AIO_Umbrella.SFcurrentParticle1 = 0
			AIO_Umbrella.SFcurrentParticle2 = 0
			AIO_Umbrella.SFcurrentParticle3 = 0
		end
	end

end

function AIO_Umbrella.SFComboDrawRequiemDamage(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSFDrawReqDMG) then return end

	local enemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	local requiem = NPC.GetAbility(myHero, "nevermore_requiem")
	local myMana = NPC.GetMana(myHero)

	local stackCounter = 0
		if NPC.HasModifier(myHero, "modifier_nevermore_necromastery") then
			stackCounter = Modifier.GetStackCount(NPC.GetModifier(myHero, "modifier_nevermore_necromastery"))
		end

	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)

	local requiemDamage = Ability.GetDamage(requiem) * (math.floor(stackCounter/2))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			requiemDamage = requiemDamage + Ability.GetLevelSpecialValueForFloat(requiem, "requiem_damage_pct_scepter") * (math.floor(stackCounter/2))
		end
	local requiemTrueDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (requiemDamage + requiemDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))

	local remainingHP = math.floor(Entity.GetHealth(enemy) - requiemTrueDamage)
		if remainingHP < 0 then
			remainingHP = 0
		end

	if requiem and Ability.IsCastable(requiem, myMana) then
		if visible then
			if Entity.GetHealth(enemy) > requiemTrueDamage then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
			Renderer.DrawText(AIO_Umbrella.skywrathFont, x-60, y-70, "Full requiem hit:   " .. math.floor(requiemTrueDamage) .. "  (" .. remainingHP .. ")", 0)
		end
	end	

end

function AIO_Umbrella.WillowCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroWillow) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local maze = NPC.GetAbilityByIndex(myHero, 0)
    	local shadowRealm = NPC.GetAbilityByIndex(myHero, 1)
	local cursedCrown = NPC.GetAbilityByIndex(myHero, 2)
    	local bedlam = NPC.GetAbility(myHero, "dark_willow_bedlam")

	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local euls = NPC.GetItem(myHero, "item_cyclone", true)
	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)

	AIO_Umbrella.itemUsage(myHero, enemy)

	local comboRange = 800
		if cursedCrown then
			comboRange = Ability.GetCastRange(cursedCrown)
		end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 900) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroWillowBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroWillowBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroWillowBlinkRange))))
					return
				end
			else
				if cursedCrown and Ability.IsCastable(cursedCrown, myMana) then
					Ability.CastTarget(cursedCrown, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
				if AIO_Umbrella.SleepReady(0.1) and shadowRealm and Ability.IsCastable(shadowRealm, myMana) then
					Ability.CastNoTarget(shadowRealm)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
				if euls then
					if AIO_Umbrella.SleepReady(0.1) and Ability.IsCastable(euls, myMana) then
						Ability.CastTarget(euls, enemy)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
					if Ability.SecondsSinceLastUse(euls) > -1 and Ability.SecondsSinceLastUse(euls) < 0.5 then
						if maze and Ability.IsCastable(maze, myMana) then
							local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
							if bestPos ~= nil then
								Ability.CastPosition(maze, bestPos)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
					if bedlam and Ability.IsCastable(bedlam, myMana) then
						if NPC.IsEntityInRange(myHero, enemy, 150) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
							Ability.CastNoTarget(bedlam)
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				else
					if atos then
						if AIO_Umbrella.SleepReady(0.1) and Ability.IsCastable(atos, myMana) then
							Ability.CastTarget(atos, enemy)
							AIO_Umbrella.lastTick = os.clock()
							return
						end
						if AIO_Umbrella.SleepReady(0.1) and bedlam and Ability.IsCastable(bedlam, myMana) then
							if NPC.IsEntityInRange(myHero, enemy, 150) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastNoTarget(bedlam)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
						if NPC.HasModifier(enemy, "modifier_rod_of_atos_debuff") then
							local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_rod_of_atos_debuff"))
							if dieTime - GameRules.GetGameTime() < 0.1 then
								if AIO_Umbrella.SleepReady(0.1) and maze and Ability.IsCastable(maze, myMana) then
									local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
									if bestPos ~= nil then
										Ability.CastPosition(maze, bestPos)
										AIO_Umbrella.lastTick = os.clock()
										return
									end
								end
							end
						else
							if Ability.SecondsSinceLastUse(atos) > ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500) + 0.15 then
								if AIO_Umbrella.SleepReady(0.1) and maze and Ability.IsCastable(maze, myMana) then
									local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
									if bestPos ~= nil then
										Ability.CastPosition(maze, bestPos)
										AIO_Umbrella.lastTick = os.clock()
										return
									end
								end
							end
						end
					else
						if maze and Ability.IsCastable(maze, myMana) then
							local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
							if bestPos ~= nil then
								Ability.CastPosition(maze, bestPos)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
						if bedlam and Ability.IsCastable(bedlam, myMana) then
							if NPC.IsEntityInRange(myHero, enemy, 250) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastNoTarget(bedlam)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
						
				end
			end
		end
		if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) or NPC.HasModifier(enemy, "modifier_rod_of_atos_debuff") or NPC.HasModifier(myHero, "modifier_dark_willow_bedlam") then
			if not NPC.HasModifier(myHero, "modifier_dark_willow_shadow_realm_buff") then
				if not NPC.IsEntityInRange(myHero, enemy, 150) then
					AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
					return
				end
			else
				local creaTime = Modifier.GetCreationTime(NPC.GetModifier(myHero, "modifier_dark_willow_shadow_realm_buff"))
				if GameRules.GetGameTime() - creaTime >= 3 then
					AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
					return
				else
					if not NPC.IsEntityInRange(myHero, enemy, 150) then
						AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
						return
					end
				end
			end	
		else
			if NPC.HasModifier(myHero, "modifier_dark_willow_shadow_realm_buff") then
				local creaTime = Modifier.GetCreationTime(NPC.GetModifier(myHero, "modifier_dark_willow_shadow_realm_buff"))
				if GameRules.GetGameTime() - creaTime >= 3 then
					AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
					return
				else
					if not NPC.IsEntityInRange(myHero, enemy, 150) then
						AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
						return
					end
				end
			else	
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
				return
			end
		end
	end

end

function AIO_Umbrella.SilencerCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSilencer) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local arcaneCurse = NPC.GetAbilityByIndex(myHero, 0)
    	local glaives = NPC.GetAbilityByIndex(myHero, 1)
	local lastWord = NPC.GetAbilityByIndex(myHero, 2)
    	local globalSilence = NPC.GetAbility(myHero, "silencer_global_silence")

	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)

	local myAttackRange = NPC.GetAttackRange(myHero)

	AIO_Umbrella.SilencerAutoInterruptChan(myHero, myMana, globalSilence)
	AIO_Umbrella.itemUsage(myHero, enemy)
	
	if Menu.IsKeyDown(AIO_Umbrella.optionHeroSilencerHarassKey) then
		AIO_Umbrella.SilencerAutoHarass(myHero, myMana, myAttackRange, glaives)
		Engine.ExecuteCommand("dota_range_display " .. myAttackRange)
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 900) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroSilencerBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroSilencerBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroSilencerBlinkRange))))
					return
				end
			else
				if lastWord and Ability.IsCastable(lastWord, myMana) then
					Ability.CastTarget(lastWord, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
				if AIO_Umbrella.SleepReady(0.1) and arcaneCurse and Ability.IsCastable(arcaneCurse, myMana) then
					local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 840, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 420)
					if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, 999, 0) then
						Ability.CastPosition(arcaneCurse, bestPos)
						AIO_Umbrella.lastTick = os.clock()
						return
					else
						Ability.CastPosition(arcaneCurse, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end				
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end
		
end

function AIO_Umbrella.SilencerAutoHarass(myHero, myMana, myAttackRange, glaives)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSilencerHarass) then return end

	if not glaives then return end
		if Ability.GetLevel(glaives) < 1 then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	for _, hero in ipairs(NPC.GetHeroesInRadius(myHero, myAttackRange, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
			if Entity.IsAlive(hero) then
        			Ability.CastTarget(glaives, hero)
				break
        			return
			end
      		end		
	end

end

function AIO_Umbrella.SilencerAutoHurricane(myHero, myMana, enemy, hurricanePike)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSilencerHurricane) then return end

	if not hurricanePike then return end
		if not Ability.IsCastable(hurricanePike, myMana) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroSilencerHurricaneHP) then
		for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.IsAttacking(v) then
							Ability.CastTarget(hurricanePike, enemy)
							break
							return
						end
					end
				end
			end	
		end
	end

end

function AIO_Umbrella.SilencerAutoInterruptChan(myHero, myMana, globalSilence)

	if not myHero then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSilencerGlobal) then return end

	if not globalSilence then return end
		if not Ability.IsCastable(globalSilence, myMana) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	for i = 1, Heroes.Count() do
		local enemy = Heroes.Get(i)
		if enemy and Entity.IsHero(enemy) and not Entity.IsSameTeam(myHero, enemy) and not Entity.IsDormant(enemy) and NPC.GetUnitName(enemy) == "npc_dota_hero_enigma" and not NPC.IsIllusion(enemy) then
			if Entity.IsAlive(enemy) then
				local blackHole = NPC.GetAbility(enemy, "enigma_black_hole")
				if blackHole and Ability.IsChannelling(blackHole) then
					Ability.CastNoTarget(globalSilence)
					return
				end
			end
		end
	end

end

function AIO_Umbrella.ODCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroOD) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local arcaneOrb = NPC.GetAbilityByIndex(myHero, 0)
    	local astralPrison = NPC.GetAbilityByIndex(myHero, 1)
    	local sanityEclipse = NPC.GetAbility(myHero, "obsidian_destroyer_sanity_eclipse")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)

	local myAttackRange = NPC.GetAttackRange(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.ODKillsteal(myHero, myMana, myAttackRange, arcaneOrb, astralPrison, sanityEclipse)
	AIO_Umbrella.ODAutoPrisonAutoDisable(myHero, myMana, astralPrison)
	AIO_Umbrella.ODAutoPrisonSave(myHero, myMana, astralPrison)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroODBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroODBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroODBlinkRange))))
					return
				end
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end

end

function AIO_Umbrella.ODAutoPrisonSave(myHero, myMana, astralPrison)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroODAutoPrisonSave) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not astralPrison then return end
		if not Ability.IsCastable(astralPrison, myMana) then return end

	local prisonCastRange = Ability.GetCastRange(astralPrison) - 25

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Menu.IsEnabled(AIO_Umbrella.optionHeroODAutoPrisonSaveSelf) then
		if myHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroODAutoPrisonHP) then
			for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
				if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
					if NPC.FindFacingNPC(v) == myHero then
						if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
							if NPC.IsAttacking(v) then
								Ability.CastTarget(astralPrison, myHero)
								break
								return
							end
						end
					end
				end	
			end
		end
	end
	
	if Menu.IsEnabled(AIO_Umbrella.optionHeroODAutoPrisonSaveAlly) then
		local teamMatesAround = NPC.GetHeroesInRadius(myHero, prisonCastRange, Enum.TeamType.TEAM_FRIEND)
		if next(teamMatesAround) ~= nil then
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
					if not AIO_Umbrella.isHeroChannelling(ally) and not AIO_Umbrella.IsHeroInvisible(ally) then
						if AIO_Umbrella.IsNPCinDanger(myHero, ally) or (((Entity.GetHealth(ally) / Entity.GetMaxHealth(ally)) * 100) < Menu.GetValue(AIO_Umbrella.optionHeroODAutoPrisonHP)) then
							Ability.CastTarget(astralPrison, ally)
							break
							return
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.ODAutoPrisonAutoDisable(myHero, myMana, astralPrison)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroODAutoPrisonDefend) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not astralPrison then return end
		if not Ability.IsCastable(astralPrison, myMana) then return end

	local prisonCastRange = Ability.GetCastRange(astralPrison) - 25

	for _, heroes in ipairs(NPC.GetHeroesInRadius(myHero, prisonCastRange, Enum.TeamType.TEAM_ENEMY)) do
		if heroes and not NPC.IsDormant(heroes) and Entity.IsAlive(heroes) then
			local enemyDagger = NPC.GetItem(heroes, "item_blink", true)
			if enemyDagger and Ability.GetCooldownTimeLeft(enemyDagger) >= 9 and Ability.SecondsSinceLastUse(enemyDagger) > -1 and Ability.SecondsSinceLastUse(enemyDagger) <= 1 then
				if not NPC.HasState(heroes, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(heroes) then
					Ability.CastTarget(astralPrison, heroes)
					break
					return
				end
			end
		end
	end

end

function AIO_Umbrella.ODAutoHurricane(myHero, myMana, enemy, hurricanePike)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroODHurricane) then return end

	if not hurricanePike then return end
		if not Ability.IsCastable(hurricanePike, myMana) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroODHurricaneHP) then
		for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.IsAttacking(v) then
							Ability.CastTarget(hurricanePike, enemy)
							break
							return
						end
					end
				end
			end	
		end
	end

end

function AIO_Umbrella.ODKillsteal(myHero, myMana, myAttackRange, arcaneOrb, astralPrison, sanityEclipse)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroODKillsteal) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not (arcaneOrb and astralPrison and sanityEclipse) then return end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroODKillstealEclipse) then
		if sanityEclipse and Ability.IsCastable(sanityEclipse, myMana) then
			local tempTableHittableTargets = {}
			local tempTableKillableTargets = {}
			local sanityEclipseRadius = Ability.GetLevelSpecialValueFor(sanityEclipse, "radius")
			for _, targets in ipairs(Entity.GetHeroesInRadius(myHero, 1200, Enum.TeamType.TEAM_ENEMY)) do
				if targets then
					local target = AIO_Umbrella.targetChecker(targets)
					if target then
						if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							if NPC.IsEntityInRange(myHero, target, 690 + sanityEclipseRadius - 25) then
								if #Entity.GetHeroesInRadius(target, sanityEclipseRadius - 25, Enum.TeamType.TEAM_FRIEND) > -1 then
									table.insert(tempTableHittableTargets, target)
								end
							end
						end
					end
				end
			end

			if #tempTableHittableTargets >= 1 then
				local bestPos = AIO_Umbrella.getBestPosition(tempTableHittableTargets, (sanityEclipseRadius - 25))
				if bestPos ~= nil and #Heroes.InRadius(bestPos, (sanityEclipseRadius - 25), Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(AIO_Umbrella.optionHeroODKillstealEclipseHittable) then
					for _, v in ipairs(Heroes.InRadius(bestPos, (sanityEclipseRadius - 25), Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)) do
						local targetHP = Entity.GetHealth(v) + NPC.GetHealthRegen(v)
						local sanityEclipseDamage = (Hero.GetIntellectTotal(myHero) - Hero.GetIntellectTotal(v)) * Ability.GetLevelSpecialValueFor(sanityEclipse, "damage_multiplier")
						local sanityEclipseTrueDamage = (1 - NPC.GetMagicalArmorValue(v)) * (sanityEclipseDamage + sanityEclipseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))		
						if targetHP < sanityEclipseTrueDamage then
							table.insert(tempTableKillableTargets, v)
						end
					end
				end
			end

			if #tempTableKillableTargets >= Menu.GetValue(AIO_Umbrella.optionHeroODKillstealEclipseKillable) then
				local bestPos = AIO_Umbrella.getBestPosition(tempTableHittableTargets, (sanityEclipseRadius - 25))
				if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, 690, 0) then
					Ability.CastPosition(sanityEclipse, bestPos)
					return
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroODKillstealPrison) then
		if astralPrison and Ability.IsCastable(astralPrison, myMana) then
			local prisonCastRange = Ability.GetCastRange(astralPrison)
			for _, targets in ipairs(Entity.GetHeroesInRadius(myHero, prisonCastRange, Enum.TeamType.TEAM_ENEMY)) do
				if targets then
					local target = AIO_Umbrella.targetChecker(targets)
					if target then
						if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(target) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
							local targetHP = Entity.GetHealth(target) + 5 * math.ceil(NPC.GetHealthRegen(target))
							local prisonDamage = Ability.GetLevelSpecialValueFor(astralPrison, "damage")
							local prisonTrueDamage = (1 - NPC.GetMagicalArmorValue(target)) * (prisonDamage + prisonDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) - 5
							if targetHP < prisonTrueDamage then
								Ability.CastTarget(astralPrison, target)
								break
								return
							end
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroODKillstealOrb) then
		if arcaneOrb and Ability.IsCastable(arcaneOrb, myMana) and Ability.GetLevel(arcaneOrb) > 0 then
			for _, targets in ipairs(Entity.GetHeroesInRadius(myHero, myAttackRange, Enum.TeamType.TEAM_ENEMY)) do
				if targets then
					local target = AIO_Umbrella.targetChecker(targets)
					if target then
						if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(target) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
							local targetHP = Entity.GetHealth(target) + NPC.GetHealthRegen(target)
							local orbExtraDamage = (0.05 + (0.01 * Ability.GetLevel(arcaneOrb))) * NPC.GetMana(myHero)
							local rightClickDamage = NPC.GetDamageMultiplierVersus(myHero, target) * ((NPC.GetMinDamage(myHero) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(target))
							local overallDamage = rightClickDamage + orbExtraDamage
							if targetHP < overallDamage then
								Ability.CastTarget(arcaneOrb, target)
								break
								return
							end
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.NecroCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNecro) then return end

	local deathPulse = NPC.GetAbilityByIndex(myHero, 0)
    	local ghostShroud = NPC.GetAbilityByIndex(myHero, 1)
    	local reapersScythe = NPC.GetAbility(myHero, "necrolyte_reapers_scythe")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	
	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.necroComboTotalDamage(myHero, myMana, enemy, deathPulse, reapersScythe)
	AIO_Umbrella.necroComboSelector(myHero, myMana, enemy, deathPulse, reapersScythe)
	AIO_Umbrella.necroAutoScythe(myHero, myMana, reapersScythe)
	AIO_Umbrella.necroAutoPulse(myHero, myMana, deathPulse)
	AIO_Umbrella.necroAutoFarmShroud(myHero, myMana, deathPulse, ghostShroud)
	AIO_Umbrella.necroAutoPulseShroudPanic(myHero, myMana, deathPulse, ghostShroud)

	if enemy then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 999) then
					if Menu.IsEnabled(AIO_Umbrella.optionHeroNecroBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroNecroBlinkRange)) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroNecroBlinkRange))))
						return
					end
				end

				if not AIO_Umbrella.necroComboSelect then
					AIO_Umbrella.necroComboWithoutUlt(myHero, myMana, enemy, deathPulse)
				else
					AIO_Umbrella.necroComboWithUlt(myHero, myMana, enemy, deathPulse, reapersScythe)
				end

			end
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end

end

function AIO_Umbrella.necroAutoPulseShroudPanic(myHero, myMana, deathPulse, ghostShroud)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNecroShroudPanic) then return end
	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local myHP = Entity.GetHealth(myHero)
	local myHPperc = (myHP / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(AIO_Umbrella.optionHeroNecroShroudPanicHP) then
		if ghostShroud and Ability.IsCastable(ghostShroud, myMana) then
			Ability.CastNoTarget(ghostShroud)
			return
		end
		if deathPulse and Ability.IsCastable(deathPulse, myMana) then
			Ability.CastNoTarget(deathPulse)
			return
		end
	end

end

function AIO_Umbrella.necroAutoFarmShroud(myHero, myMana, deathPulse, ghostShroud)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNecroShroudFarm) then return end
	if not myHero then return end
	if not deathPulse then return end
		if Ability.GetLevel(deathPulse) < 1 then return end

	if not ghostShroud then return end
		if Ability.GetLevel(ghostShroud) < 1 then return end
		if not Ability.IsCastable(ghostShroud, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local deathPulseModifier = NPC.GetModifier(myHero, "modifier_necrolyte_death_pulse_counter")
	local deathPulseCounter = 0
		if deathPulseModifier then
			deathPulseCounter = Modifier.GetStackCount(deathPulseModifier)
		end

	if deathPulseCounter <= Menu.GetValue(AIO_Umbrella.optionHeroNecroShroudFarmCount) then return end
	if Menu.IsEnabled(AIO_Umbrella.optionHeroNecroShroudFarmSave) then
		if #Entity.GetHeroesInRadius(myHero, 600, Enum.TeamType.TEAM_ENEMY) > 0 then
			return
		end
	end
	local manaPerc = (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) * 100
	local healthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	local treshold = Menu.GetValue(AIO_Umbrella.optionHeroNecroShroudFarmTreshold)
	if manaPerc <= treshold or healthPerc <= treshold then
		Ability.CastNoTarget(ghostShroud)
		return
	end

end

function AIO_Umbrella.necroAutoPulse(myHero, myMana, deathPulse)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNecroPulse) then return end
	if not myHero then return end
	if not deathPulse then return end
		if Ability.GetLevel(deathPulse) < 1 then return end
		if not Ability.IsCastable(deathPulse, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then return end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroNecroPulseCreeps) then
		local tempTable = {}
		for _, creep in ipairs(NPC.GetUnitsInRadius(myHero, 450, Enum.TeamType.TEAM_ENEMY)) do
			if creep and Entity.IsNPC(creep) and not Entity.IsDormant(creep) and not NPC.IsWaitingToSpawn(creep) and NPC.GetUnitName(creep) ~= "npc_dota_neutral_caster" then
				local pulseDamage = Ability.GetDamage(deathPulse)
				local pulseTrueDamage = (1 - NPC.GetMagicalArmorValue(creep)) * (pulseDamage + pulseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				local creepHP = Entity.GetHealth(creep)
				if NPC.IsLaneCreep(creep) then
					local attackerCount = 0
						if AIO_Umbrella.lastHitGetAttackerCount(myHero, creep) ~= nil and AIO_Umbrella.lastHitGetAttackerCount(myHero, creep) > 0 then
							attackerCount = AIO_Umbrella.lastHitGetAttackerCount(myHero, creep)
						end
					if creepHP + (attackerCount * 15) < pulseTrueDamage then
						table.insert(tempTable, creep)
					end
				else
					if creepHP < pulseTrueDamage then
						table.insert(tempTable, creep)
					end
				end
			end
		end

		if #tempTable >= Menu.GetValue(AIO_Umbrella.optionHeroNecroPulseCreepsCount) then
			if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(AIO_Umbrella.optionHeroNecroPulseCreepsMana) / 100) then
				Ability.CastNoTarget(deathPulse)
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroNecroPulseHeroes) then
		for _, hero in ipairs(NPC.GetHeroesInRadius(myHero, 450, Enum.TeamType.TEAM_ENEMY)) do
			local target = AIO_Umbrella.targetChecker(hero)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(AIO_Umbrella.optionHeroNecroPulseHeroesMana) / 100) then
						Ability.CastNoTarget(deathPulse)
						break
						return
					end
				end
			end
		end
	end
					
end

function AIO_Umbrella.necroAutoScythe(myHero, myMana, reapersScythe)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNecroScythe) then return end
	if not myHero then return end
	if not reapersScythe then return end
		if Ability.GetLevel(reapersScythe) < 1 then return end
		if not Ability.IsCastable(reapersScythe, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then return end

	for _, hero in ipairs(NPC.GetHeroesInRadius(myHero, 575, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
			if Entity.IsAlive(hero) and not NPC.HasModifier(hero, "modifier_templar_assassin_refraction_absorb") then
				local scytheDamage = (Entity.GetMaxHealth(hero) - Entity.GetHealth(hero)) * Ability.GetLevelSpecialValueForFloat(reapersScythe, "damage_per_health")
        			local scytheTrueDamage = (1 - NPC.GetMagicalArmorValue(hero)) * (scytheDamage + scytheDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				if Entity.GetHealth(hero) < scytheTrueDamage then
					Ability.CastTarget(reapersScythe, hero)
					break
        				return
				end
			end
      		end		
	end

end

function AIO_Umbrella.necroComboSelector(myHero, myMana, enemy, deathPulse, reapersScythe)

	if not myHero then return end
	if not enemy then return end
	if os.clock() - AIO_Umbrella.lastTick < 0.55 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 400) then return end


	if not deathPulse then return end

	if Ability.SecondsSinceLastUse(deathPulse) > -1 and Ability.SecondsSinceLastUse(deathPulse) < 0.55 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 400) then return end

	if not reapersScythe then
		AIO_Umbrella.necroComboSelect = false
		return
	end

	if Ability.GetLevel(reapersScythe) < 1 then
		AIO_Umbrella.necroComboSelect = false
		return
	end

	if not Ability.IsCastable(reapersScythe, myMana) then
		AIO_Umbrella.necroComboSelect = false
		return
	end

	if Menu.GetValue(AIO_Umbrella.optionHeroNecroComboScythe) == 0 then
		AIO_Umbrella.necroComboSelect = false
		return
	else
		if Entity.GetHealth(enemy) > AIO_Umbrella.necroDMGwithoutUlt then
			AIO_Umbrella.necroComboSelect = true
			return
		else
			AIO_Umbrella.necroComboSelect = false
			return
		end
	end	

end

function AIO_Umbrella.necroComboWithoutUlt(myHero, myMana, enemy, deathPulse)

	if not myHero then return end
	if not enemy then return end

	if deathPulse and Ability.IsCastable(deathPulse, myMana) and NPC.IsEntityInRange(myHero, enemy, 450) then
		Ability.CastNoTarget(deathPulse)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

end

function AIO_Umbrella.necroComboWithUlt(myHero, myMana, enemy, deathPulse, reapersScythe)

	if not myHero then return end
	if not enemy then return end

	if deathPulse and Ability.IsCastable(deathPulse, myMana) and NPC.IsEntityInRange(myHero, enemy, 450) then
		Ability.CastNoTarget(deathPulse)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	if reapersScythe and Ability.IsCastable(reapersScythe, myMana) and NPC.IsEntityInRange(myHero, enemy, 550) then
		if Menu.GetValue(AIO_Umbrella.optionHeroNecroComboScythe) == 1 then
			if not Ability.IsReady(deathPulse) then
				Ability.CastTarget(reapersScythe, enemy)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		elseif Menu.GetValue(AIO_Umbrella.optionHeroNecroComboScythe) == 2 then
			local scytheDamage = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(reapersScythe, "damage_per_health")
        		local scytheTrueDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (scytheDamage + scytheDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			local rightClickDamage = NPC.GetDamageMultiplierVersus(myHero, enemy) * ((NPC.GetMinDamage(myHero) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(enemy))
			local pulseExtraDamage = 0
				if deathPulse and Ability.SecondsSinceLastUse(deathPulse) > -1 and Ability.SecondsSinceLastUse(deathPulse) < (((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 400) + 0.05) then
					pulseExtraDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetDamage(deathPulse) + Ability.GetDamage(deathPulse) * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				end
			if Entity.GetHealth(enemy) < (scytheTrueDamage + rightClickDamage + pulseExtraDamage) then
				Ability.CastTarget(reapersScythe, enemy)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	end

end

function AIO_Umbrella.necroComboTotalDamage(myHero, myMana, enemy, deathPulse, reapersScythe)

	if not myHero then return end
	if not enemy then return end
	if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end 

	local totalDamage = 0
	local totalDamageUlt = 0
	local veilAmp = 0
	local ebladeAmp = 0
	local reqMana = 0
	local reqManaUlt = 0

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if veil and Ability.IsCastable(veil, myMana) then
		veilAmp = 0.25
		reqMana = reqMana + Ability.GetManaCost(veil)
	end

	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local ebladedamage = Hero.GetIntellectTotal(myHero) * 2 + 75
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (ebladedamage + ebladedamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		ebladeAmp = 0.4
		reqMana = reqMana + Ability.GetManaCost(eBlade)
	end	

	if dagon and Ability.IsCastable(dagon, Ability.GetManaCost(dagon)) then
		local dagondmg = Ability.GetLevelSpecialValueFor(dagon, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (dagondmg + dagondmg * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(dagon)
	end

	if deathPulse and Ability.IsCastable(deathPulse, myMana) then
		if NPC.HasItem(myHero, "item_blink", true) and Ability.IsReady(NPC.GetItem(myHero, "item_blink", true)) then
			local pulseDamage = Ability.GetDamage(deathPulse)
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (pulseDamage + pulseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			reqMana = reqMana + Ability.GetManaCost(deathPulse)
		else
			if NPC.IsEntityInRange(myHero, enemy, 475) then
				local pulseDamage = Ability.GetDamage(deathPulse)
				totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (pulseDamage + pulseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				reqMana = reqMana + Ability.GetManaCost(deathPulse)
			end
		end
	end

	local rightClickDamage = 0
		if not NPC.HasItem(myHero, "item_ethereal_blade", true) then
			rightClickDamage = NPC.GetDamageMultiplierVersus(myHero, enemy) * ((NPC.GetMinDamage(myHero) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(enemy))
		end

	totalDamage = totalDamage + rightClickDamage

	local scytheOverallTrueDamage = 0
	local totalDamageUlt = totalDamage
	local reqManaUlt = reqMana
	if reapersScythe and Ability.IsCastable(reapersScythe, myMana) then
		local scytheDamage = (Entity.GetMaxHealth(enemy) - (Entity.GetHealth(enemy) - totalDamage)) * Ability.GetLevelSpecialValueForFloat(reapersScythe, "damage_per_health")
		local scytheTrueDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (scytheDamage + scytheDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		scytheOverallTrueDamage = scytheTrueDamage + rightClickDamage
		totalDamageUlt = totalDamage + scytheOverallTrueDamage
		reqManaUlt = reqManaUlt + Ability.GetManaCost(reapersScythe)
	end

	if reqManaUlt > NPC.GetMana(myHero) and reqMana < NPC.GetMana(myHero) then
		totalDamageUlt = totalDamage
	end

	if reqMana < NPC.GetMana(myHero) then
		AIO_Umbrella.necroDMGwithoutUlt = totalDamage
		AIO_Umbrella.necroDMGwithUlt = totalDamageUlt
	end

end

function AIO_Umbrella.necroComboDrawDamage(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroNecroDrawDMG) then return end
	
	if AIO_Umbrella.necroDMGwithoutUlt == 0 then return end
	if AIO_Umbrella.necroDMGwithUlt == 0 then return end

	local enemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if AIO_Umbrella.necroDMGwithoutUlt > 0 and AIO_Umbrella.necroDMGwithUlt > 0 then
		if visible then
			if Entity.GetHealth(enemy) > AIO_Umbrella.necroDMGwithoutUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(AIO_Umbrella.skywrathFont, x-50, y-90, "DMG w/o Ult: " .. math.floor(AIO_Umbrella.necroDMGwithoutUlt), 0)
			if Entity.GetHealth(enemy) > AIO_Umbrella.necroDMGwithUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(AIO_Umbrella.skywrathFont, x-50, y-75, "DMG w/ Ult: " .. math.floor(AIO_Umbrella.necroDMGwithUlt), 0)
		end
	end
		

end

function AIO_Umbrella.PACombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroPA) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local dagger = NPC.GetAbilityByIndex(myHero, 0)
	local phantomStrike = NPC.GetAbilityByIndex(myHero, 1)

	local myMana = NPC.GetMana(myHero)

	local daggerRange = Ability.GetCastRange(dagger)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
			if AIO_Umbrella.SleepReady(0.1) and dagger and Ability.IsCastable(dagger, myMana) then
				if NPC.IsEntityInRange(myHero, enemy, daggerRange - 5) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					Ability.CastTarget(dagger, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
			if AIO_Umbrella.SleepReady(0.1) and phantomStrike and Ability.IsCastable(phantomStrike, myMana) then
				if NPC.IsEntityInRange(myHero, enemy, 999) then
					Ability.CastTarget(phantomStrike, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)

	end
	
	local minHP = 99999
	local minHPenemy

	if Menu.IsEnabled(AIO_Umbrella.optionHeroPADagger) and AIO_Umbrella.isHeroChannelling(myHero) == false and AIO_Umbrella.IsHeroInvisible(myHero) == false then
		if AIO_Umbrella.Toggler then
			if NPC.GetMana(myHero) > (NPC.GetMaxMana(myHero) * (Menu.GetValue(AIO_Umbrella.optionHeroPADaggerThreshold) / 100)) then
				if dagger and Ability.IsCastable(dagger, myMana) then
					local daggerEnemies = NPC.GetHeroesInRadius(myHero, daggerRange - 1, Enum.TeamType.TEAM_ENEMY)
					for _, daggerEnemy in ipairs(daggerEnemies) do
						if daggerEnemy and AIO_Umbrella.targetChecker(daggerEnemy) ~= nil and not NPC.HasState(daggerEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							local enemyHP = Entity.GetHealth(daggerEnemy)
							if enemyHP < minHP then
								minHP = enemyHP
								minHPenemy = daggerEnemy
							end
						end
					end
				end
			end
		end
	end

	if minHPenemy and AIO_Umbrella.isHeroChannelling(myHero) == false and AIO_Umbrella.IsHeroInvisible(myHero) == false then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroPADagger) then
			if AIO_Umbrella.Toggler then
				if not NPC.IsChannellingAbility(myHero) and not NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVISIBLE) and not NPC.HasModifier(myHero, "modifier_teleporting") then
					if AIO_Umbrella.SleepReady(0.3) and dagger and Ability.IsCastable(dagger, myMana) then
						Ability.CastTarget(dagger, minHPenemy)
						AIO_Umbrella.lastTick = os.clock()
						minHP = 99999
						minHPenemy = nil
						return
					end
				end
			end
		end
	end

end

function AIO_Umbrella.DrawPADaggerSwitch()

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 0, 255)

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroPADaggerToggleKey) then
		AIO_Umbrella.Toggler = not AIO_Umbrella.Toggler
		AIO_Umbrella.TogglerTime = os.clock()
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroPADaggerDraw) then
		if os.clock() - AIO_Umbrella.TogglerTime < 3 then
			if AIO_Umbrella.Toggler then
				Renderer.DrawTextCentered(AIO_Umbrella.font, w / 2, h / 2 + 300, "AUTO DAGGER ON", 1)
			else 
				Renderer.DrawTextCentered(AIO_Umbrella.font, w / 2, h / 2 + 300, "AUTO DAGGER OFF", 1)
			end
		end
	end

end

function AIO_Umbrella.AntiMageCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroAntiMage) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local AMblink = NPC.GetAbilityByIndex(myHero, 1)
    	local manaVoid = NPC.GetAbility(myHero, "antimage_mana_void")
    	
	local myMana = NPC.GetMana(myHero)

	local blinkRange = Ability.GetLevelSpecialValueFor(AMblink, "blink_range")

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 250) then
			if AMblink and Ability.IsCastable(AMblink, myMana) and Menu.IsEnabled(AIO_Umbrella.optionHeroAntiMageBlink) then
				if NPC.IsEntityInRange(myHero, enemy, blinkRange - 105) then
					if NPC.GetTimeToFace(enemy, myHero) <= 0.05 then
						Ability.CastPosition(AMblink, Entity.GetAbsOrigin(enemy))
						return
					else
						Ability.CastPosition(AMblink, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(100))
						return
					end
				end
			end
		end

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	AIO_Umbrella.MantaIlluController(enemy, nil, myHero, myHero)

	end

	local maxManaDiff = 0
	local maxDMGTarget

	if manaVoid and Ability.IsCastable(manaVoid, myMana) and AIO_Umbrella.isHeroChannelling(myHero) == false and AIO_Umbrella.IsHeroInvisible(myHero) == false then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroAntiMageVoid) then
			local voidEnemies = NPC.GetHeroesInRadius(myHero, 599, Enum.TeamType.TEAM_ENEMY)
			for _, voidEnemy in ipairs(voidEnemies) do
				if voidEnemy and not NPC.IsLinkensProtected(voidEnemy) then
					local enemyManaDiff = NPC.GetMaxMana(voidEnemy) - NPC.GetMana(voidEnemy)
					if #voidEnemies <= 1 then
						if not NPC.HasState(voidEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							maxManaDiff = 0
							maxDMGTarget = voidEnemy
							break
							return
						end
					else
						if enemyManaDiff > maxManaDiff and not NPC.HasState(voidEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							maxManaDiff = enemyManaDiff
							maxDMGTarget = voidEnemy
						end
					end
				end
			end
		end
	end

	if maxDMGTarget ~= nil then
		if AIO_Umbrella.isHeroChannelling(myHero) == false and AIO_Umbrella.IsHeroInvisible(myHero) == false then
			local enemyHP = Entity.GetHealth(maxDMGTarget) + NPC.GetHealthRegen(maxDMGTarget)
			local enemiesInVoidRadius = NPC.GetHeroesInRadius(maxDMGTarget, 450, Enum.TeamType.TEAM_FRIEND)
			local enemyManaDiff = NPC.GetMaxMana(maxDMGTarget) - NPC.GetMana(maxDMGTarget)
			local voidDamage = enemyManaDiff * Ability.GetLevelSpecialValueForFloat(manaVoid, "mana_void_damage_per_mana")
			local totalVoidDamage = ((1 - NPC.GetMagicalArmorValue(maxDMGTarget)) * voidDamage) + (voidDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			if manaVoid and Ability.IsCastable(manaVoid, myMana) then
				if NPC.IsEntityInRange(myHero, maxDMGTarget, 599) then
					if totalVoidDamage > enemyHP then
						Ability.CastTarget(manaVoid, maxDMGTarget)
						maxManaDiff = 0
						maxDMGTarget = nil
						return
					end
					if #enemiesInVoidRadius >= 1 then
						for _, radiusTargets in ipairs(enemiesInVoidRadius) do
							if radiusTargets then
								local voidDamageRadius = enemyManaDiff * Ability.GetLevelSpecialValueForFloat(manaVoid, "mana_void_damage_per_mana")
								local totalVoidDamageRadius = ((1 - NPC.GetMagicalArmorValue(radiusTargets)) * voidDamageRadius) + (voidDamageRadius * (Hero.GetIntellectTotal(myHero) / 14 / 100))
								if totalVoidDamageRadius > Entity.GetHealth(radiusTargets) + NPC.GetHealthRegen(radiusTargets) and not NPC.HasState(radiusTargets, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
									Ability.CastTarget(manaVoid, maxDMGTarget)
									maxManaDiff = 0
									maxDMGTarget = nil
									break
									return
								end
							end
						end
					end
				end	
			end
		end
	end
				
end		

function AIO_Umbrella.tinyCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroTiny) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end
    
    	local avalanche = NPC.GetAbilityByIndex(myHero, 0)
    	local toss = NPC.GetAbilityByIndex(myHero, 1)
    	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 275) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end
		else
			AIO_Umbrella.itemUsage(myHero, enemy)
			if avalanche and Ability.IsCastable(avalanche, myMana) then 
				Ability.CastPosition(avalanche, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastTick = os.clock()
			end
    			if AIO_Umbrella.SleepReady(0.2) and toss and Ability.IsCastable(toss, myMana) then 
				Ability.CastTarget(toss, enemy)
				return 
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function AIO_Umbrella.WindRunnerCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunner) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local shackleShot = NPC.GetAbilityByIndex(myHero, 0)
	local windRun = NPC.GetAbilityByIndex(myHero, 2)
	local focusFire = NPC.GetAbility(myHero, "windrunner_focusfire")
	local myMana = NPC.GetMana(myHero)
	
	local branch = NPC.GetItem(myHero, "item_branches", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if AIO_Umbrella.canEnemyBeShackledWithTree(myHero, enemy) == true or AIO_Umbrella.getEnemyBeShackledWithNPC(myHero, enemy) ~= nil then
		AIO_Umbrella.enemyCanBeShackled = true
	else
		AIO_Umbrella.enemyCanBeShackled = false
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if AIO_Umbrella.getEnemyBeShackledWithNPC(myHero, enemy) ~= nil then
			if shackleShot and Ability.IsCastable(shackleShot, myMana) then
				Ability.CastTarget(shackleShot, AIO_Umbrella.getEnemyBeShackledWithNPC(myHero, enemy))
				return
			end
		elseif AIO_Umbrella.canEnemyBeShackledWithTree(myHero, enemy) == true then
			if shackleShot and Ability.IsCastable(shackleShot, myMana) then
				Ability.CastTarget(shackleShot, enemy)
				return
			end
		else
			if AIO_Umbrella.getEnemyShackledBestPosition(myHero, enemy, 1150):__tostring() ~= Vector():__tostring() then
				if blink and Ability.IsReady(blink) and Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunnerBlinkShackle) then
					Ability.CastPosition(blink, AIO_Umbrella.getEnemyShackledBestPosition(myHero, enemy, 1150))
					return
				end

			else
				if Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunnerBranchShackle) then
					if branch and NPC.IsEntityInRange(myHero, enemy, 750) then
						if blink and Ability.IsReady(blink) then	
							if shackleShot and Ability.IsCastable(shackleShot, myMana) then
								Ability.CastTarget(shackleShot, enemy)
								return
							end
							if blink and Ability.IsReady(blink) and not Ability.IsReady(shackleShot) then
								Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Rotated(Angle(0,45,0)):Normalized():Scaled(200))
								Ability.CastPosition(branch, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(150))
								return
							end
						end
					end
				end
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

	if NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then

			local shackleMod = NPC.GetModifier(enemy, "modifier_windrunner_shackle_shot")
				if not shackleMod then return end
			local shackleTime = Modifier.GetCreationTime(shackleMod) + Modifier.GetDuration(shackleMod)

			if NPC.HasModifier(enemy, "modifier_windrunner_shackle_shot") and Modifier.GetDuration(shackleMod) >= 1.5 and Menu.IsEnabled(AIO_Umbrella.optionHeroWindrunnerUlt) then
				if focusFire and Ability.IsCastable(focusFire, myMana) then
					Ability.CastTarget(focusFire, enemy)
					return
				end
				if Menu.GetValue(AIO_Umbrella.optionHeroWindrunnerWind) > 0 then
					if windRun and Ability.IsCastable(windRun, myMana) and #NPC.GetHeroesInRadius(myHero, 600, Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(AIO_Umbrella.optionHeroWindrunnerWind) then
						Ability.CastNoTarget(windRun)
						return
					end
				end
			end
		end
	end
	
end

function AIO_Umbrella.windrunnerDrawShackleIndicator(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionWindrunnerDrawIndicator) then return end
	
	if AIO_Umbrella.enemyCanBeShackled == false then return end

	local enemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if visible then
		Renderer.SetDrawColor(50,205,50,255)
		Renderer.DrawText(AIO_Umbrella.font, x-30, y-80, "shackle", 0)
	end
		
end

function AIO_Umbrella.TimberCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroTimber) then return end
	
	if (os.clock() - AIO_Umbrella.lastTick) < AIO_Umbrella.delay then return end

	local whirlingDeath = NPC.GetAbilityByIndex(myHero, 0)
	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
	local chakram = NPC.GetAbility(myHero, "shredder_chakram")
	local chakramReturn = NPC.GetAbility(myHero, "shredder_return_chakram")
	local chakramAgha = NPC.GetAbility(myHero, "shredder_chakram_2")
	local chakramAghaReturn = NPC.GetAbility(myHero, "shredder_return_chakram_2")

	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	
	local myMana = NPC.GetMana(myHero)

	local rangeChecker = 500
	if blink and Ability.IsReady(blink) then
		rangeChecker = 1150
	end

	if Menu.GetValue(AIO_Umbrella.optionHeroTimberWhirling) > 0 and AIO_Umbrella.isHeroChannelling(myHero) == false and AIO_Umbrella.IsHeroInvisible(myHero) == false then
		if enemy and NPC.IsEntityInRange(myHero, enemy, 270) then
			if whirlingDeath and Ability.IsCastable(whirlingDeath, myMana) then
				if (NPC.HasModifier(myHero, "modifier_shredder_timer_chain") and #Trees.InRadius(enemy, 270, true) > 0) then
					if #Trees.InRadius(myHero, 270, true) > 0 then
						Ability.CastNoTarget(whirlingDeath)
						AIO_Umbrella.makeDelay(0.1)
						return
					end
				else
					if Menu.GetValue(AIO_Umbrella.optionHeroTimberWhirling) == 2 then
						Ability.CastNoTarget(whirlingDeath)
						AIO_Umbrella.makeDelay(0.1)
						return
					else
						if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
							Ability.CastNoTarget(whirlingDeath)
							AIO_Umbrella.makeDelay(0.1)
							return
						end
					end
				end
			end
		end
	end

	AIO_Umbrella.itemUsage(myHero, enemy)
	
	if enemy and Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if AIO_Umbrella.TimberIsTreeInRangeForChain(myHero, enemy) ~= nil or AIO_Umbrella.TimberGetBestChainPos(myHero, enemy, rangeChecker):__tostring() ~= Vector():__tostring() then
			if AIO_Umbrella.TimberIsTreeInRangeForChain(myHero, enemy) ~= nil then
				if timberChain and Ability.IsCastable(timberChain, myMana) then
					Ability.CastPosition(timberChain, Entity.GetAbsOrigin(AIO_Umbrella.TimberIsTreeInRangeForChain(myHero, enemy)))
					AIO_Umbrella.lastCastTime3 = GameRules.GetGameTime() + (((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() + 275) / (1200 + Ability.GetLevel(timberChain) * 400))
					AIO_Umbrella.makeDelay(0.1)
					return
				end
			else
				if blink and Ability.IsReady(blink) and Menu.IsEnabled(AIO_Umbrella.optionHeroTimberBlink) then
					if AIO_Umbrella.TimberGetBestChainPos(myHero, enemy, rangeChecker):__tostring() ~= Vector():__tostring() then
						Ability.CastPosition(blink, AIO_Umbrella.TimberGetBestChainPos(myHero, enemy, 1150))
						return
					end
				elseif (not blink or (blink and not Ability.IsReady(blink)) or not Menu.IsEnabled(AIO_Umbrella.optionHeroTimberBlink)) and Ability.IsReady(timberChain) then
					if AIO_Umbrella.TimberGetBestChainPos(myHero, enemy, rangeChecker):__tostring() ~= Vector():__tostring() then
						AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, AIO_Umbrella.TimberGetBestChainPos(myHero, enemy, 500), myHero)
						return
					else
						if Ability.IsReady(timberChain) then
							AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
							return
						end
					end
				end
			end
		else
			if Menu.IsEnabled(AIO_Umbrella.optionHeroTimberUlt) and NPC.IsEntityInRange(myHero, enemy, 700) then
				if GameRules.GetGameTime() < AIO_Umbrella.lastCastTime3 then
					return
				else
					if not Ability.IsHidden(chakram) and not Ability.IsInAbilityPhase(timberChain) then
						if chakram and Ability.IsCastable(chakram, myMana) then
							local chakramPrediction = Ability.GetCastPoint(chakram) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 900) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							Ability.CastPosition(chakram, AIO_Umbrella.castLinearPrediction(myHero, enemy, chakramPrediction))
							AIO_Umbrella.lastCastTime = 1
							AIO_Umbrella.makeDelay(0.3)
							return
						end
					elseif not Ability.IsHidden(chakramAgha) and Ability.IsHidden(chakram) and not Ability.IsInAbilityPhase(timberChain) then
						if chakramAgha and Ability.IsCastable(chakramAgha, myMana) then
							local chakramPrediction = Ability.GetCastPoint(chakram) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 900) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							Ability.CastPosition(chakramAgha, AIO_Umbrella.castLinearPrediction(myHero, enemy, chakramPrediction))
							AIO_Umbrella.lastCastTime2 = 1
							AIO_Umbrella.makeDelay(0.3)
							return
						end
					end
				end
			end
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end

	if enemy then
		if not Ability.IsHidden(chakramReturn) and AIO_Umbrella.lastCastTime == 1 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if chakramReturn and Ability.IsCastable(chakramReturn, myMana) and (Ability.SecondsSinceLastUse(chakram) >= 1 and not NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff")) or (NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff") and Ability.SecondsSinceLastUse(chakram) >= (Menu.GetValue(AIO_Umbrella.optionHeroTimberUltTiming) * 0.5)) then
				Ability.CastNoTarget(chakramReturn)
				AIO_Umbrella.lastCastTime = 0
				AIO_Umbrella.makeDelay(0.3)
				return
			end
		end
		if not Ability.IsHidden(chakramAghaReturn) and AIO_Umbrella.lastCastTime2 == 1 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if chakramAghaReturn and Ability.IsCastable(chakramAghaReturn, myMana) and (Ability.SecondsSinceLastUse(chakramAgha) >= 1 and not NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff")) or (NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff") and Ability.SecondsSinceLastUse(chakramAgha) >= (Menu.GetValue(AIO_Umbrella.optionHeroTimberUltTiming) * 0.5)) then
				Ability.CastNoTarget(chakramAghaReturn)
				AIO_Umbrella.lastCastTime2 = 0
				AIO_Umbrella.makeDelay(0.3)
				return
			end
		end
	else
		if not Ability.IsHidden(chakramReturn) and AIO_Umbrella.lastCastTime == 1 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if chakramReturn and Ability.IsCastable(chakramReturn, myMana) and Ability.SecondsSinceLastUse(chakram) >= 1 then
				Ability.CastNoTarget(chakramReturn)
				AIO_Umbrella.lastCastTime = 0
				AIO_Umbrella.makeDelay(0.1)
				return
			end
		end
		if not Ability.IsHidden(chakramAghaReturn) and AIO_Umbrella.lastCastTime2 == 1 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if chakramAghaReturn and Ability.IsCastable(chakramAghaReturn, myMana) and Ability.SecondsSinceLastUse(chakramAgha) >= 1 then
				Ability.CastNoTarget(chakramAghaReturn)
				AIO_Umbrella.lastCastTime2 = 0
				AIO_Umbrella.makeDelay(0.1)
				return
			end
		end
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroTimberPanicKey) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if AIO_Umbrella.TimberPanic(myHero) ~= nil then
			Ability.CastPosition(timberChain, Entity.GetAbsOrigin(AIO_Umbrella.TimberPanic(myHero)))
			return
		end
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroTimberFastMoveKey) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if AIO_Umbrella.TimberFastMove(myHero) ~= nil then
			Ability.CastPosition(timberChain, Entity.GetAbsOrigin(AIO_Umbrella.TimberFastMove(myHero)))
			return
		else
			AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos(), myHero)
			return
		end
	end		

end

function AIO_Umbrella.TimberFastMove(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)
	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return end
		if not Ability.IsCastable(timberChain, myMana) then return end

	local chainCastRange = Ability.GetCastRange(timberChain)

	local cursorPos = Input.GetWorldCursorPos()

	local chainTree
	local minDis = 99999

	if next(AIO_Umbrella.TimberGetTreesFastMoveCursor(myHero)) ~= nil then
		chainTree = AIO_Umbrella.TimberGetTreesFastMoveCursor(myHero)[1][2]
	end

	if chainTree ~= nil then
		return chainTree
	end
	return

end

function AIO_Umbrella.TimberPanic(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return end
		if not Ability.IsCastable(timberChain, myMana) then return end

	local chainCastRange = Ability.GetCastRange(timberChain)

	local chainTree
	local minDis = 99999
	local maxDis = 0

	if Menu.GetValue(AIO_Umbrella.optionHeroTimberPanicDir) < 2 then
		if Menu.GetValue(AIO_Umbrella.optionHeroTimberPanicDir) == 0 then
			if next(AIO_Umbrella.TimberGetEscapeChainTreesFountain(myHero)) ~= nil then
				chainTree = AIO_Umbrella.TimberGetEscapeChainTreesFountain(myHero)[1][2]
			end
		else
			if next(AIO_Umbrella.TimberGetEscapeChainTrees(myHero)) ~= nil then
				chainTree = AIO_Umbrella.TimberGetEscapeChainTrees(myHero)[1][2]
			end
		end
	else
		local tree = Input.GetNearestTreeToCursor(true)
		if tree ~= nil then
			local dismyHeroToTree = (Entity.GetAbsOrigin(tree) - Entity.GetAbsOrigin(myHero)):Length2D()
			if dismyHeroToTree < chainCastRange then
				chainTree = tree
			else
				if AIO_Umbrella.TimberFastMove(myHero) ~= nil then
					chainTree = AIO_Umbrella.TimberFastMove(myHero)
				end
			end
		end
	end

	if chainTree ~= nil then
		return chainTree
	end
	return

end

function AIO_Umbrella.EmberCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroEmber) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local chains = NPC.GetAbility(myHero, "ember_spirit_searing_chains")
	local fist = NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")
	local flameGuard = NPC.GetAbility(myHero, "ember_spirit_flame_guard")
	local activeRemnant = NPC.GetAbility(myHero, "ember_spirit_activate_fire_remnant")
	local remnant = NPC.GetAbility(myHero, "ember_spirit_fire_remnant")
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	local remnantModifier = NPC.GetModifier(myHero, "modifier_ember_spirit_fire_remnant_charge_counter")

	local fistRange = 650
		if fist then
			fistRange = fistRange + Ability.GetLevelSpecialValueFor(fist, "radius")
		end
		
	AIO_Umbrella.itemUsage(myHero, enemy)

	local myPos = Entity.GetAbsOrigin(myHero)
	if NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") then
		if chains and Ability.IsCastable(chains, myMana) then
			if NPC.IsEntityInRange(myHero, enemy, 85) then
				Ability.CastNoTarget(chains)
			end
		end
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, fistRange) then
			if blink and Ability.IsReady(blink) and not NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") and NPC.IsEntityInRange(myHero, enemy, 1150 + fistRange) then
				Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(math.abs((Entity.GetAbs(Origin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() - 1150)))))
				return
			end
		else
			
			if fist and Ability.IsCastable(fist, myMana) then
				AIO_Umbrella.noItemCastFor(0.5)
				if NPC.IsEntityInRange(myHero, enemy, 650) then
					Ability.CastPosition(fist, Entity.GetAbsOrigin(enemy))
				else
					Ability.CastPosition(fist, (Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(690)))
				end
			end

			if flameGuard and Ability.IsCastable(flameGuard, myMana) and not NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") and NPC.HasModifier(enemy, "modifier_ember_spirit_searing_chains") then
				Ability.CastNoTarget(flameGuard)
			end
	
			if remnant and Ability.IsReady(remnant) and not NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") and NPC.GetMana(myHero) >= Ability.GetManaCost(activeRemnant) and NPC.HasModifier(enemy, "modifier_ember_spirit_searing_chains") then
				local remnantCharges = Modifier.GetStackCount(remnantModifier)
				if Menu.GetValue(AIO_Umbrella.optionHeroEmberUlt) == 0 then
					if remnantCharges == 3 then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()			
					end
					if remnantCharges == 2 then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
					end
					if remnantCharges == 1 then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
					end
				end
				if Menu.GetValue(AIO_Umbrella.optionHeroEmberUlt) == 1 then
					if remnantCharges > 2 and AIO_Umbrella.SleepReady(3) then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
					end
					if remnantCharges >= 2 and AIO_Umbrella.SleepReady(3) then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
					end
				end
			end
			if activeRemnant and Ability.IsCastable(activeRemnant, myMana) and NPC.HasModifier(myHero, "modifier_ember_spirit_fire_remnant_timer") and NPC.HasModifier(enemy, "modifier_ember_spirit_searing_chains") then
				for i = 1, NPCs.Count() do 
				local npc = NPCs.Get(i)
					if npc and npc ~= myHero and Entity.IsSameTeam(myHero, npc) then
						if Entity.GetOwner(myHero) == Entity.GetOwner(npc) or Entity.OwnedBy(npc, myHero) then
							if NPC.GetUnitName(npc) == "npc_dota_ember_spirit_remnant" then
								if NPC.IsEntityInRange(npc, enemy, 350) then
									Ability.CastPosition(activeRemnant, Entity.GetAbsOrigin(npc))
									break
								end
							end
						end
					end
				end
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end	
end

function AIO_Umbrella.UrsaCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroUrsa) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local earthShock = NPC.GetAbilityByIndex(myHero, 0)
	local overPower = NPC.GetAbilityByIndex(myHero, 1)
	local enrage = NPC.GetAbility(myHero, "ursa_enrage")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	AIO_Umbrella.itemUsage(myHero, enemy)

	local earthShockOffset = 315
		if NPC.IsRunning(enemy) then
			earthShockOffset = 200
		end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if overPower and Ability.IsCastable(overPower, myMana) and NPC.IsEntityInRange(myHero, enemy, 1200) and not NPC.HasModifier(myHero, "modifier_ursa_overpower") then
				Ability.CastNoTarget(overPower)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.2) then
				if not NPC.IsEntityInRange(myHero, enemy, earthShockOffset) then
					if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
						return
					end
				else
					if earthShock and Ability.IsCastable(earthShock, myMana) then
						Ability.CastNoTarget(earthShock)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
					if Menu.IsEnabled(AIO_Umbrella.optionHeroUrsaEnrageCombo) then
						if enrage and Ability.IsCastable(enrage, myMana) then
							Ability.CastNoTarget(enrage)
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			end
		end
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroUrsaEnrage) then
		if enrage and Ability.IsCastable(enrage, myMana) then
			if AIO_Umbrella.isHeroChannelling(myHero) == false and AIO_Umbrella.IsHeroInvisible(myHero) == false then		
				if (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) <= (Menu.GetValue(AIO_Umbrella.optionHeroUrsaEnrageHP) / 100) and #NPC.GetHeroesInRadius(myHero, 650, Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(AIO_Umbrella.optionHeroUrsaEnrageEnemies) then
					if AIO_Umbrella.SleepReady(0.25) then
						Ability.CastNoTarget(enrage)
						return
					end
				end
			end
		end
	end
end

function AIO_Umbrella.TACombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroTA) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local refraction = NPC.GetAbilityByIndex(myHero, 0)
	local meld = NPC.GetAbilityByIndex(myHero, 1)
	local psionicTrap = NPC.GetAbility(myHero, "templar_assassin_psionic_trap")
	local trap = NPC.GetAbility(myHero, "templar_assassin_trap")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	AIO_Umbrella.itemUsage(myHero, enemy)

	local myAttackRange = NPC.GetAttackRange(myHero)
		if NPC.HasItem(myHero, "item_dragon_lance", true) or NPC.HasItem(myHero, "item_hurricane_pike", true) then
			myAttackRange = myAttackRange + 140
		end

	local refractionModifier = NPC.GetModifier(myHero, "modifier_templar_assassin_refraction_damage")
	local meldModifier = NPC.GetModifier(myHero, "modifier_templar_assassin_meld")

	if Menu.IsEnabled(AIO_Umbrella.optionHeroTAHarass) then
		if Menu.IsKeyDown(AIO_Umbrella.optionHeroTAHarassKey) then
			if AIO_Umbrella.TApsiBladesSpill(myHero, enemy, myAttackRange) ~= nil then
				local spillNPC = AIO_Umbrella.TApsiBladesSpill(myHero, enemy, myAttackRange)
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", spillNPC, nil)
				return
			else
				if AIO_Umbrella.TApsiBladesSpillBestPos(myHero, enemy, myAttackRange, Menu.GetValue(AIO_Umbrella.optionHeroTAHarassRange)):__tostring() ~= Vector():__tostring() then
					local movePos = AIO_Umbrella.TApsiBladesSpillBestPos(myHero, enemy, myAttackRange, Menu.GetValue(AIO_Umbrella.optionHeroTAHarassRange))
					AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, movePos)
					return
				end
			end
		end
	end		

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if NPC.IsEntityInRange(myHero, enemy, (1200 + myAttackRange/2)) then
			if refraction and Ability.IsCastable(refraction, myMana) then
				Ability.CastNoTarget(refraction)
			end
			if psionicTrap and Ability.IsCastable(psionicTrap, myMana) then
				Ability.CastPosition(psionicTrap, AIO_Umbrella.castPrediction(myHero, enemy, Ability.GetCastPoint(psionicTrap) + 0.25 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.3) and trap and Ability.IsReady(trap) and Ability.SecondsSinceLastUse(psionicTrap) > 0 and Ability.SecondsSinceLastUse(psionicTrap) < 1 then
				Ability.CastNoTarget(trap)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
		if not NPC.IsEntityInRange(myHero, enemy, myAttackRange) then
			if AIO_Umbrella.SleepReady(0.3) then
				if AIO_Umbrella.SleepReady(0.1) and blink and Ability.IsReady(blink) and Menu.IsEnabled(AIO_Umbrella.optionHeroTABlink) and NPC.IsEntityInRange(myHero, enemy, (1150 + myAttackRange/2)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(myAttackRange/2)))
					return
				end
			end
		else
			if AIO_Umbrella.SleepReady(0.3) and meld and Ability.IsCastable(meld, myMana) then
				AIO_Umbrella.noItemCastFor(0.1)
				Ability.CastNoTarget(meld)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.1) and NPC.HasModifier(myHero, "modifier_templar_assassin_meld") then
				Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
		
end

function AIO_Umbrella.isEnemyInSpillRange(myHero, spillNPC, enemy, spillRange)

	if not spillNPC then return false end
	if not enemy then return false end

	if Entity.IsSameTeam(myHero, spillNPC) then
		if Entity.GetHealth(spillNPC) > 0.5 * Entity.GetMaxHealth(spillNPC) then
			return false 
		end
	end

	if NPC.IsRunning(spillNPC) then return false end

	local enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.75 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
		enemyPos:SetZ(0)

	local spillNPCpos = Entity.GetAbsOrigin(spillNPC)
		spillNPCpos:SetZ(0)

	local myPos = 	Entity.GetAbsOrigin(myHero)
		myPos:SetZ(0)

	if (spillNPCpos - enemyPos):Length2D() > spillRange then
		return false
	end

	local vecmyHeroTospillNPC = spillNPCpos - myPos
	local vecspillNPCToEnemy = enemyPos - spillNPCpos

	local searchPoint = spillNPCpos + vecmyHeroTospillNPC:Normalized():Scaled(vecspillNPCToEnemy:Length2D())

	if math.floor((enemyPos - searchPoint):Length2D()) <= 37 then
		return true
	end

	return false

end

function AIO_Umbrella.TApsiBladesSpillBestPos(myHero, enemy, myAttackRange, searchRange)

	if not myHero then return Vector() end
	if not enemy then return Vector() end

	local myMana = NPC.GetMana(myHero)
	local psiBlades = NPC.GetAbility(myHero, "templar_assassin_psi_blades")
		if not psiBlades then return Vector() end
		if Ability.GetLevel(psiBlades) < 1 then return Vector() end

	local spillRange = Ability.GetLevelSpecialValueFor(psiBlades, "attack_spill_range")

	local enemyPos = AIO_Umbrella.castPrediction(myHero, enemy, 0.75 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))

	local npcs = Entity.GetUnitsInRadius(myHero, myAttackRange+searchRange, Enum.TeamType.TEAM_BOTH)
		if next(npcs) == nil then return Vector() end

		local spillPos = Vector()
		local minRange = 99999
			
		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				if Entity.IsNPC(targetNPC) and not Entity.IsDormant(targetNPC) and (NPC.IsCreep(targetNPC) or NPC.IsLaneCreep(targetNPC) or NPC.IsNeutral(targetNPC)) and Entity.IsAlive(targetNPC) and not NPC.IsRunning(targetNPC) then
					local myDisToNPC = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetNPC)):Length()
					local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length()
					local disEnemyToNPC = (enemyPos - Entity.GetAbsOrigin(targetNPC)):Length()
					if disEnemyToNPC < spillRange - 50 and myDisToNPC < myDisToEnemy then
						if ((Entity.IsSameTeam(myHero, targetNPC) and Entity.GetHealth(targetNPC) < 0.5 * Entity.GetMaxHealth(targetNPC)) or not Entity.IsSameTeam(myHero, targetNPC)) then
							local vecEnemyTospillNPC = Entity.GetAbsOrigin(targetNPC) - enemyPos
							local adjustedNPCPos = Entity.GetAbsOrigin(targetNPC) + vecEnemyTospillNPC:Normalized():Scaled(100)
							local searchPos = adjustedNPCPos + vecEnemyTospillNPC:Normalized():Scaled(myAttackRange - 105)
							local closestPoint = AIO_Umbrella.GetClosestPoint(adjustedNPCPos, searchPos, Entity.GetAbsOrigin(myHero), true)
							local myDisToClostestPoint = (Entity.GetAbsOrigin(myHero) - closestPoint):Length()
							if myDisToClostestPoint < searchRange then
								if myDisToClostestPoint < minRange then
									spillPos = closestPoint
									minRange = myDisToClostestPoint
								end
							end
						end
					end
				end
			end
		end

		if spillPos:__tostring() ~= Vector():__tostring() and minRange > 25 then
			return spillPos
		end

	return Vector()

end

function AIO_Umbrella.TApsiBladesSpill(myHero, enemy, myAttackRange)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)
	local psiBlades = NPC.GetAbility(myHero, "templar_assassin_psi_blades")
		if not psiBlades then return end
		if Ability.GetLevel(psiBlades) < 1 then return end

	local spillRange = Ability.GetLevelSpecialValueFor(psiBlades, "attack_spill_range")

	local npcs = Entity.GetUnitsInRadius(myHero, myAttackRange, Enum.TeamType.TEAM_BOTH)
		if next(npcs) == nil then return end

		local spillNPC
			
		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				if Entity.IsNPC(targetNPC) and not Entity.IsDormant(targetNPC) and (NPC.IsCreep(targetNPC) or NPC.IsLaneCreep(targetNPC) or NPC.IsNeutral(targetNPC)) and Entity.IsAlive(targetNPC) then
					if AIO_Umbrella.isEnemyInSpillRange(myHero, targetNPC, enemy, spillRange) == true then
						spillNPC = targetNPC
					end
				end
			end
		end

		if spillNPC then
			return spillNPC
		end
	
	return

end

function AIO_Umbrella.LegionCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroLegion) then return end

	local odds = NPC.GetAbilityByIndex(myHero, 0)
	local pressTheAttack = NPC.GetAbilityByIndex(myHero, 1)
    	local duel = NPC.GetAbility(myHero, "legion_commander_duel")

	local Blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsEnabled(AIO_Umbrella.optionHeroLegionAutoSave) then
		AIO_Umbrella.LegionSaveAlly(myHero, myMana, pressTheAttack)
	end

	if enemy and Entity.IsAlive(enemy) then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
			if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then 
				if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
					if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(AIO_Umbrella.optionHeroLegionBlinkRange)) then
						if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1199) then
							if Blademail and Ability.IsCastable(Blademail, myMana) and Ability.IsCastable(duel, myMana) then
								Ability.CastNoTarget(Blademail)
								return
							end
							if pressTheAttack and Ability.IsCastable(pressTheAttack, myMana) then
								Ability.CastTarget(pressTheAttack, myHero)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
							if AIO_Umbrella.SleepReady(0.2) then
								Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
								return
							end
						end
					end

					if NPC.IsEntityInRange(myHero, enemy, 200) then
						if Blademail and Ability.IsCastable(Blademail, myMana) and Ability.IsCastable(duel, myMana) then
							Ability.CastNoTarget(Blademail)
							return
						end
						if NPC.IsLinkensProtected(enemy) then
							if AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
								Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), enemy)
								return
							end
						end
						if NPC.IsStunned(enemy) then
							if pressTheAttack and Ability.IsCastable(pressTheAttack, myMana) then
								Ability.CastTarget(pressTheAttack, myHero)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
					if NPC.IsEntityInRange(myHero, enemy, 150) then
						if duel and Ability.IsCastable(duel, myMana) then
							if NPC.HasItem(myHero, "item_armlet", true) and Menu.IsEnabled(AIO_Umbrella.optionItemArmlet) and Menu.IsEnabled(AIO_Umbrella.optionItemArmletCombo) then
								if AIO_Umbrella.armletCurrentHPGain > 0 then
									Ability.CastTarget(duel, enemy)
									return
								end
							else
								Ability.CastTarget(duel, enemy)
								return
							end
						end
					end
				end
			end
			if duel and Ability.IsReady(duel) and Ability.IsCastable(duel, myMana) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true and not NPC.IsEntityInRange(myHero, enemy, 150) then
				local rotationVec = Entity.GetRotation(enemy):GetForward():Normalized()
				local pos = Entity.GetAbsOrigin(enemy) + rotationVec:Scaled(100)
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, pos)
			else	
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			end
		end
	end

		

end

function AIO_Umbrella.LegionSaveAlly(myHero, myMana, pressTheAttack)

	if not myHero then return end
	if not pressTheAttack then return end
		if not Ability.IsCastable(pressTheAttack, myMana) then return end

	if AIO_Umbrella.heroCanCastItems(myHero) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local teamMatesAround = NPC.GetHeroesInRadius(myHero, 690, Enum.TeamType.TEAM_FRIEND)
	if next(teamMatesAround) ~= nil then
		for _, ally in ipairs(teamMatesAround) do
			if ally and Entity.IsHero(ally) and not NPC.IsIllusion(ally) and Entity.IsAlive(ally) then
				if AIO_Umbrella.IsNPCinDanger(myHero, ally) then
					Ability.CastTarget(pressTheAttack, ally)
					break
					return
				end
			end
		end
	end

end

function AIO_Umbrella.SlardarCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSlardar) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local sprint = NPC.GetAbilityByIndex(myHero, 0)
	local crush = NPC.GetAbilityByIndex(myHero, 1)
	local haze = NPC.GetAbility(myHero, "slardar_amplify_damage")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	AIO_Umbrella.itemUsage(myHero, enemy)

	local crushRadius = 300
		if NPC.IsRunning(enemy) then
			crushRadius = 200
		end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, crushRadius) then
			if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
				if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					if Menu.GetValue(AIO_Umbrella.optionHeroSlardarStyle) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
						return
					else
						local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 660, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 330)
						if bestPos ~= nil then
							Ability.CastPosition(blink, bestPos)
							return
						end
					end
				end
			end
			if NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk") then
				if AIO_Umbrella.SleepReady(0.1) then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		else
			
			if NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk") then
				if AIO_Umbrella.SleepReady(0.1) then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			else
				
				if crush and Ability.IsCastable(crush, myMana) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					Ability.CastNoTarget(crush)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
				if AIO_Umbrella.SleepReady(0.3) and NPC.IsLinkensProtected(enemy) then
					if AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
						Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), enemy)
						return
					end
				end
				if AIO_Umbrella.SleepReady(0.3) and haze and Ability.IsCastable(haze, myMana) and NPC.HasModifier(enemy, "modifier_stunned") then
					Ability.CastTarget(haze, enemy)
					return
				end
				if not NPC.IsStunned(enemy) and not Ability.IsReady(crush) then
					if NPC.GetMoveSpeed(enemy) + 20 > NPC.GetMoveSpeed(myHero) then
						if sprint and Ability.IsCastable(sprint, myMana) then
							Ability.CastNoTarget(sprint)
							return
						end
					end
				end
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function AIO_Umbrella.ClinkzCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroClinkz) then return end

	local strafe = NPC.GetAbilityByIndex(myHero, 0)
	local searingArrows = NPC.GetAbilityByIndex(myHero, 1)
	local skeletonWalk = NPC.GetAbilityByIndex(myHero, 2)
	local deathPact = NPC.GetAbility(myHero, "clinkz_death_pact")

	local myMana = NPC.GetMana(myHero)
	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsEnabled(AIO_Umbrella.optionHeroClinkzHarass) then
		if Menu.IsKeyDown(AIO_Umbrella.optionHeroClinkzHarassKey) then
			AIO_Umbrella.ClinkzAutoHarass(myHero, myMana, searingArrows)
		end
	end
	
	if enemy then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
				if strafe and Ability.IsCastable(strafe, myMana) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastNoTarget(strafe)
					return
				end
			end
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end					
end



function AIO_Umbrella.ClinkzAutoHarass(myHero, myMana, searingArrows)

	if not myHero then return end

	if not searingArrows then return end
		if Ability.GetLevel(searingArrows) < 1 then return end
		if not Ability.IsCastable(searingArrows, myMana) then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	local harassTarget = nil
		for _, hero in ipairs(NPC.GetHeroesInRadius(myHero, NPC.GetAttackRange(myHero), Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
				if Entity.IsAlive(hero) and not NPC.HasState(hero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
        				harassTarget = hero
					break
				end
      			end			
		end

	local mousePos = Input.GetWorldCursorPos()
	if harassTarget ~= nil then
		if not AIO_Umbrella.lastHitBackswingChecker(myHero) then
			Ability.CastTarget(searingArrows, harassTarget)
			return
		else
			if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
				return
			end
		end
	else
		if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
			return
		end
	end

	return

end

function AIO_Umbrella.ClinkzAutoUlt(myHero)

	if not myHero then return end

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroClinkz) then return end
	if (os.clock() - AIO_Umbrella.lastTick) < AIO_Umbrella.delay then return end

	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	
	local myMana = NPC.GetMana(myHero)

	local deathPact = NPC.GetAbility(myHero, "clinkz_death_pact")
		if not deathPact then return end
		if not Ability.IsCastable(deathPact, myMana) then return end

	local maxHPcreep
	local maxHP = 0
	for _, creeps in ipairs(NPC.GetUnitsInRadius(myHero, 380, Enum.TeamType.TEAM_ENEMY)) do
		if creeps then
			if Entity.IsHero(creeps) then 
				return 
			end
      			if AIO_Umbrella.IsCreepAncient(creeps) == false and (NPC.IsCreep(creeps) or NPC.IsLaneCreep(creeps)) and Entity.GetMaxHealth(creeps) >= 550 and Entity.GetHealth(creeps) >= maxHP then
           			maxHPcreep = creeps
            			maxHP = Entity.GetMaxHealth(creeps)
        		end
   		end
	end

	if next(NPC.GetUnitsInRadius(myHero, 380, Enum.TeamType.TEAM_ENEMY)) == nil then
		maxHP = 0
	end

	if maxHPcreep then
		if not NPC.HasModifier(myHero, "modifier_clinkz_death_pact") then
			Ability.CastTarget(deathPact, maxHPcreep)
			AIO_Umbrella.makeDelay(Ability.GetCastPoint(deathPact))
			return
		end
	end

end

function AIO_Umbrella.QoPCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroQoP) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local shadowStrike = NPC.GetAbilityByIndex(myHero, 0)
	local qopBlink = NPC.GetAbilityByIndex(myHero, 1)
	local screamOfPain = NPC.GetAbilityByIndex(myHero, 2)
	local sonicWave = NPC.GetAbility(myHero, "queenofpain_sonic_wave")

	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.GetValue(AIO_Umbrella.optionHeroQoPAutoUlt) > 0 then
		AIO_Umbrella.QoPComboUltKS(myHero, sonicWave, aghanims, myMana)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 425) then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroQoPblink) then
				if qopBlink and Ability.IsCastable(qopBlink, myMana) and NPC.IsEntityInRange(myHero, enemy, 1500) then
					Ability.CastPosition(qopBlink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(350)))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end		
		else
			if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(shadowStrike) + NPC.GetCastRangeBonus(myHero)) then
				if AIO_Umbrella.SleepReady(0.1) and shadowStrike and Ability.IsCastable(shadowStrike, myMana) then
					Ability.CastTarget(shadowStrike, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
			if AIO_Umbrella.SleepReady(0.1) and screamOfPain and Ability.IsCastable(screamOfPain, myMana) then
				Ability.CastNoTarget(screamOfPain)
				return
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function AIO_Umbrella.QoPComboUltKS(myHero, sonicWave, aghanims, myMana)

	if not myHero then return end

	if not sonicWave then return end
		if not Ability.IsCastable(sonicWave, myMana) then return end

	if Menu.GetValue(AIO_Umbrella.optionHeroQoPAutoUlt) == 0	then return end

	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end

	for _, hero in ipairs(Entity.GetHeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
		local target = AIO_Umbrella.targetChecker(hero)
		if target and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
			if NPC.GetUnitName(target) == "npc_dota_hero_skeleton_king" then
				local reincarnation = NPC.GetAbility(target, "skeleton_king_reincarnation")
				if reincarnation and Ability.IsReady(reincarnation) then
					break
					return
				end
			end

			local sonicDamage
			if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
				sonicDamage = Ability.GetLevelSpecialValueFor(sonicWave, "damage_scepter")
			else
				sonicDamage = Ability.GetLevelSpecialValueFor(sonicWave, "damage")
			end
			if Menu.GetValue(AIO_Umbrella.optionHeroQoPAutoUlt) == 1 then
				if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
					if Entity.GetHealth(target) <= sonicDamage then
						Ability.CastPosition(sonicWave, (Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(target) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(600)))
						break
						return
					end
				end
			elseif Menu.GetValue(AIO_Umbrella.optionHeroQoPAutoUlt) == 2 then
				if Entity.GetHealth(target) <= sonicDamage then
					Ability.CastPosition(sonicWave, (Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(target) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(600)))
					break
					return
				end
			end
		end
	end

end

function AIO_Umbrella.SvenCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroSven) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local stormHammer = NPC.GetAbilityByIndex(myHero, 0)
	local warCry = NPC.GetAbilityByIndex(myHero, 2)
	local godsStrength = NPC.GetAbility(myHero, "sven_gods_strength")

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local maskOfMadness = NPC.GetItem(myHero, "item_mask_of_madness", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.IsEntityInRange(myHero, enemy, 450) then
			if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
				if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
					if warCry and Ability.IsCastable(warCry, myMana) then
						Ability.CastNoTarget(warCry)
						return
					end
					if godsStrength and Ability.IsCastable(godsStrength, myMana) then
						Ability.CastNoTarget(godsStrength)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
					if AIO_Umbrella.SleepReady(0.05) then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
						return
					end
				end
			end
			if NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk") and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				if AIO_Umbrella.SleepReady(0.1) then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		else
			if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
				
				if NPC.IsLinkensProtected(enemy) then
					if AIO_Umbrella.LinkensBreakerNew(myHero) ~= nil then
						Ability.CastTarget(NPC.GetItem(myHero, AIO_Umbrella.LinkensBreakerNew(myHero), true), enemy)
						return
					end
				end
				if stormHammer and Ability.IsCastable(stormHammer, myMana) and not (NPC.IsLinkensProtected(enemy) or NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE)) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastTarget(stormHammer, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
				if AIO_Umbrella.SleepReady(0.3) and warCry and Ability.IsCastable(warCry, myMana) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastNoTarget(warCry)
					return
				end
				if AIO_Umbrella.SleepReady(0.3) and godsStrength and Ability.IsCastable(godsStrength, myMana) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastNoTarget(godsStrength)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
				if not (Ability.IsCastable(stormHammer, myMana) and Ability.IsCastable(warCry, myMana) and Ability.IsCastable(godsStrength, myMana)) then
					if AIO_Umbrella.SleepReady(0.4) and maskOfMadness and Ability.IsCastable(maskOfMadness, myMana) then
						Ability.CastNoTarget(maskOfMadness)
						return
					end
				end
			end
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function AIO_Umbrella.VisageCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroVisage) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local graveChill = NPC.GetAbilityByIndex(myHero, 0)
	local soulAssumption = NPC.GetAbilityByIndex(myHero, 1)
	local soulMaxStacks = Ability.GetLevelSpecialValueFor(soulAssumption, "stack_limit")
	local myMana = NPC.GetMana(myHero)

	local graveChillRange = 650
		if graveChill and Ability.GetCastRange(graveChill) > graveChillRange then
			graveChillRange = Ability.GetCastRange(graveChill)
		end

	local soulModifier = NPC.GetModifier(myHero, "modifier_visage_soul_assumption")
	local soulStackCounter 
		if soulModifier then
			soulStackCounter = Modifier.GetStackCount(soulModifier)
		end
	
	local familiars = NPC.GetAbility(myHero, "visage_summon_familiars")
	local familiarsLevel = Ability.GetLevel(familiars)

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroVisageInstStunKey) then
		if AIO_Umbrella.VisageInstStunLockTarget == nil then
			if enemy and NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then
				AIO_Umbrella.VisageInstStunLockTarget = enemy
			else
				AIO_Umbrella.VisageInstStunLockTarget = nil
			end
		end
	else
		AIO_Umbrella.VisageInstStunLockTarget = nil
	end

	local familiarEntityTable = {}
	for i = 1, NPCs.Count() do
	local npc = NPCs.Get(i)
		if familiars then
			if npc and npc ~= myHero and Entity.IsSameTeam(myHero, npc) then
				if (Entity.GetOwner(myHero) == Entity.GetOwner(npc) or Entity.OwnedBy(npc, myHero)) then
					if NPC.GetUnitName(npc) == "npc_dota_visage_familiar" .. familiarsLevel then
						if not (NPC.HasModifier(npc, "modifier_visage_summonfamiliars_timer") or NPC.HasModifier(npc, "modifier_rooted")) then
							if Entity.IsAlive(npc) then
								if npc ~= nil then
									table.insert(familiarEntityTable, npc)
								end
							end
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroVisageKS) then
		AIO_Umbrella.VisageSoulAssumptionKS(myHero, myMana, soulAssumption, soulStackCounter)
	end

	if not Menu.IsKeyDown(AIO_Umbrella.optionHeroVisagePanicKey) then
		AIO_Umbrella.VisagePanicTarget = nil
	end

	if next(familiarEntityTable) ~= nil then

		for _, familiarAttack in ipairs(familiarEntityTable) do
			if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
				if familiarAttack and not NPC.IsEntityInRange(familiarAttack, enemy, NPC.GetAttackRange(familiarAttack)) then
					AIO_Umbrella.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, familiarAttack)
				end
			end
			if Menu.IsKeyDown(AIO_Umbrella.optionHeroVisageInstStunKey) then
				if familiarAttack and not NPC.IsEntityInRange(familiarAttack, enemy, NPC.GetAttackRange(familiarAttack)) then
					AIO_Umbrella.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", AIO_Umbrella.VisageInstStunLockTarget, nil, familiarAttack)
				end
			end
		end

		for _, familiarStun in ipairs(familiarEntityTable) do
			if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
				if familiarStun and (os.clock() - AIO_Umbrella.ControlledUnitCastTime) >= (Ability.GetLevelSpecialValueForFloat(NPC.GetAbilityByIndex(familiarStun, 0), "stun_duration") * (1 - (Hero.GetStrengthTotal(enemy) * 0.0015)) - 0.1 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)) then
					AIO_Umbrella.VisageFamiliarControl(myHero, enemy, familiarStun, soulAssumption, soulMaxStacks, soulStackCounter, NPC.GetAbilityByIndex(familiarStun, 0), myMana)
					break
				end
			end
			if Menu.IsKeyDown(AIO_Umbrella.optionHeroVisageInstStunKey) then
				if familiarStun and (os.clock() - AIO_Umbrella.ControlledUnitCastTime) >= (Ability.GetLevelSpecialValueForFloat(NPC.GetAbilityByIndex(familiarStun, 0), "stun_duration") * (1 - (Hero.GetStrengthTotal(enemy) * 0.0015)) - 0.1 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)) then
					AIO_Umbrella.VisageFamiliarInstantStun(myHero, AIO_Umbrella.VisageInstStunLockTarget, familiarStun, NPC.GetAbilityByIndex(familiarStun, 0), myMana)
					break
				end
			end

		end

		for _, familiarSave in ipairs(familiarEntityTable) do
			if Menu.IsEnabled(AIO_Umbrella.optionHeroVisageFamiliarSave) then
				if familiarSave and Entity.GetHealth(familiarSave) < 0.5 * Entity.GetMaxHealth(familiarSave) then
					AIO_Umbrella.VisageFamiliarAutoSaver(myHero, familiarSave, NPC.GetAbilityByIndex(familiarSave, 0))
					break
					return
				end
			end
		end	

		for _, familiarCancel in ipairs(familiarEntityTable) do
			if Menu.IsEnabled(AIO_Umbrella.optionHeroVisageFamiliarCancel) then
				if familiarCancel and (os.clock() - AIO_Umbrella.ControlledUnitCastTime) >= (Ability.GetLevelSpecialValueForFloat(NPC.GetAbilityByIndex(familiarCancel, 0), "stun_duration")) then
					AIO_Umbrella.VisageFamiliarCancelChannelling(myHero, familiarCancel, NPC.GetAbilityByIndex(familiarCancel, 0))
					break
					return
				end
			end
		end	
		
		for _, familiarPanic in pairs(familiarEntityTable) do
			if Menu.IsKeyDown(AIO_Umbrella.optionHeroVisagePanicKey) then
				if familiarPanic then
					AIO_Umbrella.VisageFamiliarPanicStun(myHero, familiarPanic, NPC.GetAbilityByIndex(familiarPanic, 0))
				end
			end
		end

	end
	

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if NPC.IsEntityInRange(myHero, enemy, graveChillRange) then
				if graveChill and Ability.IsCastable(graveChill, myMana) then
					Ability.CastTarget(graveChill, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
				if AIO_Umbrella.SleepReady(0.2) and soulAssumption and Ability.IsCastable(soulAssumption, myMana) then
					if soulMaxStacks <= soulStackCounter then
						Ability.CastTarget(soulAssumption, enemy)
						return
					end
				end
			end	
		end
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function AIO_Umbrella.VisageFamiliarControl(myHero, enemy, familiarEntity, soulAssumption, soulMaxStacks, soulStackCounter, stoneForm, myMana)

	if not familiarEntity then return end
	if not Entity.IsAlive(familiarEntity) then return end

	local familiarAttackCount = 0
		for i, v in pairs(AIO_Umbrella.VisageFamiliarAttackCounter) do
			if v then
				if i == Entity.GetIndex(familiarEntity) then
					if GameRules.GetGameTime() > v[1] + 1 then
						AIO_Umbrella.VisageFamiliarAttackCounter[i] = nil
						familiarAttackCount = 0
					else
						familiarAttackCount = v[2]
					end
				end
			end
		end

	local stunRange = 250
		if NPC.IsRunning(enemy) then
			stunRange = 75
		end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
			if stoneForm and Ability.IsReady(stoneForm) then
				if familiarAttackCount >= Menu.GetValue(AIO_Umbrella.optionHeroVisageDMGStacks) then
					if not NPC.HasModifier(enemy, "modifier_rooted") or not NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
						if NPC.IsEntityInRange(familiarEntity, enemy, stunRange) then
							AIO_Umbrella.ControlledUnitCastTime = os.clock()
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, enemy, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
							return
						else
							if os.clock() - AIO_Umbrella.lastCastTime2 > 0.1 then
								Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(75), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
								AIO_Umbrella.lastCastTime2 = os.clock()
								return
							end
						end
					end
				end
			end
		if soulAssumption and Ability.IsCastable(soulAssumption, myMana) and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)-50) then
			if soulMaxStacks <= soulStackCounter then
				Ability.CastTarget(soulAssumption, enemy)
			end
		end
	end
end

function AIO_Umbrella.VisageFamiliarInstantStun(myHero, enemy, familiarEntity, stoneForm, myMana)

	if not myHero then return end
	if not enemy then return end

	if not familiarEntity then return end
	if not Entity.IsAlive(familiarEntity) then return end

	if not stoneForm then return end
		if not Ability.IsReady(stoneForm) then return end

	local stunRange = 250
		if NPC.IsRunning(enemy) then
			stunRange = 75
		end

	if Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		if stoneForm and Ability.IsReady(stoneForm) then
			if not NPC.HasModifier(enemy, "modifier_rooted") or not NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
				if not NPC.IsEntityInRange(familiarEntity, enemy, stunRange) then
					if os.clock() - AIO_Umbrella.lastCastTime2 > 0.1 then
						NPC.MoveTo(familiarEntity, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(75), false, false)
						AIO_Umbrella.lastCastTime2 = os.clock()
						return
					end
				else
					AIO_Umbrella.ControlledUnitCastTime = os.clock()
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, enemy, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
					return
				end
			end
		end
	end

end

function AIO_Umbrella.VisageFamiliarPanicStun(myHero, familiarEntity, stoneForm)

	if not myHero then return end
	if not familiarEntity then return end

	if not stoneForm then return end

	for _, hero in ipairs(Entity.GetHeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
		local target = AIO_Umbrella.targetChecker(hero)
		if target and Entity.IsAlive(target) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
			if AIO_Umbrella.VisagePanicTarget == nil or (AIO_Umbrella.VisagePanicTarget ~= nil and NPC.GetUnitName(target) ~= AIO_Umbrella.VisagePanicTarget) and not NPC.IsStunned(target) then

				if stoneForm and Ability.IsReady(stoneForm) then
					if not NPC.HasModifier(target, "modifier_rooted") or not NPC.HasModifier(target, "modifier_sheepstick_debuff") then
					local stunRange = 250
						if NPC.IsRunning(target) then
							stunRange = 75
						end
						if not NPC.IsEntityInRange(familiarEntity, target, stunRange) then
							AIO_Umbrella.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", target, Entity.GetAbsOrigin(target) + Entity.GetRotation(target):GetForward():Normalized():Scaled(75), familiarEntity)
							return
						else
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET, myHero, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
							AIO_Umbrella.VisagePanicTarget = NPC.GetUnitName(target)
							return
						end
					end
				end
			end
		end
	end

	if not Ability.IsReady(stoneForm) and not NPC.HasModifier(familiarEntity, "modifier_rooted") then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET, myHero, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
	end
	
end

function AIO_Umbrella.VisageSoulAssumptionKS(myHero, myMana, soulAssumption, soulStackCounter)

	if not myHero then return end

	if not soulAssumption then return end
		if not Ability.IsCastable(soulAssumption, myMana) then return end

	if not soulStackCounter then return end
	if soulStackCounter <= 1 then return end

	local soulAssumptionDMG = (20 + soulStackCounter * 65) * (1 + (Hero.GetIntellectTotal(myHero) / 14 / 100))

	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end

	for _, hero in ipairs(Entity.GetHeroesInRadius(myHero, Ability.GetCastRange(soulAssumption) - 15, Enum.TeamType.TEAM_ENEMY)) do
		local target = AIO_Umbrella.targetChecker(hero)
		if target and Entity.IsAlive(target) and not NPC.IsLinkensProtected(target) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
			if Entity.GetHealth(target) <= soulAssumptionDMG * (1 - NPC.GetMagicalArmorValue(target)) then
				Ability.CastTarget(soulAssumption, target)
				break
				return
			end
		end
	end

end

function AIO_Umbrella.VisageFamiliarAutoSaver(myHero, familiarEntity, stoneForm)

	if not myHero then return end
	if not familiarEntity then return end
	if not Entity.IsAlive(familiarEntity) then return end

	if not stoneForm then return end
		if not Ability.IsReady(stoneForm) then return end

	 if Entity.GetHealth(familiarEntity) < Entity.GetMaxHealth(familiarEntity) * 0.33 then
	 	if stoneForm and Ability.IsReady(stoneForm) and not Ability.IsInAbilityPhase(stoneForm) and not NPC.IsStunned(familiarEntity) and not NPC.IsSilenced(familiarEntity) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET, myHero, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity, true)
			return
		end
	end	

end

function AIO_Umbrella.VisageFamiliarCancelChannelling(myHero, familiarEntity, stoneForm)

	if not myHero then return end
	if not familiarEntity then return end
	if not Entity.IsAlive(familiarEntity) then return end

	if not stoneForm then return end
		if not Ability.IsReady(stoneForm) then return end

	local channellingTable = {
		npc_dota_hero_bane = { "bane_fiends_grip", { 5, 5, 5 } },
		npc_dota_hero_crystal_maiden = { "crystal_maiden_freezing_field", { 10, 10, 10} },
		npc_dota_hero_enigma = { "enigma_black_hole", { 4, 4, 4 } },
		npc_dota_hero_oracle = { "oracle_fortunes_end", { 2.5, 2.5, 2.5, 2.5 } },
		npc_dota_hero_pudge = { "pudge_dismember", { 3, 3, 3 } },
		npc_dota_hero_pugna = { "pugna_life_drain", { 10, 10, 10 } },
		npc_dota_hero_sand_king = { "sandking_epicenter", { 2, 2, 2} },
		npc_dota_hero_shadow_shaman = { "shadow_shaman_shackles", { 2.75, 3.5, 4.25, 5 } },
		npc_dota_hero_tinker = { "tinker_rearm", { 3, 1.5, 0.75 } },
		npc_dota_hero_warlock = { "warlock_upheaval", { 16, 16, 16, 16 } },
		npc_dota_hero_witch_doctor = { "witch_doctor_death_ward", { 8, 8, 8} }
				}
	
	local stunRange = 300

	local cancelEnemies = NPC.GetHeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)
	for _, cancelEnemy in ipairs(cancelEnemies) do
		if cancelEnemy and not NPC.IsDormant(cancelEnemy) and not NPC.IsIllusion(cancelEnemy) and Entity.IsAlive(cancelEnemy) then
			if not NPC.HasState(cancelEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				for i, v in pairs(channellingTable) do
					if (NPC.GetUnitName(cancelEnemy) == i and Ability.IsChannelling(NPC.GetAbility(cancelEnemy, v[1]))) then
						local channellingStartTime = Ability.GetChannelStartTime(NPC.GetAbility(cancelEnemy, v[1]))
						local channellingEndTime = channellingStartTime + v[2][Ability.GetLevel(NPC.GetAbility(cancelEnemy, v[1]))]
						local disToEnemy = (Entity.GetAbsOrigin(familiarEntity) - Entity.GetAbsOrigin(cancelEnemy)):Length2D() - 250
						local timeToStun = (disToEnemy / 430) + 0.6
						if stoneForm and Ability.IsReady(stoneForm) then
							if GameRules.GetGameTime() < channellingEndTime - timeToStun then
								if not NPC.IsEntityInRange(familiarEntity, cancelEnemy, stunRange) then
									if os.clock() - AIO_Umbrella.lastCastTime2 > 0.1 then
										NPC.MoveTo(familiarEntity, Entity.GetAbsOrigin(cancelEnemy), false, false)
										AIO_Umbrella.lastCastTime2 = os.clock()
										return
									end
								else
									AIO_Umbrella.ControlledUnitCastTime = os.clock()
									Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
									break
									return
								end
							end
						end
					elseif NPC.HasModifier(cancelEnemy, "modifier_teleporting") then
						local teleportCreationTime = Modifier.GetCreationTime(NPC.GetModifier(cancelEnemy, "modifier_teleporting"))
						local teleportEndTime = teleportCreationTime + 3
						local disToEnemy = (Entity.GetAbsOrigin(familiarEntity) - Entity.GetAbsOrigin(cancelEnemy)):Length2D() - 250
						local timeToStun = (disToEnemy / 430) + 0.6
						if stoneForm and Ability.IsReady(stoneForm) then
							if GameRules.GetGameTime() < teleportEndTime - timeToStun then
								if not NPC.IsEntityInRange(familiarEntity, cancelEnemy, stunRange) then
									if os.clock() - AIO_Umbrella.lastCastTime2 > 0.1 then
										NPC.MoveTo(familiarEntity, Entity.GetAbsOrigin(cancelEnemy), false, false)
										AIO_Umbrella.lastCastTime2 = os.clock()
										return
									end
								else
									AIO_Umbrella.ControlledUnitCastTime = os.clock()
									Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.ArcTempestTargetIndicator(myHero)

	if not myHero then return end

	if AIO_Umbrella.ArcTempestLockedTarget ~= nil then
		local target = AIO_Umbrella.ArcTempestLockedTarget
		
		if AIO_Umbrella.ArcTempestLockedTargetParticle == 0 then
			local tempestParticle = Particle.Create("particles/units/heroes/hero_sniper/sniper_crosshair.vpcf", Enum.ParticleAttachment.PATTACH_OVERHEAD_FOLLOW, target)
			AIO_Umbrella.ArcTempestLockedTargetParticle = tempestParticle
			AIO_Umbrella.ArcTempestLockedTargetParticleHero = target
		else
			if AIO_Umbrella.ArcTempestLockedTargetParticleHero ~= target then
				Particle.Destroy(AIO_Umbrella.ArcTempestLockedTargetParticle)
				AIO_Umbrella.ArcTempestLockedTargetParticle = 0
			end
		end
	else
		if AIO_Umbrella.ArcTempestLockedTargetParticle > 0 then
			Particle.Destroy(AIO_Umbrella.ArcTempestLockedTargetParticle)
			AIO_Umbrella.ArcTempestLockedTargetParticle = 0
		end			
	end

end

function AIO_Umbrella.ArcWardenCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroArcWarden) then return end

	local flux = NPC.GetAbilityByIndex(myHero, 0)
	local magneticField = NPC.GetAbilityByIndex(myHero, 1)
	local sparkWraith = NPC.GetAbilityByIndex(myHero, 2)
	local tempestDouble = NPC.GetAbility(myHero, "arc_warden_tempest_double")

	local arcWardenAttackRange = NPC.GetAttackRange(myHero)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	
	for i = 1, NPCs.Count() do
        local npc = NPCs.Get(i)
		if tempestDouble then
			if npc and npc ~= myHero then
				if NPC.GetUnitName(npc) == "npc_dota_hero_arc_warden" then
					if NPC.HasModifier(npc, "modifier_arc_warden_tempest_double") then
						if npc ~= nil then
							if Entity.IsAlive(npc) then
								AIO_Umbrella.ArcWardenEntity = npc
								AIO_Umbrella.TempestDoubleHandler(myHero, enemy, npc, tempestDouble, myMana, arcWardenAttackRange)
							end
						end
					end
				end
			end
		end
	end

	local necronomicon = NPC.GetItem(myHero, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(myHero, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end

	AIO_Umbrella.itemUsage(myHero, enemy)

	if tempestDouble then
		if Ability.IsCastable(tempestDouble, myMana) then				
			if Menu.IsKeyDownOnce(AIO_Umbrella.optionArcWardenTempestKey) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				local tempestEnemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
				if tempestEnemy and NPC.IsPositionInRange(tempestEnemy, Input.GetWorldCursorPos(), 700, 0) then
					AIO_Umbrella.ArcTempestLockedTarget = tempestEnemy
					AIO_Umbrella.arcWardenPusher = false
				else
					AIO_Umbrella.ArcTempestLockedTarget = nil
					AIO_Umbrella.arcWardenStatus = 0
				end
				Ability.CastNoTarget(tempestDouble)
				return
			end
		end

		if AIO_Umbrella.ArcWardenEntity ~= nil and Entity.IsAlive(AIO_Umbrella.ArcWardenEntity) then
			local tempestEnemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
			if Menu.IsKeyDownOnce(AIO_Umbrella.optionArcWardenTempestKey) then
				if AIO_Umbrella.ArcTempestLockedTarget == nil then
					if tempestEnemy and NPC.IsPositionInRange(tempestEnemy, Input.GetWorldCursorPos(), 700, 0) then
						AIO_Umbrella.ArcTempestLockedTarget = tempestEnemy
						AIO_Umbrella.arcWardenPusher = false
					else
						AIO_Umbrella.ArcTempestLockedTarget = nil
						AIO_Umbrella.arcWardenStatus = 0
					end
				else
					if tempestEnemy ~= AIO_Umbrella.ArcTempestLockedTarget and NPC.IsPositionInRange(tempestEnemy, Input.GetWorldCursorPos(), 700, 0) then
						AIO_Umbrella.ArcTempestLockedTarget = tempestEnemy
						AIO_Umbrella.arcWardenPusher = false
					else
						AIO_Umbrella.ArcTempestLockedTarget = nil
						AIO_Umbrella.arcWardenStatus = 0
					end
				end	
			end
	
			if AIO_Umbrella.ArcTempestLockedTarget ~= nil then
				if not Entity.IsAlive(AIO_Umbrella.ArcTempestLockedTarget) then
					AIO_Umbrella.ArcTempestLockedTarget = nil
					AIO_Umbrella.arcWardenStatus = 0
			--	elseif Entity.IsDormant(AIO_Umbrella.ArcTempestLockedTarget) then
			--		AIO_Umbrella.ArcTempestLockedTarget = nil
			--		AIO_Umbrella.arcWardenStatus = 0
			--	elseif not NPC.IsEntityInRange(myHero, AIO_Umbrella.ArcTempestLockedTarget, 3000) then
			--		AIO_Umbrella.ArcTempestLockedTarget = nil
			--		AIO_Umbrella.arcWardenStatus = 0
				end
			end
		else
			if not Ability.IsReady(tempestDouble) then
				AIO_Umbrella.ArcTempestLockedTarget = nil
				AIO_Umbrella.arcWardenStatus = 0
			end
		end

		if Menu.IsEnabled(AIO_Umbrella.optionArcWardenTempestParticle) then
			AIO_Umbrella.ArcTempestTargetIndicator(myHero)
		end
	end

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionArcWardenPushKey) then
		if AIO_Umbrella.ArcTempestLockedTarget == nil then
			AIO_Umbrella.arcWardenPusher = not AIO_Umbrella.arcWardenPusher
		else
			AIO_Umbrella.ArcTempestLockedTarget = nil
			AIO_Umbrella.arcWardenPusher = not AIO_Umbrella.arcWardenPusher
		end
	end

	if not tempestDouble then
		AIO_Umbrella.arcWardenPusher = false
		AIO_Umbrella.arcWardenStatus = 0
	else
		if not Ability.IsReady(tempestDouble) then
			if not AIO_Umbrella.ArcWardenEntity or (AIO_Umbrella.ArcWardenEntity and not Entity.IsAlive(AIO_Umbrella.ArcWardenEntity)) then
				AIO_Umbrella.arcWardenPusher = false
				AIO_Umbrella.arcWardenStatus = 0
			end
		end
	end

	if not AIO_Umbrella.arcWardenPusher and AIO_Umbrella.ArcTempestLockedTarget == nil then
		if AIO_Umbrella.arcWardenStatus > 1 then
			AIO_Umbrella.arcWardenStatus = 0
		end
	end

	if AIO_Umbrella.arcWardenPusher then
		if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if tempestDouble and Ability.IsCastable(tempestDouble, myMana) then
				Ability.CastNoTarget(tempestDouble)
				return
			end
		end
	end

	if enemy and NPC.IsEntityInRange(myHero, enemy, 1600) then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
			if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
					if not NPC.IsEntityInRange(myHero, enemy, arcWardenAttackRange + Menu.GetValue(AIO_Umbrella.optionArcWardenBlinkTrigger)) then
						if Menu.IsEnabled(AIO_Umbrella.optionArcWardenMainBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionArcWardenBlinkRange)) then
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionArcWardenBlinkRange))))
							return
						end
					end

					if os.clock() > AIO_Umbrella.lastTick then 
						if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(flux)) then
								if Menu.IsEnabled(AIO_Umbrella.optionHeroArcWardenFlux) and flux and Ability.IsCastable(flux, myMana) and #NPC.GetHeroesInRadius(enemy, 225, Enum.TeamType.TEAM_FRIEND) < 1 then
									Ability.CastTarget(flux, enemy)
									AIO_Umbrella.lastTick = os.clock() + 0.2
									return
								end
							end

							if Menu.IsEnabled(AIO_Umbrella.optionHeroArcWardenSpark) and sparkWraith and Ability.IsCastable(sparkWraith, myMana) then
								local sparkPrediction = 2.3 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								local sparkPos = AIO_Umbrella.castPrediction(myHero, enemy, sparkPrediction)
								if NPC.IsPositionInRange(myHero, sparkPos, 1999) then
									Ability.CastPosition(sparkWraith, sparkPos)
									AIO_Umbrella.lastTick = os.clock() + 0.2
									return
								end
							end
						end
						
						if NPC.IsEntityInRange(myHero, enemy, arcWardenAttackRange) then
							if Menu.IsEnabled(AIO_Umbrella.optionHeroArcWardenMagnetic) and magneticField and Ability.IsCastable(magneticField, myMana) and not NPC.HasModifier(myHero, "modifier_arc_warden_magnetic_field_attack_speed") then
								if os.clock() > AIO_Umbrella.arcWardenMagneticCastTime then
									local pos = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(150)
									Ability.CastPosition(magneticField, pos)
									AIO_Umbrella.lastTick = os.clock() + 0.2
									AIO_Umbrella.arcWardenMagneticCastTime = os.clock() + 0.55
									return
								end
							end

							if necronomicon and Ability.IsCastable(necronomicon, myMana) then
								Ability.CastNoTarget(necronomicon)
								AIO_Umbrella.lastTick = os.clock() + 0.05
								return
							end
						end

						if NPC.IsEntityInRange(myHero, enemy, arcWardenAttackRange + Menu.GetValue(AIO_Umbrella.optionArcWardenBlinkTrigger) - 50) then
							if Menu.IsEnabled(AIO_Umbrella.optionArcWardenComboUlt) and tempestDouble and Ability.IsCastable(tempestDouble, myMana) then
								Ability.CastNoTarget(tempestDouble)
								AIO_Umbrella.lastTick = os.clock() + 0.2
								return
							end
						end
					end
				end
			end

			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			for _, necro in ipairs(AIO_Umbrella.GetNecronomiconEntityTable(myHero, myHero)) do
				AIO_Umbrella.NecronomiconController(necro, enemy, nil)
			end
			if #AIO_Umbrella.GetIllusionEntityTable(myHero, myHero) > 0 then
				AIO_Umbrella.MantaIlluController(enemy, nil, myHero, myHero)
			end

			return
		end
	end

end

function AIO_Umbrella.TempestInAttackAnimation(myHero)

	if not myHero then return false end
	if AIO_Umbrella.ArcWardenEntity == nil then return false end
	if not Entity.IsAlive(AIO_Umbrella.ArcWardenEntity) then return false end

	if AIO_Umbrella.ArcWardenEntityAnimationStart < 1 then return false end
	if AIO_Umbrella.ArcWardenEntityAnimationEnd < 1 then return false end

	if GameRules.GetGameTime() > AIO_Umbrella.ArcWardenEntityAnimationEnd then return false end

	if GameRules.GetGameTime() >= AIO_Umbrella.ArcWardenEntityAnimationStart then
		if GameRules.GetGameTime() <= AIO_Umbrella.ArcWardenEntityAnimationEnd then
			return true
		end
	end

	return false

end

function AIO_Umbrella.TempestTrackLockedTargetLocation(myHero, target)

	if not myHero then return end
	if not target then
		AIO_Umbrella.ArcTempestLockedTargetPos = Vector()
		AIO_Umbrella.ArcTempestLockedTargetPosTimer = 0
		return 
	end

	if not Entity.IsDormant(target) then
		if os.clock() > AIO_Umbrella.ArcTempestLockedTargetPosTimer then
			AIO_Umbrella.ArcTempestLockedTargetPos = Entity.GetAbsOrigin(target)
			AIO_Umbrella.ArcTempestLockedTargetPosTimer = os.clock() + 0.5
			return
		end
	end

	return

end

function AIO_Umbrella.TempestOrbWalker(myHero, tempestDoubleEntity, enemy)

	if not tempestDoubleEntity then return end
	if not enemy then return end

	if NPC.IsChannellingAbility(tempestDoubleEntity) then return end

	local attackRange = NPC.GetAttackRange(tempestDoubleEntity)

	local increasedAS = NPC.GetIncreasedAttackSpeed(tempestDoubleEntity)
	local attackTime = NPC.GetAttackTime(tempestDoubleEntity)
	local movementSpeed = NPC.GetMoveSpeed(tempestDoubleEntity)

	local attackPoint = 0.3 / (1 + (increasedAS/100))
	local attackBackSwing = 0.7 / (1 + (increasedAS/100))

	local idleTime = math.max(attackTime - attackPoint - attackBackSwing, 0)

	if AIO_Umbrella.ArcWardenEntityProjectileCreate > 0 then
		if GameRules.GetGameTime() > AIO_Umbrella.ArcWardenEntityAnimationStart and GameRules.GetGameTime() < AIO_Umbrella.ArcWardenEntityProjectileCreate + attackBackSwing + idleTime then
			AIO_Umbrella.TempestInAttackBackswing = true
		else
			AIO_Umbrella.TempestInAttackBackswing = false
		end
	end
	

	if GameRules.GetGameTime() > AIO_Umbrella.ArcWardenEntityAnimationStart and GameRules.GetGameTime() < AIO_Umbrella.AttackProjectileCreate then
		AIO_Umbrella.TempestInAttackBackswing = false
	end

	local breakPoint = attackRange * 0.7

	local moveDistance = NPC.GetMoveSpeed(tempestDoubleEntity) * (attackBackSwing + idleTime - NPC.GetTimeToFace(tempestDoubleEntity, enemy)) * 0.9
		if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() > breakPoint and (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() <= breakPoint + moveDistance then
			moveDistance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() - breakPoint
		end
	
	if not AIO_Umbrella.TempestInAttackBackswing then
		if os.clock() - AIO_Umbrella.TempestOrbwalkerDelay > 0.05 + attackPoint + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and GameRules.GetGameTime() - AIO_Umbrella.ArcWardenEntityAnimationStart > attackPoint + 0.1 then
			Player.AttackTarget(Players.GetLocal(), tempestDoubleEntity, enemy, false)
			AIO_Umbrella.TempestOrbwalkerDelay = os.clock()
			return
		end
	else
		if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() > breakPoint then
			if os.clock() - AIO_Umbrella.TempestOrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if moveDistance > 50 then
					local targetVector = Entity.GetAbsOrigin(tempestDoubleEntity) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Normalized():Scaled(moveDistance)
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, targetVector, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity, queue, showEffects)
					AIO_Umbrella.TempestOrbwalkerDelay = os.clock()
					return
				end
			end
		end
	end

end

function AIO_Umbrella.TempestDoubleHandler(myHero, enemy, tempestDoubleEntity, tempestDouble, myMana, arcWardenAttackRange)
	
	if not tempestDoubleEntity then return end
	if not Entity.IsAlive(tempestDoubleEntity) then return end
	if tempestDoubleEntity == myHero then return end
	if os.clock() - AIO_Umbrella.ControlledUnitPauseTime < 3.1 then return end

	if AIO_Umbrella.heroCanCastSpells(tempestDoubleEntity) == false then return end

	local travelBoots1 = NPC.GetItem(tempestDoubleEntity, "item_travel_boots", true)
	local travelBoots2 = NPC.GetItem(tempestDoubleEntity, "item_travel_boots_2", true)
	local wardenMana = NPC.GetMana(tempestDoubleEntity)

	local TPing = nil
		if travelBoots1 and Ability.IsCastable(travelBoots1, wardenMana) then
			TPing = travelBoots1
		elseif travelBoots2 and Ability.IsCastable(travelBoots2, wardenMana) then
			TPing = travelBoots2
		end
		local tempestMod = NPC.GetModifier(tempestDoubleEntity, "modifier_kill")
		if tempestMod then
			local tempestCreaTime = Modifier.GetCreationTime(tempestMod)
			local tempestDieTime = Modifier.GetDieTime(tempestMod)
			if GameRules.GetGameTime() > tempestCreaTime + 0.35 * (tempestDieTime - tempestCreaTime) then
				TPing = nil
			end
		end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
		if enemy and Entity.GetHealth(enemy) > 0 then
			if AIO_Umbrella.ArcTempestLockedTarget == nil then
				AIO_Umbrella.ArcWardenFight(myHero, enemy, tempestDoubleEntity, arcWardenAttackRange)
				AIO_Umbrella.arcWardenStatus = 1
			end
		end
	else
		if AIO_Umbrella.arcWardenStatus == 1 and AIO_Umbrella.ArcTempestLockedTarget == nil then
			AIO_Umbrella.arcWardenStatus = 0
		end
	end

	if AIO_Umbrella.ArcTempestLockedTarget ~= nil then
		AIO_Umbrella.TempestTrackLockedTargetLocation(myHero, AIO_Umbrella.ArcTempestLockedTarget)
		if not Entity.IsDormant(AIO_Umbrella.ArcTempestLockedTarget) then
			AIO_Umbrella.ArcWardenFight(myHero, AIO_Umbrella.ArcTempestLockedTarget, tempestDoubleEntity, arcWardenAttackRange)
			AIO_Umbrella.arcWardenStatus = 1
		else
			AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, AIO_Umbrella.ArcTempestLockedTargetPos, tempestDoubleEntity)
			AIO_Umbrella.arcWardenStatus = 1
			if NPC.IsPositionInRange(tempestDoubleEntity, AIO_Umbrella.ArcTempestLockedTargetPos, 100, 0) then
				AIO_Umbrella.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
				AIO_Umbrella.arcWardenStatus = 5
				AIO_Umbrella.ArcTempestLockedTargetPos = Entity.GetAbsOrigin(tempestDoubleEntity)
			end
		end	
	end

	if AIO_Umbrella.arcWardenPusher then
		if TPing then
			if AIO_Umbrella.ArcWardenPort(myHero) ~= nil and not NPC.IsPositionInRange(tempestDoubleEntity, AIO_Umbrella.ArcWardenPort(myHero), Menu.GetValue(AIO_Umbrella.optionArcWardenPushTPRange)) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, AIO_Umbrella.ArcWardenPort(myHero), TPing, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				AIO_Umbrella.arcWardenStatus = 3
				AIO_Umbrella.ControlledUnitPauseTime = os.clock()
				return
			else
				AIO_Umbrella.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
				AIO_Umbrella.arcWardenStatus = 2
			end
		else
			if not NPC.HasModifier(tempestDoubleEntity ,"modifier_teleporting") then
				if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
					if not ((travelBoots1 and Ability.IsReady(travelBoots1)) or (travelBoots2 and Ability.IsReady(travelBoots2))) then
						AIO_Umbrella.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
						AIO_Umbrella.arcWardenStatus = 4
					else
						AIO_Umbrella.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
						AIO_Umbrella.arcWardenStatus = 2
					end
				else
					AIO_Umbrella.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
					AIO_Umbrella.arcWardenStatus = 2
				end
			end
		end
	end
			
	if not NPC.HasModifier(tempestDoubleEntity ,"modifier_teleporting") then
		AIO_Umbrella.utilityItemMidas(tempestDoubleEntity, NPC.GetItem(tempestDoubleEntity, "item_hand_of_midas", true))
	end

end	

function AIO_Umbrella.ArcWardenFight(myHero, enemy, tempestDoubleEntity, arcWardenAttackRange)

	if not tempestDoubleEntity then return end
	if not enemy then return end
	if not Entity.IsAlive(tempestDoubleEntity) then return end
	if tempestDoubleEntity == myHero then return end

	if AIO_Umbrella.heroCanCastSpells(tempestDoubleEntity) == false then return end

	local flux = NPC.GetAbilityByIndex(tempestDoubleEntity, 0)
	local magneticField = NPC.GetAbilityByIndex(tempestDoubleEntity, 1)
	local sparkWraith = NPC.GetAbilityByIndex(tempestDoubleEntity, 2)

	local blink = NPC.GetItem(tempestDoubleEntity, "item_blink", true)
	local shadowBlade = NPC.GetItem(tempestDoubleEntity, "item_invis_sword", true)
	local silverEdge = NPC.GetItem(tempestDoubleEntity, "item_silver_edge", true)
	local bkb = NPC.GetItem(tempestDoubleEntity, "item_black_king_bar", true)

	local necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end	 

	local wardenMana = NPC.GetMana(tempestDoubleEntity)

	if shadowBlade and Ability.IsCastable(shadowBlade, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), shadowBlade, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		AIO_Umbrella.noItemCastFor(0.5)
		AIO_Umbrella.ControlledUnitCastTime = os.clock() + 0.25
		return
	end

	if silverEdge and Ability.IsCastable(silverEdge, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), silverEdge, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		AIO_Umbrella.noItemCastFor(0.5)
		AIO_Umbrella.ControlledUnitCastTime = os.clock() + 0.25
		return
	end

	AIO_Umbrella.itemUsageSmartOrder(tempestDoubleEntity, enemy, true)
	AIO_Umbrella.TempestOrbWalker(myHero, tempestDoubleEntity, enemy)

	if not NPC.IsEntityInRange(tempestDoubleEntity, enemy, arcWardenAttackRange + 250) then
		if blink and Ability.IsReady(blink) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(tempestDoubleEntity) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250)), blink, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		end
	end

	if NPC.IsEntityInRange(tempestDoubleEntity, enemy, arcWardenAttackRange) then
		if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.GetAvgLatency() and necronomicon and Ability.IsCastable(necronomicon, wardenMana) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), necronomicon, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
			AIO_Umbrella.ControlledUnitCastTime = os.clock()
		end

		if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.GetAvgLatency() and bkb and Ability.IsReady(bkb) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), bkb, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
			AIO_Umbrella.ControlledUnitCastTime = os.clock()
		end
	end

	if not (NPC.HasModifier(tempestDoubleEntity, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(tempestDoubleEntity, "modifier_item_silver_edge_windwalk")) then
		if NPC.IsEntityInRange(tempestDoubleEntity, enemy, Ability.GetCastRange(flux)) then
			if NPC.IsLinkensProtected(enemy) and (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.CastAnimationDelay(flux) and flux and Ability.IsCastable(flux, wardenMana) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, enemy, Vector(0,0,0), flux, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				AIO_Umbrella.ControlledUnitCastTime = os.clock()
				return
			end
		
			if Menu.IsEnabled(AIO_Umbrella.optionHeroArcWardenFlux) and (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.CastAnimationDelay(flux) and flux and Ability.IsCastable(flux, wardenMana) and #NPC.GetHeroesInRadius(enemy, 225, Enum.TeamType.TEAM_FRIEND) < 1 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, enemy, Vector(0,0,0), flux, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				AIO_Umbrella.ControlledUnitCastTime = os.clock()
				return
			end
		end

		if NPC.IsEntityInRange(tempestDoubleEntity, enemy, arcWardenAttackRange) then
			if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.CastAnimationDelay(magneticField) and magneticField and Ability.IsCastable(magneticField, wardenMana) and not NPC.HasModifier(tempestDoubleEntity, "modifier_arc_warden_magnetic_field_attack_speed") and not Ability.IsInAbilityPhase(NPC.GetAbilityByIndex(myHero, 1)) and NPC.IsEntityInRange(tempestDoubleEntity, enemy, NPC.GetAttackRange(tempestDoubleEntity)) then
				if os.clock() > AIO_Umbrella.arcWardenMagneticCastTime then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, Entity.GetAbsOrigin(tempestDoubleEntity) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Normalized():Scaled(50), magneticField, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
					AIO_Umbrella.ControlledUnitCastTime = os.clock()
					AIO_Umbrella.arcWardenMagneticCastTime = os.clock() + 0.55
					return
				end
			end
		end

		if NPC.IsEntityInRange(tempestDoubleEntity, enemy, 2000) then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroArcWardenSpark) and sparkWraith and (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.CastAnimationDelay(sparkWraith) and Ability.IsCastable(sparkWraith, wardenMana) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local sparkPrediction = 2.3 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				local sparkPos = AIO_Umbrella.castPrediction(tempestDoubleEntity, enemy, sparkPrediction)
				if NPC.IsPositionInRange(tempestDoubleEntity, sparkPos, 1999) then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, sparkPos, sparkWraith, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
					AIO_Umbrella.ControlledUnitCastTime = os.clock()
					return
				end
			end
		end
	end
	
	for _, necro in ipairs(AIO_Umbrella.GetNecronomiconEntityTable(myHero, tempestDoubleEntity)) do
		AIO_Umbrella.NecronomiconController(necro, enemy, nil)
	end

	if #AIO_Umbrella.GetIllusionEntityTable(myHero, tempestDoubleEntity) > 0 then
		AIO_Umbrella.MantaIlluController(enemy, nil, myHero, tempestDoubleEntity)
	end

end
	
function AIO_Umbrella.ArcWardenPort(myHero)

	local enemyFountainPos = AIO_Umbrella.GetEnemyFountainPos(myHero)
	local myFountainPos = AIO_Umbrella.GetMyFountainPos(myHero)

	if AIO_Umbrella.arcWardenPushMode then
		local targetCreep
		local maxDistance = 99999
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and Entity.IsAlive(npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not NPC.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if npc ~= nil then
						local creepPosition = Entity.GetAbsOrigin(npc)
						local distanceToMouse = (creepPosition - Input.GetWorldCursorPos()):Length2D()
						if distanceToMouse < maxDistance then
							targetCreep = npc
							maxDistance = distanceToMouse
						end
					end
				end
			end
		end

		if targetCreep == nil then
			maxDistance = 99999
		end

		if targetCreep then
			return Entity.GetAbsOrigin(targetCreep)
		end
	else
		local targetCreep
		local pushDistance = 99999
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not NPC.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if #NPC.GetUnitsInRadius(npc, 1200, Enum.TeamType.TEAM_ENEMY) >= 3 and #NPC.GetHeroesInRadius(npc, 900, Enum.TeamType.TEAM_ENEMY) <= 1  and #NPC.GetHeroesInRadius(npc, 1000, Enum.TeamType.TEAM_FRIEND) <= 1 then
						if (Entity.GetHealth(npc) / Entity.GetMaxHealth(npc)) >= 0.8 and #NPC.GetUnitsInRadius(npc, 500, Enum.TeamType.TEAM_FRIEND) >= 2 then	
							if npc ~= nil then
								if (Entity.GetAbsOrigin(npc) - Entity.GetAbsOrigin(myHero)):Length2D() > 3000 then
									if not AIO_Umbrella.arcWardenPushModeLine then
										if (Entity.GetAbsOrigin(npc) - enemyFountainPos):Length2D() < pushDistance then
											targetCreep = npc
											pushDistance = (Entity.GetAbsOrigin(npc) - enemyFountainPos):Length2D()
											break
										end
									else
										if (Entity.GetAbsOrigin(npc) - myFountainPos):Length2D() < pushDistance then
											targetCreep = npc
											pushDistance = (Entity.GetAbsOrigin(npc) - myFountainPos):Length2D()
											break
										end
									end
								end
							end
						end
					end
				end
			end
		end

		if targetCreep == nil then
			pushDistance = 99999
		end

		if targetCreep ~= nil then
			return Entity.GetAbsOrigin(targetCreep)
		end
	end
end

function AIO_Umbrella.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
	
	if not tempestDoubleEntity then return end
	if not Entity.IsAlive(tempestDoubleEntity) then return end
	if tempestDoubleEntity == myHero then return end

	local wardenMana = NPC.GetMana(tempestDoubleEntity)
	local mantaStyle = NPC.GetItem(tempestDoubleEntity, "item_manta", true)

	AIO_Umbrella.utilityItemMidas(tempestDoubleEntity, NPC.GetItem(tempestDoubleEntity, "item_hand_of_midas", true))

	local necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end

	local mjollnir = NPC.GetItem(tempestDoubleEntity, "item_mjollnir", true)

	if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.GetAvgLatency() and necronomicon and Ability.IsCastable(necronomicon, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), necronomicon, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		AIO_Umbrella.ControlledUnitCastTime = os.clock()
	end
	if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.GetAvgLatency() and mantaStyle and Ability.IsCastable(mantaStyle, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), mantaStyle, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		AIO_Umbrella.ControlledUnitCastTime = os.clock()
	end
	if NPC.HasModifier(tempestDoubleEntity, "modifier_kill") then
		local tempestDieTime = Modifier.GetDieTime(NPC.GetModifier(tempestDoubleEntity, "modifier_kill"))
		if tempestDieTime - GameRules.GetGameTime() < 2.5 then
			if mjollnir and Ability.IsCastable(mjollnir, wardenMana) then
				for _, allyCreep in ipairs(Entity.GetUnitsInRadius(tempestDoubleEntity, 825, Enum.TeamType.TEAM_FRIEND)) do
					if allyCreep and Entity.IsAlive(allyCreep) and NPC.IsLaneCreep(allyCreep) and not NPC.IsRanged(allyCreep) and Entity.GetHealth(allyCreep) > Entity.GetMaxHealth(allyCreep) * 0.6 then
						if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.GetAvgLatency() then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, allyCreep, Vector(0,0,0), mjollnir, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
							AIO_Umbrella.ControlledUnitCastTime = os.clock()
						end
					end
				end
			end
		end
	end

	local targetHero
	local enemyHeroHealth = 99999
	local targetCreep
	local enemyCreepHealth = 99999
	for i, heroes in ipairs(NPC.GetHeroesInRadius(tempestDoubleEntity, 799, Enum.TeamType.TEAM_ENEMY)) do
		if heroes then
        		if Entity.IsAlive(heroes) and not Entity.IsDormant(heroes) and not NPC.HasState(heroes, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsIllusion(heroes) then
				if Entity.GetHealth(heroes) < enemyHeroHealth then
					targetHero = heroes
					enemyHeroHealth = Entity.GetHealth(heroes)
				end
			end
		end
	end
	if #NPC.GetHeroesInRadius(tempestDoubleEntity, 799, Enum.TeamType.TEAM_ENEMY) < 1 then
		for i = 1, NPCs.Count() do 
		local creeps = NPCs.Get(i)
			if creeps and Entity.IsNPC(creeps) and not Entity.IsSameTeam(myHero, creeps) then
				if NPC.IsEntityInRange(tempestDoubleEntity, creeps, 799) then
					if Entity.IsAlive(creeps) and not Entity.IsDormant(creeps) and NPC.IsKillable(creeps) and not NPC.IsWaitingToSpawn(creeps) and NPC.GetUnitName(creeps) ~= "npc_dota_neutral_caster" then
						if Entity.GetHealth(creeps) < enemyCreepHealth then
							if creeps ~= nil then
								targetCreep = creeps
								enemyCreepHealth = Entity.GetHealth(creeps)
							end
						end
					end
				end
			end
		end
	end
	
	if #NPC.GetUnitsInRadius(tempestDoubleEntity, 800, Enum.TeamType.TEAM_ENEMY) < 1 then
		targetHero = nil
		enemyHeroHealth = 99999
		targetCreep = nil
		enemyCreepHealth = 99999
	end
	
	if targetHero then
		AIO_Umbrella.ArcWardenFight(myHero, targetHero, tempestDoubleEntity, arcWardenAttackRange)
		if not NPC.IsLinkensProtected(targetHero) then
			AIO_Umbrella.itemUsageSmartOrder(tempestDoubleEntity, targetHero, true)
		end
	end

	if targetCreep then

		if not AIO_Umbrella.TempestInAttackAnimation(myHero) then
			AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", targetCreep, nil, tempestDoubleEntity)
		end

		if #NPC.GetUnitsInRadius(tempestDoubleEntity, 625, Enum.TeamType.TEAM_ENEMY) >= 3 then
			if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.CastAnimationDelay(NPC.GetAbilityByIndex(tempestDoubleEntity, 1)) and NPC.GetAbilityByIndex(tempestDoubleEntity, 1) and Ability.IsCastable(NPC.GetAbilityByIndex(tempestDoubleEntity, 1), wardenMana) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, Entity.GetAbsOrigin(tempestDoubleEntity) + Entity.GetRotation(tempestDoubleEntity):GetForward():Normalized():Scaled(75), NPC.GetAbilityByIndex(tempestDoubleEntity, 1), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				AIO_Umbrella.ControlledUnitCastTime = os.clock()
				return
			end
		end
		if NPC.IsEntityInRange(tempestDoubleEntity, targetCreep, 1900) then
			if (os.clock() - AIO_Umbrella.ControlledUnitCastTime) > AIO_Umbrella.CastAnimationDelay(NPC.GetAbilityByIndex(tempestDoubleEntity, 2)) and NPC.GetAbilityByIndex(tempestDoubleEntity, 2) and Ability.IsCastable(NPC.GetAbilityByIndex(tempestDoubleEntity, 2), wardenMana) and not NPC.IsStructure(targetCreep) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, Entity.GetAbsOrigin(targetCreep), NPC.GetAbilityByIndex(tempestDoubleEntity, 2), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				AIO_Umbrella.ControlledUnitCastTime = os.clock()
				return
			end
		end
		for _, necro in ipairs(AIO_Umbrella.GetNecronomiconEntityTable(myHero, tempestDoubleEntity)) do
			AIO_Umbrella.NecronomiconController(necro, nil, AIO_Umbrella.GenericLanePusher(tempestDoubleEntity))
		end
		if #AIO_Umbrella.GetIllusionEntityTable(myHero, tempestDoubleEntity) > 0 then
			AIO_Umbrella.MantaIlluController(nil, AIO_Umbrella.GenericLanePusher(tempestDoubleEntity), myHero, tempestDoubleEntity)
		end		
	end

	if not targetHero and not targetCreep then

		if not AIO_Umbrella.TempestInAttackAnimation(myHero) then
			AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, AIO_Umbrella.GenericLanePusher(tempestDoubleEntity), tempestDoubleEntity)
		end

		for _, necro in ipairs(AIO_Umbrella.GetNecronomiconEntityTable(myHero, tempestDoubleEntity)) do
			AIO_Umbrella.NecronomiconController(necro, nil, AIO_Umbrella.GenericLanePusher(tempestDoubleEntity))
		end

		if #AIO_Umbrella.GetIllusionEntityTable(myHero, tempestDoubleEntity) > 0 then
			AIO_Umbrella.MantaIlluController(nil, AIO_Umbrella.GenericLanePusher(tempestDoubleEntity), myHero, tempestDoubleEntity)
		end
	end
end

function AIO_Umbrella.drawArcWardenPanel(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroArcWarden) then return end
	
	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroArcWardenPanelKey) then
		AIO_Umbrella.Toggler = not AIO_Umbrella.Toggler
	end
	
	if AIO_Umbrella.Toggler then return end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	if AIO_Umbrella.arcWardenPanelX ~= Config.ReadInt("arcWarden", "panelX", w/2) then
		AIO_Umbrella.arcWardenPanelX = Config.ReadInt("arcWarden", "panelX", w/2)
	end
	if AIO_Umbrella.arcWardenPanelY ~= Config.ReadInt("arcWarden", "panelY", h/2) then
		AIO_Umbrella.arcWardenPanelY = Config.ReadInt("arcWarden", "panelY", h/2)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroArcWardenPanelMove) then
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_UP) then
			AIO_Umbrella.arcWardenPanelY = AIO_Umbrella.arcWardenPanelY - 10
			Config.WriteInt("arcWarden", "panelY", AIO_Umbrella.arcWardenPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_DOWN) then
			AIO_Umbrella.arcWardenPanelY = AIO_Umbrella.arcWardenPanelY + 10
			Config.WriteInt("arcWarden", "panelY", AIO_Umbrella.arcWardenPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_LEFT) then
			AIO_Umbrella.arcWardenPanelX = AIO_Umbrella.arcWardenPanelX - 10
			Config.WriteInt("arcWarden", "panelX", AIO_Umbrella.arcWardenPanelX)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_RIGHT) then
			AIO_Umbrella.arcWardenPanelX = AIO_Umbrella.arcWardenPanelX + 10
			Config.WriteInt("arcWarden", "panelX", AIO_Umbrella.arcWardenPanelX)
		end
	end

	local startX = AIO_Umbrella.arcWardenPanelX
	local startY = AIO_Umbrella.arcWardenPanelY

	local width = 120
	local height = 277

	 -- black background
	Renderer.SetDrawColor(0, 0, 0, 125)
	Renderer.DrawFilledRect(startX, startY, width, height)


	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY, width, height)

	Renderer.SetDrawColor(255, 0, 0, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startX + width/2, startY + 10, "OPTIONS", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startX+1, startY+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startX + width/2, startY + 30, "TP Push", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+21, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY+40, width/2, 20)
	Renderer.DrawOutlineRect(startX + width/2, startY+40, width/2, 20)

	local hoveringOverAuto = Input.IsCursorInRect(startX, startY+40, width/2, 20)
	local hoveringOverCursor = Input.IsCursorInRect(startX + width/2, startY+40, width/2, 20)

	if hoveringOverAuto and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if AIO_Umbrella.arcWardenPushMode then
			AIO_Umbrella.arcWardenPushMode = not AIO_Umbrella.arcWardenPushMode
		end
	end

	if hoveringOverCursor and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if not AIO_Umbrella.arcWardenPushMode then
			AIO_Umbrella.arcWardenPushMode = not AIO_Umbrella.arcWardenPushMode
		end
	end
	
	if not AIO_Umbrella.arcWardenPushMode then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	end

	Renderer.SetDrawColor(0, 191, 255, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startX + width/2, startY + 70, "line select", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+61, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY+80, width/2, 20)
	Renderer.DrawOutlineRect(startX + width/2, startY+80, width/2, 20)

	local hoveringOverFurthest = Input.IsCursorInRect(startX, startY+80, width/2, 20)
	local hoveringOverLeast = Input.IsCursorInRect(startX + width/2, startY+80, width/2, 20)

	if hoveringOverFurthest and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if AIO_Umbrella.arcWardenPushModeLine then
			AIO_Umbrella.arcWardenPushModeLine = not AIO_Umbrella.arcWardenPushModeLine
		end
	end

	if hoveringOverLeast and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if not AIO_Umbrella.arcWardenPushModeLine then
			AIO_Umbrella.arcWardenPushModeLine = not AIO_Umbrella.arcWardenPushModeLine
		end
	end
	
	if AIO_Umbrella.arcWardenPushMode then
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4, startY + 80, "min", 0)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3, startY + 80, "max", 0)
	else
		if not AIO_Umbrella.arcWardenPushModeLine then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4, startY + 80, "min", 0)
			Renderer.SetDrawColor(255, 255, 255, 75)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3, startY + 80, "max", 0)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4, startY + 80, "min", 0)
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3, startY + 80, "max", 0)
		end
	end

	local startXinfo = startX
	local startYinfo = startY + 110

	Renderer.SetDrawColor(255, 0, 0, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 10, "INFORMATION", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startXinfo+1, startYinfo+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 30, "Clone action", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startYinfo+21, width-2, 20-2)

	if AIO_Umbrella.ArcWardenEntity == nil then
		Renderer.SetDrawColor(255, 100, 0, 255)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/2, startYinfo + 40, "not spawned", 0)
	else	
		if AIO_Umbrella.arcWardenStatus == 0 then
			if not Entity.IsAlive(AIO_Umbrella.ArcWardenEntity) then
				Renderer.SetDrawColor(255, 100, 0, 255)
				Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/2, startYinfo + 40, "dead", 0)
			else
				Renderer.SetDrawColor(255, 100, 0, 255)
				Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/2, startYinfo + 40, "idle", 0)
			end
		elseif AIO_Umbrella.arcWardenStatus == 1 and AIO_Umbrella.ArcTempestLockedTarget ~= nil then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "comboing", 0)
			local heroName = NPC.GetUnitName(AIO_Umbrella.ArcTempestLockedTarget)
			local heroNameShort = string.gsub(heroName, "npc_dota_hero_", "")
			local imageHandle
				if AIO_Umbrella.heroIconHandler[heroNameShort] ~= nil then
					imageHandle = AIO_Umbrella.heroIconHandler[heroNameShort]
				else
					imageHandle = Renderer.LoadImage(AIO_Umbrella.heroIconPath .. heroNameShort .. ".png")
					AIO_Umbrella.heroIconHandler[heroNameShort] = imageHandle
				end
			Renderer.SetDrawColor(255, 255, 255, 255)
			Renderer.DrawImage(imageHandle, startX + width/2 - 35, startYinfo + 58, 67, 48)
		elseif AIO_Umbrella.arcWardenStatus == 1 and AIO_Umbrella.ArcTempestLockedTarget == nil and AIO_Umbrella.LockedTarget ~= nil then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "main comboing", 0)
			local heroName = NPC.GetUnitName(AIO_Umbrella.LockedTarget)
			local heroNameShort = string.gsub(heroName, "npc_dota_hero_", "")
			local imageHandle
				if AIO_Umbrella.heroIconHandler[heroNameShort] ~= nil then
					imageHandle = AIO_Umbrella.heroIconHandler[heroNameShort]
				else
					imageHandle = Renderer.LoadImage(AIO_Umbrella.heroIconPath .. heroNameShort .. ".png")
					AIO_Umbrella.heroIconHandler[heroNameShort] = imageHandle
				end
			Renderer.SetDrawColor(255, 255, 255, 255)
			Renderer.DrawImage(imageHandle, startX + width/2 - 35, startYinfo + 58, 67, 48)
		elseif AIO_Umbrella.arcWardenStatus == 2 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "pushing", 0)
		elseif AIO_Umbrella.arcWardenStatus == 3 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "tping", 0)
		elseif AIO_Umbrella.arcWardenStatus == 4 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "TP pushing", 0)
		elseif AIO_Umbrella.arcWardenStatus == 5 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "hunting", 0)
		end
	end
					
	Renderer.SetDrawColor(0, 191, 255, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 120, "Clone CDs", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startYinfo+111, width-2, 20-2)

	if AIO_Umbrella.ArcWardenEntity == nil then return end

	local travelBoots1 = NPC.GetItem(AIO_Umbrella.ArcWardenEntity, "item_travel_boots", true)
	local travelBoots2 = NPC.GetItem(AIO_Umbrella.ArcWardenEntity, "item_travel_boots_2", true)
	local midas = NPC.GetItem(AIO_Umbrella.ArcWardenEntity, "item_hand_of_midas", true)
	local necronomicon = NPC.GetItem(AIO_Umbrella.ArcWardenEntity, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(AIO_Umbrella.ArcWardenEntity, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end

	local tempTable = {}
	if travelBoots1 then
		table.insert(tempTable, travelBoots1)
	end
	if travelBoots2 then
		table.insert(tempTable, travelBoots2)
	end
	if midas then
		table.insert(tempTable, midas)
	end
	if necronomicon then
		table.insert(tempTable, necronomicon)
	end

	for i, v in ipairs(tempTable) do

		local itemName = Ability.GetName(v)
		local itemNameShort = string.gsub(itemName, "item_", "")
		local imageHandle
			if AIO_Umbrella.itemIconHandler[itemNameShort] ~= nil then
				imageHandle = AIO_Umbrella.itemIconHandler[itemNameShort]
			else
				imageHandle = Renderer.LoadImage(AIO_Umbrella.itemIconPath .. itemNameShort .. ".png")
				AIO_Umbrella.itemIconHandler[itemNameShort] = imageHandle
			end
		
		Renderer.SetDrawColor(255, 255, 255, 255)
		Renderer.DrawImage(imageHandle, startX + 3 + (39*(i-1)), startYinfo + 135, 37, 26)
		if Ability.GetCooldownTimeLeft(v) > 0 then
			Renderer.SetDrawColor(255, 255, 255, 45)
			Renderer.DrawFilledRect(startX + 3 + (39*(i-1)), startYinfo + 135, 37, 26)
			Renderer.SetDrawColor(255, 0, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + 21 + (39*(i-1)), startYinfo + 139, math.ceil(Ability.GetCooldownTimeLeft(v)), 0)
		end
			
	end

end
		
function AIO_Umbrella.MorphCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroMorphling) then return end

	local waveForm = NPC.GetAbilityByIndex(myHero, 0)
	local adaptiveStrikeAGI = NPC.GetAbilityByIndex(myHero, 1)
	local adaptiveStrikeSTR = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	AIO_Umbrella.itemUsage(myHero, enemy)

	AIO_Umbrella.GetMorphShotgunDMG(myHero, myMana, enemy)
	AIO_Umbrella.MorphSelectCombo(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
		Engine.ExecuteCommand("dota_range_display 800")
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroMorphHPBalance) then
		AIO_Umbrella.MorphBalaceHP(myHero, myMana)
	end

	local replicateMod = NPC.GetModifier(myHero, "modifier_morphling_replicate")	

	if not replicateMod then
		if enemy and Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 800) then
					if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1550) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(300)))
						return
					end
				else
					if NPC.HasItem(myHero, "item_ethereal_blade", true) then
						if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > 0.1 then
							if AIO_Umbrella.morphlingComboSelect == false then
								AIO_Umbrella.MorphComboWithoutWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR)
							else
								AIO_Umbrella.MorphComboWithWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR, waveForm)
							end
						end
					else
						if not AIO_Umbrella.morphlingComboSelect then
							AIO_Umbrella.MorphComboWithoutWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR)
						else
							AIO_Umbrella.MorphComboWithWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR, waveForm)
						end
					end
				end	
			end
		AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
		end
	else
		if enemy and Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
		end
	end
		
end

function AIO_Umbrella.MorphComboWithWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR, waveForm)

	if not myHero then return end
	if not enemy then return end
	if not adaptiveStrikeAGI or not waveForm then return end
	if Ability.GetLevel(adaptiveStrikeAGI) < 1 or Ability.GetLevel(waveForm) < 1 then return end

	if adaptiveStrikeAGI and Ability.IsCastable(adaptiveStrikeAGI, myMana) then
		Ability.CastTarget(adaptiveStrikeAGI, enemy)
		AIO_Umbrella.lastTick = os.clock()
		return
	end
	if AIO_Umbrella.SleepReady(0.1) and waveForm and Ability.IsCastable(waveForm, myMana) and not Ability.IsReady(adaptiveStrikeAGI) then
		Ability.CastPosition(waveForm, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(99))
		return
	end
	if adaptiveStrikeSTR and Ability.IsCastable(adaptiveStrikeSTR, myMana) then
		Ability.CastTarget(adaptiveStrikeSTR, enemy)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	return

end

function AIO_Umbrella.MorphComboWithoutWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR)

	if not myHero then return end
	if not enemy then return end
	if not adaptiveStrikeAGI then return end
	if Ability.GetLevel(adaptiveStrikeAGI) < 1 then return end

	if adaptiveStrikeAGI and Ability.IsCastable(adaptiveStrikeAGI, myMana) then
		Ability.CastTarget(adaptiveStrikeAGI, enemy)
		return
	end
	if adaptiveStrikeSTR and Ability.IsCastable(adaptiveStrikeSTR, myMana) then
		Ability.CastTarget(adaptiveStrikeSTR, enemy)
		AIO_Umbrella.lastTick = os.clock()
		return
	end

	return

end

function AIO_Umbrella.GetMorphShotgunDMG(myHero, myMana, enemy)

	if not myHero then return end
	if not enemy then return end
	if not NPC.GetUnitName(myHero) == "npc_dota_hero_morphling" then return end

	local waveForm = NPC.GetAbilityByIndex(myHero, 0)
	local adaptiveStrike = NPC.GetAbilityByIndex(myHero, 1)

	local waveFormLevel
	if waveForm then
		waveFormLevel = Ability.GetLevel(waveForm)
	end
	local waveFormDMG
	if waveForm and Ability.IsCastable(waveForm, myMana) then
		waveFormDMG = 100 + 75 * (waveFormLevel - 1)
	elseif not waveForm or (waveForm and not Ability.IsCastable(waveForm, myMana)) then
		waveFormDMG = 0
	end

	local adaptiveStrikeLevel
	if adaptiveStrike then
		adaptiveStrikeLevel = Ability.GetLevel(adaptiveStrike)
	end
	local adaptiveStrikeDMG
	if adaptiveStrike and Ability.IsCastable(adaptiveStrike, myMana) then
		local basicDamage = 100
		local myAgility = Hero.GetAgilityTotal(myHero)
		local myStrength = Hero.GetStrengthTotal(myHero)
		local minMultiplier = 0.25
		local maxMultiplier = 0.5 + 0.5 * (adaptiveStrikeLevel - 1)

		local ratio = myAgility / myStrength
		local multiplier = minMultiplier
			if ratio > 1.5 then
				multiplier = maxMultiplier
			end

		adaptiveStrikeDMG = basicDamage + myAgility * multiplier
	elseif not adaptiveStrike or (adaptiveStrike and not Ability.IsCastable(adaptiveStrike, myMana)) then
		adaptiveStrikeDMG = 0
	end
	
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local eBladeDMG
	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local myAgility = Hero.GetAgilityTotal(myHero)
		eBladeDMG = (2 * myAgility + 75)
	elseif not eBlade or (eBlade and not Ability.IsCastable(eBlade, myMana)) then
		eBladeDMG = 0
	end

	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end
	local dagonDMG = 0
	if dagon and Ability.IsCastable(dagon, myMana) then
		dagonDMG = Ability.GetLevelSpecialValueFor(dagon, "damage")
	end

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)

	local overAllDMG = waveFormDMG + adaptiveStrikeDMG + eBladeDMG + dagonDMG
	if veil and Ability.IsCastable(veil, myMana) then
		overAllDMG = overAllDMG * 1.25
	end
	if eBlade and Ability.IsCastable(eBlade, myMana) then
		overAllDMG = overAllDMG * 1.4
	end

	local overAllDMGwoWave = adaptiveStrikeDMG + eBladeDMG + dagonDMG
	if veil and Ability.IsCastable(veil, myMana) then
		overAllDMGwoWave = overAllDMGwoWave * 1.25
	end
	if eBlade and Ability.IsCastable(eBlade, myMana) then
		overAllDMGwoWave = overAllDMGwoWave * 1.4
	end
	
	local trueOverallDMG = math.floor((1 - NPC.GetMagicalArmorValue(enemy)) * overAllDMG + overAllDMG * (Hero.GetIntellectTotal(myHero) / 14 / 100))
	local trueOverallDMGwoWave = math.floor((1 - NPC.GetMagicalArmorValue(enemy)) * overAllDMGwoWave + overAllDMGwoWave * (Hero.GetIntellectTotal(myHero) / 14 / 100))

	if NPC.HasModifier(myHero, "modifier_morphling_replicate") then
		AIO_Umbrella.morphlingTotalDMG = 0
		AIO_Umbrella.morphlingTotalDMGwoWave = 0
	end

	AIO_Umbrella.morphlingTotalDMG = trueOverallDMG - 35
	AIO_Umbrella.morphlingTotalDMGwoWave = trueOverallDMGwoWave - 35
	

end

function AIO_Umbrella.MorphBalaceHP(myHero, myMana)

	if not myHero then return end
	if not AIO_Umbrella.MorphBalanceToggler then return end
	
	if os.clock() - AIO_Umbrella.MorphBalanceTimer < 0.1 then return end

	if NPC.IsSilenced(myHero) then return end
	if NPC.IsStunned(myHero) then return end

	local targetHP
	if AIO_Umbrella.MorphBalanceSelectedHP > 0 then
		targetHP = AIO_Umbrella.MorphBalanceSelectedHP
	end

	if not targetHP then return end

	local morphAGI = NPC.GetAbility(myHero, "morphling_morph_agi")
	local morphSTR = NPC.GetAbility(myHero, "morphling_morph_str")

		if not morphAGI or not morphSTR then return end
		if Ability.GetLevel(morphAGI) < 1 then return end
		if NPC.HasModifier(myHero, "modifier_morphling_replicate") then return end

	local myHP = Entity.GetHealth(myHero)
	local myMAXHP = Entity.GetMaxHealth(myHero)

	local shouldToggleAGI = false
	local shouldToggleStr = false
	local allowedDeviation = Menu.GetValue(AIO_Umbrella.optionHeroMorphHPBalanceDeviation)

	if not NPC.HasModifier(myHero, "modifier_fountain_aura_buff") then
		if targetHP - myHP >= allowedDeviation then
			if Hero.GetAgility(myHero) > 1 then
				shouldToggleStr = true
			else
				shouldToggleStr = false
			end
		else
			shouldToggleStr = false
		end

		if myMAXHP - targetHP >= allowedDeviation and (myHP - targetHP) >= allowedDeviation then
			if Hero.GetStrength(myHero) > 1 then
				shouldToggleAGI = true
			else
				shouldToggleAGI = false
			end
		else
			shouldToggleAGI = false
		end

		if myMana < 35 then
			shouldToggleAGI = false
			shouldToggleStr = false
		end
	else
		if myMAXHP - myHP <= 50 then
			if myMAXHP - targetHP >= 50 then
				shouldToggleAGI = true
			elseif targetHP - myHP >= 50 then
				shouldToggleStr = true
			else
				shouldToggleAGI = false
				shouldToggleStr = false
			end
		end
	end
	

	if shouldToggleStr then
		if not Ability.GetToggleState(morphSTR) then
			Ability.Toggle(morphSTR)
			AIO_Umbrella.MorphBalanceTimer = os.clock()
			return
		end
	else
		if Ability.GetToggleState(morphSTR) then
			Ability.Toggle(morphSTR)
			AIO_Umbrella.MorphBalanceTimer = os.clock()
			return
		end
	end

	if shouldToggleAGI then
		if not Ability.GetToggleState(morphAGI) then
			Ability.Toggle(morphAGI)
			AIO_Umbrella.MorphBalanceTimer = os.clock()
			return
		end
	else
		if Ability.GetToggleState(morphAGI) then
			Ability.Toggle(morphAGI)
			AIO_Umbrella.MorphBalanceTimer = os.clock()
			return
		end
	end
				
end

function AIO_Umbrella.MorphDrawBalanceBoard(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroMorphDrawBoard) then return end

	local maxMorphAGI = math.floor(Hero.GetAgility(myHero))
	local maxMorphSTR = math.floor(Hero.GetStrength(myHero))

	local currentMAXHP = Entity.GetMaxHealth(myHero)

	local minHP = currentMAXHP - maxMorphSTR * 20
	local maxHP = currentMAXHP + maxMorphAGI * 20

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	local startX = w - 300 - Menu.GetValue(AIO_Umbrella.optionHeroMorphDrawBoardXPos)
	local startY = 300 + Menu.GetValue(AIO_Umbrella.optionHeroMorphDrawBoardYPos)
	
	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroMorphBoardToggleKey) then
		AIO_Umbrella.Toggler = not AIO_Umbrella.Toggler
	end

	if not AIO_Umbrella.Toggler then return end
		
	-- black background
	Renderer.SetDrawColor(0, 0, 0, 150)
	Renderer.DrawFilledRect(startX-1, startY, 202, 25)

	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX-1, startY, 202, 25)

	-- min/max HP
	Renderer.SetDrawColor(0, 255, 0, 150)
	Renderer.DrawText(AIO_Umbrella.font, startX-25, startY-25, minHP, 0)
	Renderer.SetDrawColor(255, 0, 0, 150)
	Renderer.DrawText(AIO_Umbrella.font, startX+175, startY-25, maxHP, 0)

	-- colored rect
	for i = 1, 20 do
		Renderer.SetDrawColor(25 + i*10, 230 - i*10, 0, 150)
		Renderer.DrawFilledRect(startX + (i-1)*10 , startY+1, 10, 23)
	end

	-- hovering rects
	local hoveringTable = {}
	if next(hoveringTable) == nil then
		for i = 1, 20 do
			hoveringTable[i] = Input.IsCursorInRect(startX + (i-1)*10 , startY+1, 10, 23)
		end
	end

	-- on/off rects
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX+75, startY-25, 50, 20)
	Renderer.SetDrawColor(0, 0, 0, 150)
	Renderer.DrawFilledRect(startX+75, startY-25, 50, 20)
		local togglerHovering = Input.IsCursorInRect(startX+75, startY-25, 50, 20)
		if togglerHovering and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
			AIO_Umbrella.MorphBalanceToggler = not AIO_Umbrella.MorphBalanceToggler
		end

	if AIO_Umbrella.MorphBalanceToggler then
		Renderer.SetDrawColor(0, 255, 0, 150)
		Renderer.DrawTextCenteredX(AIO_Umbrella.font, startX+100, startY-27, "ON", 0)
	else
		Renderer.SetDrawColor(255, 0, 0, 150)
		Renderer.DrawTextCenteredX(AIO_Umbrella.font, startX+100, startY-27, "OFF", 0)
	end

	local HPsteps = math.floor((maxHP - minHP) / 20)

	if Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		for i, v in ipairs(hoveringTable) do
			if hoveringTable[1] == true then
				AIO_Umbrella.MorphBalanceSelectedHP = minHP
				AIO_Umbrella.MorphBalanceSelected = 1
			elseif hoveringTable[20] == true then
				AIO_Umbrella.MorphBalanceSelectedHP = maxHP
				AIO_Umbrella.MorphBalanceSelected = 20
			else
				if v == true then
					AIO_Umbrella.MorphBalanceSelectedHP = minHP + HPsteps*i
					AIO_Umbrella.MorphBalanceSelected = i
				end
			end		
		end
	end

	if AIO_Umbrella.MorphBalanceSelected > 0 then
		Renderer.SetDrawColor(0, 0, 0, 200)
		Renderer.DrawFilledRect(startX+3+10*(AIO_Umbrella.MorphBalanceSelected-1), startY, 4, 30)
		Renderer.DrawTextCenteredX(AIO_Umbrella.font, startX+3+10*(AIO_Umbrella.MorphBalanceSelected-1), startY+30, AIO_Umbrella.MorphBalanceSelectedHP, 0)
	end

end

function AIO_Umbrella.MorphSelectCombo(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local adaptiveStrike = NPC.GetAbilityByIndex(myHero, 1)

	if adaptiveStrike and Ability.SecondsSinceLastUse(adaptiveStrike) > -1 and Ability.SecondsSinceLastUse(adaptiveStrike) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1150) + 0.15 then
		AIO_Umbrella.morphlingComboSelect = false
		return
	end

	if Entity.GetHealth(enemy) >= AIO_Umbrella.morphlingTotalDMGwoWave then
		AIO_Umbrella.morphlingComboSelect = true
	else
		AIO_Umbrella.morphlingComboSelect = false
	end
	return

end		

function AIO_Umbrella.drawMorphlingKillIndicator(myHero)

	if not myHero then return end
	
	if AIO_Umbrella.morphlingTotalDMG == 0 then return end

	local enemy = AIO_Umbrella.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if AIO_Umbrella.morphlingTotalDMG > 0 then
		if visible then
			if Entity.GetHealth(enemy) > AIO_Umbrella.morphlingTotalDMG then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(AIO_Umbrella.skywrathFont, x-50, y-70, "Shotgun DMG:  " .. math.floor(AIO_Umbrella.morphlingTotalDMG), 0)
		end
	end

end

function AIO_Umbrella.PuckCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroPuck) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local illusoryOrb = NPC.GetAbilityByIndex(myHero, 0)
	local etherealJaunt = NPC.GetAbility(myHero, "puck_ethereal_jaunt")
	local waningRift = NPC.GetAbilityByIndex(myHero, 1)
	local phaseShift = NPC.GetAbility(myHero, "puck_phase_shift")
	local dreamCoil = NPC.GetAbility(myHero, "puck_dream_coil")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	AIO_Umbrella.itemUsage(myHero, enemy)

	local orbIsFlying = false
	if illusoryOrb and Ability.SecondsSinceLastUse(illusoryOrb) > 0 and Ability.SecondsSinceLastUse(illusoryOrb) <= 2.995 then
		orbIsFlying = true
	end

	if orbIsFlying then
		AIO_Umbrella.lastPosition = Vector(0, 0, 0)
	end
		
	if Menu.IsEnabled(AIO_Umbrella.optionHeroPuckPanic) then
		if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroPuckPanicKey) then
			AIO_Umbrella.GenericUpValue = false
		end
		if Menu.IsKeyDown(AIO_Umbrella.optionHeroPuckPanicKey) then
			AIO_Umbrella.PuckPanic(myHero, enemy, myMana, orbIsFlying)
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroPuckDefend) then
		AIO_Umbrella.PuckDefend(myHero, enemy, myMana, waningRift)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 375) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1000) then
					AIO_Umbrella.lastPosition = Entity.GetAbsOrigin(myHero)
					if Menu.GetValue(AIO_Umbrella.optionHeroPuckJump) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(175))
						return
					else
						if #NPCs.InRadius(Entity.GetAbsOrigin(enemy), 375, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) <= 1 then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(175))
							return
						else
							local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 350)
							if bestPos ~= nil then
								Ability.CastPosition(blink, bestPos)
								return
							end
						end
					end
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end

			if not blink and Menu.IsEnabled(AIO_Umbrella.optionHeroPuckOrbInit) then
				if AIO_Umbrella.SleepReady(0.15) and illusoryOrb and Ability.IsCastable(illusoryOrb, myMana) then
					local orbPrediction = Ability.GetCastPoint(illusoryOrb) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 651) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(illusoryOrb, AIO_Umbrella.castLinearPrediction(myHero, enemy, orbPrediction))
					AIO_Umbrella.lastTick = os.clock()
					AIO_Umbrella.PuckOrbCastTime = GameRules.GetGameTime()
					return
				end
				if etherealJaunt and Ability.IsReady(etherealJaunt) then
					for _, v in ipairs(AIO_Umbrella.PuckOrbHitSim) do
						local origin = v[1]
						local velocity = v[2]
						local orbPos = origin + velocity:Scaled(GameRules.GetGameTime() - AIO_Umbrella.PuckOrbCastTime)
						if NPC.IsPositionInRange(enemy, orbPos, 150, 0) then
							Ability.CastNoTarget(etherealJaunt)
							AIO_Umbrella.PuckOrbHitSim = {}
							return
						end
					end
				end		
			end
		else
			if not Ability.IsChannelling(phaseShift) or NPC.HasModifier(myHero, "modifier_eul_cyclone") then
				if AIO_Umbrella.SleepReady(0.15) and waningRift and Ability.IsCastable(waningRift, myMana) then 
					Ability.CastNoTarget(waningRift)
					AIO_Umbrella.lastTick = os.clock()
				end
				if Menu.IsKeyDown(AIO_Umbrella.optionHeroPuckComboAltKey) then	
					if AIO_Umbrella.SleepReady(0.15) and dreamCoil and Ability.IsCastable(dreamCoil, myMana) then
						local bestPos = AIO_Umbrella.getBestPosition(Heroes.InRadius(Entity.GetAbsOrigin(enemy), 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 350)
						if bestPos ~= nil then
							Ability.CastPosition(dreamCoil, bestPos)
							AIO_Umbrella.lastTick = os.clock()
						end
					end
				end
				if AIO_Umbrella.SleepReady(0.15) and illusoryOrb and Ability.IsCastable(illusoryOrb, myMana) then
					if AIO_Umbrella.lastPosition:__tostring() ~= Vector(0, 0, 0):__tostring() then
						Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.lastPosition - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
					if AIO_Umbrella.lastPosition:__tostring() == Vector(0, 0, 0):__tostring() then
						Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end			
			else
				AIO_Umbrella.GenericUpValue = false
				AIO_Umbrella.PuckPanic(myHero, enemy, myMana, orbIsFlying)
			end
		end
	AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)	
	end
end

function AIO_Umbrella.PuckPanic(myHero, enemy, myMana, orbIsFlying)

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end

	local illusoryOrb = NPC.GetAbilityByIndex(myHero, 0)
	local etherealJaunt = NPC.GetAbility(myHero, "puck_ethereal_jaunt")
	local phaseShift = NPC.GetAbility(myHero, "puck_phase_shift")

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local euls = NPC.GetItem(myHero, "item_cyclone", true)

	local orbFlyingTimeLeft = 0
		if orbIsFlying then
			orbFlyingTimeLeft = 2.995 - Ability.SecondsSinceLastUse(illusoryOrb)
		end

	if NPC.IsSilenced(myHero) then
		if not AIO_Umbrella.GenericUpValue then
			if blink and Ability.IsReady(blink) then
				if Menu.GetValue(AIO_Umbrella.optionHeroPuckPanicDirection) == 0 then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
					AIO_Umbrella.GenericUpValue = true
					return
				else
					Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
					AIO_Umbrella.GenericUpValue = true
					return
				end
			end
			if (blink and Ability.GetCooldownTimeLeft(blink) <= 2.5) or (illusoryOrb and Ability.GetCooldownTimeLeft(illusoryOrb) <= 2.5) or (phaseShift and blink and Ability.GetCooldownTimeLeft(blink) <= 2.5 + Ability.GetLevelSpecialValueForFloat(phaseShift, "duration")) then
				if euls and Ability.IsCastable(euls, myMana) then
					Ability.CastTarget(euls, myHero)
					return
				end
			end
		end
		if (not euls or (euls and not Ability.IsCastable(euls, myMana))) and (not blink or (blink and not Ability.IsReady(blink))) then
			return
		end	
	else
		if not AIO_Umbrella.GenericUpValue and not Ability.IsChannelling(phaseShift) then
			if illusoryOrb and Ability.SecondsSinceLastUse(illusoryOrb) > 0 and Ability.SecondsSinceLastUse(illusoryOrb) <= 2.995 then
				if Ability.SecondsSinceLastUse(illusoryOrb) > 0 and Ability.SecondsSinceLastUse(illusoryOrb) <= 1.25 then
					if phaseShift and Ability.IsReady(phaseShift) then
						Ability.CastNoTarget(phaseShift)
						return
					end
				end
				if Ability.SecondsSinceLastUse(illusoryOrb) > 1.25 and Ability.SecondsSinceLastUse(illusoryOrb) <= 2.995 then
					if etherealJaunt and Ability.IsReady(etherealJaunt) then
						Ability.CastNoTarget(etherealJaunt)
						AIO_Umbrella.GenericUpValue = true
						return
					end
				end
			end		
			if blink then
				if Ability.IsReady(blink) then
					if Menu.GetValue(AIO_Umbrella.optionHeroPuckPanicDirection) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						AIO_Umbrella.GenericUpValue = true
						return
					else
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						AIO_Umbrella.GenericUpValue = true
						return
					end
				end
				if Ability.GetCooldownTimeLeft(blink) > 0.1 and Ability.GetCooldownTimeLeft(blink) < Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") then
					if phaseShift and Ability.IsReady(phaseShift) then
						Ability.CastNoTarget(phaseShift)
						return
					end
				end
			end
			if illusoryOrb and Ability.IsCastable(illusoryOrb, myMana) and (phaseShift and Ability.IsReady(phaseShift)) then
				if Menu.GetValue(AIO_Umbrella.optionHeroPuckPanicDirection) == 0 then
					Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
					Ability.CastNoTarget(phaseShift, true)
					return
				else
					Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
					Ability.CastNoTarget(phaseShift, true)
					return
				end
			end
			if euls and Ability.IsCastable(euls, myMana) then
				if (blink and Ability.GetCooldownTimeLeft(blink) > Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") and Ability.GetCooldownTimeLeft(blink) <= Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") + 2.5) or (illusoryOrb and Ability.GetCooldownTimeLeft(illusoryOrb) > 0 and Ability.GetCooldownTimeLeft(illusoryOrb) < 2.5 and phaseShift and Ability.GetCooldownTimeLeft(phaseShift) < 2.5) then
					Ability.CastTarget(euls, myHero)
					return
				end
			end	
		end
	end

	if Ability.IsChannelling(phaseShift) then
		if not AIO_Umbrella.GenericUpValue then
			if orbIsFlying then
				local phaseShiftTimeLeft = math.max(Ability.GetChannelStartTime(phaseShift) + Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") - GameRules.GetGameTime(), 0)
				if etherealJaunt and Ability.IsReady(etherealJaunt) then
					if phaseShiftTimeLeft > orbFlyingTimeLeft then
						if orbFlyingTimeLeft / 2.995 <= 0.25 then
							Ability.CastNoTarget(etherealJaunt)
							AIO_Umbrella.GenericUpValue = true
							return
						end
					else
						if phaseShiftTimeLeft / Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") <= 0.25 then
							Ability.CastNoTarget(etherealJaunt)
							AIO_Umbrella.GenericUpValue = true
							return
						end
					end
						
				end
			end
			if not orbIsFlying then
				if blink and Ability.IsReady(blink) then
					if Menu.GetValue(AIO_Umbrella.optionHeroPuckPanicDirection) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						AIO_Umbrella.GenericUpValue = true
						return
					else
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						AIO_Umbrella.GenericUpValue = true
						return
					end
				end
			end
			
		end
	end				
end


function AIO_Umbrella.PuckDefend(myHero, enemy, myMana, waningRift)

	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not waningRift then return end
	if not Ability.IsCastable(waningRift, myMana) then return end

	for _, heroes in ipairs(NPC.GetHeroesInRadius(myHero, 400, Enum.TeamType.TEAM_ENEMY)) do
		if heroes and not NPC.IsDormant(heroes) and Entity.IsAlive(heroes) then
			local enemyDagger = NPC.GetItem(heroes, "item_blink", true)
			if enemyDagger and NPC.IsEntityInRange(myHero, heroes, 375) and Ability.GetCooldownTimeLeft(enemyDagger) >= 9 and Ability.SecondsSinceLastUse(enemyDagger) > 0 and Ability.SecondsSinceLastUse(enemyDagger) <= 1 then
				if waningRift and Ability.IsCastable(waningRift, myMana) and not NPC.HasState(heroes, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					Ability.CastNoTarget(waningRift)
					break
					return
				end
			end
		end
	end
end

function AIO_Umbrella.ZuusCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroZuus) then return end

  	local arc = NPC.GetAbilityByIndex(myHero, 0)
 	local bolt = NPC.GetAbilityByIndex(myHero, 1)
 	local static = NPC.GetAbilityByIndex(myHero, 2)
 	local wrath = NPC.GetAbility(myHero, "zuus_thundergods_wrath")
	local nimbus = NPC.GetAbility(myHero, "zuus_cloud")

	local lens = NPC.GetItem(myHero, "item_aether_lens", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local bonusTalentRange = NPC.GetAbility(myHero, "special_bonus_cast_range_200")
  	local arcBonusTalentDamage = NPC.GetAbility(myHero, "special_bonus_unique_zeus_2")
  	local staticBonusTalentDamage = NPC.GetAbility(myHero, "special_bonus_unique_zeus")
	local spellAmplification = Hero.GetIntellectTotal(myHero)  / 14 / 100

	local arcCastRange = 850
  	local boltCastRange = 700
  	local staticCastRange = 1200

	if lens then
    		arcCastRange = arcCastRange + 250
    		boltCastRange = boltCastRange + 250
    		staticCastRange = staticCastRange + 250
  	end

	local arcDamage = 0
		if arc then
			arcDamage = Ability.GetLevelSpecialValueFor(arc, "arc_damage") * (1 + spellAmplification / 100)
		end
  	local boltDamage = Ability.GetDamage(bolt) * (1 + spellAmplification / 100)
	local staticDamage = 0
	if static and Ability.GetLevel(static) > 0 then
		staticDamage = 2 + (2 * Ability.GetLevel(static))
	end
  	local wrathDamage = (225 + (100 * (Ability.GetLevel(wrath) - 1))) * (1 + spellAmplification / 100)

	if arcBonusTalentDamage and Ability.GetLevel(arcBonusTalentDamage) > 0 then
    		arcDamage = arcDamage + (75 * (1 + spellAmplification / 100))
  	end

	if bonusTalentRange and Ability.GetLevel(bonusTalentRange) > 0 then
    		arcCastRange = arcCastRange + 200
    		boltCastRange = boltCastRange + 200
    		staticCastRange = staticCastRange + 200
  	end

	if staticBonusTalentDamage and Ability.GetLevel(staticBonusTalentDamage) > 0 then
      		staticDamage = staticDamage + 2
    	end

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroZuusFarmKey) then
		AIO_Umbrella.ZuusArcFarm(myHero, myMana, arc, arcDamage, arcCastRange, staticDamage)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroZuusHarassKey) then
		AIO_Umbrella.ZuusArcHarass(myHero, myMana, arc, arcCastRange)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroZuusFarmKey) or Menu.IsKeyDown(AIO_Umbrella.optionHeroZuusHarassKey) then
		Engine.ExecuteCommand("dota_range_display " .. tostring(arcCastRange))
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroZuusKillsteal) then
		AIO_Umbrella.ZuusFullKillSteal(myHero, myMana, arc, bolt, static, wrath, arcCastRange, boltCastRange, staticCastRange, arcDamage, boltDamage, staticDamage, wrathDamage, refresher, nimbus)
	end
	
	if enemy and NPC.IsEntityInRange(myHero, enemy, 2000) then	
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
				if not NPC.IsEntityInRange(myHero, enemy, boltCastRange) then
					if blink and Ability.IsReady(blink) and Menu.IsEnabled(AIO_Umbrella.optionHeroZuusBlink) then
						if NPC.IsEntityInRange(myHero, enemy, 1900) then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(750))
							return
						else
							if AIO_Umbrella.SleepReady(0.5) then
								Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
					if not blink or (blink and not Ability.IsReady(blink)) or not Menu.IsEnabled(AIO_Umbrella.optionHeroZuusBlink) then
						if AIO_Umbrella.SleepReady(0.5) then
							NPC.MoveTo(myHero, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(boltCastRange - 75), false, false)
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
					if arc and Ability.IsCastable(arc, myMana) and NPC.IsEntityInRange(myHero, enemy, arcCastRange) then
						Ability.CastTarget(arc, enemy)
						AIO_Umbrella.lastTick = os.clock()
					end	
				else
					if arc and Ability.IsCastable(arc, myMana) then
						Ability.CastTarget(arc, enemy)
						AIO_Umbrella.lastTick = os.clock()
					end
					if AIO_Umbrella.SleepReady(0.2) and bolt and Ability.IsCastable(bolt, myMana) then
						Ability.CastTarget(bolt, enemy)
						AIO_Umbrella.lastTick = os.clock()
					end
				end
			end
			if Menu.IsEnabled(AIO_Umbrella.optionHeroZuusRightClick) then
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			end
		end
	end

end

function AIO_Umbrella.ZuusArcHarass(myHero, myMana, arc, arcCastRange)

	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not arc then return end
		if not Ability.IsCastable(arc, myMana) then return end

	local targetHero
	local minHP = 99999

	if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(AIO_Umbrella.optionHeroZuusHarassMana) / 100) then
		for _, hero in ipairs(NPC.GetHeroesInRadius(myHero, arcCastRange - 25, Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then
				if Entity.IsAlive(hero) then
					if Entity.GetHealth(hero) < minHP then
						targetHero = hero
						minHP = Entity.GetHealth(hero)
					end
				end
			end
		end
	end

	if targetHero then
		Ability.CastTarget(arc, targetHero)
        	return
	else
		if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(AIO_Umbrella.optionHeroZuusHarassMana) / 100) then
			for _, npc in ipairs(NPC.GetUnitsInRadius(myHero, arcCastRange - 25, Enum.TeamType.TEAM_ENEMY)) do
				if npc and not Entity.IsDormant(npc) and not Entity.IsHero(npc) and NPC.IsCreep(npc) then 
					if Entity.IsAlive(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
        					Ability.CastTarget(arc, npc)
						break
        					return
					end
				end	
			end
      		end		
	end

end

function AIO_Umbrella.ZuusArcFarm(myHero, myMana, arc, arcDamage, arcCastRange, staticDamage)

	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not arc then return end
		if not Ability.IsCastable(arc, myMana) then return end

	for _, npc in ipairs(NPC.GetUnitsInRadius(myHero, arcCastRange - 25, Enum.TeamType.TEAM_ENEMY)) do

		if npc and not Entity.IsDormant(npc) and not Entity.IsHero(npc) and NPC.IsCreep(npc) then 
			if Entity.IsAlive(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
      				if Entity.GetHealth(npc) < (arcDamage + (Entity.GetHealth(npc) * (staticDamage / 100))) * NPC.GetMagicalArmorDamageMultiplier(npc) then
        				Ability.CastTarget(arc, npc)
					break
        				return
				end
			end
      		end		
	end

end

function AIO_Umbrella.ZuusFullKillSteal(myHero, myMana, arc, bolt, static, wrath, arcCastRange, boltCastRange, staticCastRange, arcDamage, boltDamage, staticDamage, wrathDamage, refresher, nimbus)

	if not myHero then return end
	
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	for i = 1, Heroes.Count() do
	local enemies = Heroes.Get(i)
		if enemies ~= nil and Entity.IsHero(enemies) and not Entity.IsSameTeam(myHero, enemies) then
			local enemy = AIO_Umbrella.targetChecker(enemies)
			if enemy then
				if Ability.GetLevel(static) > 0 and NPC.IsEntityInRange(myHero, enemy, staticCastRange-25, 0) then
          				boltDamage  = boltDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))
          				arcDamage = arcDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))
        			end
        			boltDamage = NPC.GetMagicalArmorDamageMultiplier(enemy) * boltDamage
        			arcDamage = NPC.GetMagicalArmorDamageMultiplier(enemy) * arcDamage
        			wrathDamage = NPC.GetMagicalArmorDamageMultiplier(enemy) * wrathDamage
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) and not NPC.HasModifier(enemy, "modifier_templar_assassin_refraction_absorb") then
        				if AIO_Umbrella.ZuusWrathCount(myHero, myMana, wrath, wrathDamage, static, staticDamage, staticCastRange, false) == true and wrath and Ability.IsCastable(wrath, myMana) then
            					Ability.CastNoTarget(wrath) 
            					return
          				end
					if refresher and Ability.IsCastable(refresher, myMana) then
						if AIO_Umbrella.ZuusWrathCount(myHero, myMana, wrath, wrathDamage, static, staticDamage, staticCastRange, true) == true and wrath and Ability.IsCastable(wrath, myMana) then
            						Ability.CastNoTarget(wrath)
							Ability.CastNoTarget(refresher, true)
            						return
						end
					end
					if nimbus and not Ability.IsHidden(nimbus) and Ability.IsCastable(nimbus, myMana) then
						if not NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), arcCastRange, 0) then
							if Entity.GetHealth(enemy) <= boltDamage then
								Ability.CastPosition(nimbus, Entity.GetAbsOrigin(enemy))
								return
							end
						end
					end
					if not NPC.IsLinkensProtected(enemy) and Entity.GetHealth(enemy) <= arcDamage and arc and Ability.IsCastable(arc, myMana) and NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), arcCastRange, 0) then
            					Ability.CastTarget(arc, enemy) 
            					return 
         				end
        				if not NPC.IsLinkensProtected(enemy) and Entity.GetHealth(enemy) <= boltDamage and bolt and Ability.IsCastable(bolt, myMana) and NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), boltCastRange, 0) then
            					Ability.CastTarget(bolt, enemy) 
           	 				return
          				end
        				if not NPC.IsLinkensProtected(enemy) and Entity.GetHealth(enemy) <= (boltDamage + arcDamage) and arc and bolt and Ability.IsCastable(bolt, myMana - 80) and Ability.IsCastable(arc, myMana) and NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), boltCastRange, 0) then
            					Ability.CastTarget(bolt, enemy)
						Ability.CastTarget(arc, enemy, true)
            					return 
          				end
          			end
			end
		end
	end

end

function AIO_Umbrella.ZuusWrathCount(myHero, myMana, wrath, wrathDamage, static, staticDamage, staticCastRange, doubleUlt)

	if not myHero then return false end
	if not wrath then return false end
		if not Ability.IsReady(wrath) then return false end
		if not Ability.IsCastable(wrath, myMana) then return false end

	local count = 0
	local countRefresher = 0
	for i = 1, Heroes.Count(), 1 do
	local enemies = Heroes.Get(i)
		if enemies ~= nil and Entity.IsHero(enemies) and not Entity.IsSameTeam(myHero, enemies) then
			local enemy = AIO_Umbrella.targetChecker(enemies)
			if enemy then
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
					if not doubleUlt then
						if Ability.GetLevel(static) > 0 and NPC.IsEntityInRange(myHero, enemy, staticCastRange-25, 0) then
							if Entity.GetHealth(enemy) <= (wrathDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))) then
								count = count + 1
							end
						else
							if Entity.GetHealth(enemy) <= wrathDamage then
								count = count + 1
							end
						end
					else
						if Ability.GetLevel(static) > 0 and NPC.IsEntityInRange(myHero, enemy, staticCastRange-25, 0) then
							if Entity.GetHealth(enemy) <= (wrathDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))) * 2 then
								countRefresher = countRefresher + 1
							end
						else
							if Entity.GetHealth(enemy) <= wrathDamage * 2 then
								countRefresher = countRefresher + 1
							end
						end	
					end
				end
			end
		end
	end

	if count > 0 and doubleUlt == false then
		if count >= Menu.GetValue(AIO_Umbrella.optionHeroZuusUltCount) then
			return true
		end
	end

	if countRefresher > 0 and doubleUlt == true and myMana > (Ability.GetManaCost(wrath) * 2 + 375) then
		if countRefresher >= Menu.GetValue(AIO_Umbrella.optionHeroZuusUltCountRefresher) then
			return true
		end
	end

	return false

end

function AIO_Umbrella.ProphetHelper(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroProphet) then return end
	
	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroProphetToggleKey) then
		AIO_Umbrella.Toggler = not AIO_Umbrella.Toggler
		AIO_Umbrella.TogglerTime = os.clock()
	end

	AIO_Umbrella.itemUsage(myHero, enemy)

	if enemy and NPC.IsEntityInRange(myHero, enemy, 2000) then	
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) and AIO_Umbrella.heroCanCastItems(myHero) == true then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end
	
	local treantEntities = {}
	if AIO_Umbrella.Toggler then
		for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
			if npc and Entity.IsSameTeam(myHero, npc) and Entity.IsAlive(npc) then
				if npc ~= myHero then
					if Entity.GetOwner(npc) == myHero then
						if npc ~= nil then
							if NPC.GetUnitName(npc) == "npc_dota_furion_treant" then
								if npc ~= nil then
									AIO_Umbrella.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, AIO_Umbrella.GenericLanePusher(npc), npc)
								end
							end	
						end
					end
				end
			end
		end
	end
			
end

function AIO_Umbrella.DrawProphetHelperSwitch()

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 0, 255)

	if os.clock() - AIO_Umbrella.TogglerTime < 3 then
		if AIO_Umbrella.Toggler then
			Renderer.DrawTextCentered(AIO_Umbrella.font, w / 2, h / 2 + 300, "LANE PUSH ON", 1)
		else 
			Renderer.DrawTextCentered(AIO_Umbrella.font, w / 2, h / 2 + 300, "LANE PUSH OFF", 1)
		end
	end

end

function AIO_Umbrella.DrawProphetAwareness(myHero)

	if not myHero then return end
	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	for i = 1, Heroes.Count() do 
	local hero = Heroes.Get(i)
		if hero and not Entity.IsSameTeam(myHero, hero) and Entity.IsAlive(hero) then
			if not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then
				if Entity.GetHealth(hero) / Entity.GetMaxHealth(hero) <= 0.20 then
					Renderer.DrawTextCentered(AIO_Umbrella.font, w / 2, h / 2 + 300, "POSSIBLE PORT TARGET", 1)
					AIO_Umbrella.DrawProphetAwarenessMinimap(hero)
				end
			end
		end
	end
end

function AIO_Umbrella.DrawProphetAwarenessMinimap(hero)

	if not hero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionProphetDrawKSminimap) then return end

	local w, h = Renderer.GetScreenSize()
	local targetPos = Entity.GetAbsOrigin(hero)
	Renderer.SetDrawColor(255, 255, 255)

	position = AIO_Umbrella:WorldToMiniMap(targetPos, w, h)
	Renderer.DrawText(AIO_Umbrella.font, position:GetX(), position:GetY(), "X", 1)

end

function AIO_Umbrella.InvokerCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvoker) then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end

	if os.clock() - AIO_Umbrella.invokerCaptureGhostwalkActivation < 1.0 then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		return
	end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	local emp = NPC.GetAbility(myHero, "invoker_emp")
	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
	local ghostWalk = NPC.GetAbility(myHero, "invoker_ghost_walk")
	local deafeningBlast = NPC.GetAbility(myHero, "invoker_deafening_blast")
	local chaosMeteor = NPC.GetAbility(myHero, "invoker_chaos_meteor")
	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
	local coldSnap = NPC.GetAbility(myHero, "invoker_cold_snap")
	local alacrity = NPC.GetAbility(myHero, "invoker_alacrity")
	local forgeSpirit = NPC.GetAbility(myHero, "invoker_forge_spirit")

	local invoke = NPC.GetAbility(myHero, "invoker_invoke")
	local myMana = NPC.GetMana(myHero)
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
		if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerBlink) then
			blink = nil
		end

	if NPC.HasAbility(myHero, "special_bonus_unique_invoker_8") then
		if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_invoker_8")) > 0 then
			if AIO_Umbrella.invokerTornadoLiftDuration[1] < 1.1 then
				AIO_Umbrella.invokerTornadoLiftDuration = { 1.1, 1.4, 1.7, 2.0, 2.3, 2.6, 2.9, 3.2 }
			end
		end
	end
	
	local euls = NPC.GetItem(myHero, "item_cyclone", true)

	local invokeTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity"
			}

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroInvokerAltKey) and Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
		if AIO_Umbrella.InvokerComboSelector == 1 then
			AIO_Umbrella.PreInvokeSkills = {{coldSnap, forgeSpirit}}
		elseif AIO_Umbrella.InvokerComboSelector == 2 then
			AIO_Umbrella.PreInvokeSkills = {{coldSnap, forgeSpirit}}
		elseif AIO_Umbrella.InvokerComboSelector == 3 then
			AIO_Umbrella.PreInvokeSkills = {{emp, tornado}}
		elseif AIO_Umbrella.InvokerComboSelector == 4 then
			AIO_Umbrella.PreInvokeSkills = {{chaosMeteor, tornado}}
		elseif AIO_Umbrella.InvokerComboSelector == 5 then
			AIO_Umbrella.PreInvokeSkills = {{chaosMeteor, sunStrike}}
		elseif AIO_Umbrella.InvokerComboSelector == 6 then
			AIO_Umbrella.PreInvokeSkills = {{emp, tornado}}
		elseif AIO_Umbrella.InvokerComboSelector == 7 then
			AIO_Umbrella.PreInvokeSkills = {{sunStrike, tornado}}
		elseif AIO_Umbrella.InvokerComboSelector == 8 then
			AIO_Umbrella.PreInvokeSkills = {{sunStrike, tornado}}
		elseif AIO_Umbrella.InvokerComboSelector == 9 then
			AIO_Umbrella.PreInvokeSkills = {{emp, tornado}}
		elseif AIO_Umbrella.InvokerComboSelector == 10 then
			AIO_Umbrella.PreInvokeSkills = {{deafeningBlast, chaosMeteor}}
		elseif AIO_Umbrella.InvokerComboSelector == 12 then
			if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 0 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) <= 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)])}}
				elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)])}}
				elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)])}}
				else
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)])}}
				end
			end
		elseif AIO_Umbrella.InvokerComboSelector == 13 then
			if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 0 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) <= 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)])}}
				elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)])}}
				elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)])}}
				else
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)])}}
				end
			end
		elseif AIO_Umbrella.InvokerComboSelector == 14 then
			if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 0 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) <= 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)])}}
				elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)])}}
				elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 9 then
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)])}}
				else
					AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)])}}
				end
			end
		end
	end
	
	if AIO_Umbrella.getInvokerGhostWalkKey == nil then
		AIO_Umbrella.getInvokerGhostWalkKey = Config.ReadString("", "Ghost Walk Key0", defaultValue)
	end

	if Input.IsKeyDownOnce(AIO_Umbrella.getInvokerGhostWalkKey) then
		AIO_Umbrella.invokerCaptureGhostwalkActivation = os.clock()
	end
	
	if next(AIO_Umbrella.PreInvokeSkills) ~= nil then
		AIO_Umbrella.InvokerPreInvoke(myHero, myMana, invoke)
	end
	
	if Menu.IsKeyDown(AIO_Umbrella.optionHeroInvokerIcewallKey) then
		AIO_Umbrella.InvokerFastIceWall(myHero, myMana, invoke, enemy)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroInvokerAlacrityKey) then
		AIO_Umbrella.InvokerFastAlacrity(myHero, myMana, invoke, enemy)
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionHeroInvokerTornadoKey) then
		AIO_Umbrella.InvokerFastTornado(myHero, myMana, invoke, enemy)
	end

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroInvokerCustom1Key) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 12 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 0 then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) <= 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					else
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					end
				else
					AIO_Umbrella.InvokerComboSelector = 0
				end	
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 12 then
				AIO_Umbrella.InvokerComboSelector = 12
			end
		end
	end

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroInvokerCustom2Key) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 13 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 0 then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) <= 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					else
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					end
				else
					AIO_Umbrella.InvokerComboSelector = 0
				end		
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 13 then
				AIO_Umbrella.InvokerComboSelector = 13
			end
		end
	end

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroInvokerCustom3Key) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 14 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 0 then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) <= 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					else
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					end
				else
					AIO_Umbrella.InvokerComboSelector = 0
				end		
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 14 then
				AIO_Umbrella.InvokerComboSelector = 14
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerCancelEnable) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerCancelTPFog) then
			AIO_Umbrella.InvokerCancelTPingInFog(myHero, myMana, enemy, invoke, tornado)
		end
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerCancelBara) then
			AIO_Umbrella.InvokerCancelBaraCharge(myHero, myMana, enemy, invoke, coldSnap, tornado, deafeningBlast)
		end
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerCancelChannelling) then
			AIO_Umbrella.InvokerCancelVisibleChannellingAbilities(myHero, myMana, enemy, invoke, coldSnap, tornado)
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionKillStealInvokerTPpartice) then
		AIO_Umbrella.EnemyHPTracker(myHero)
	end
	
	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerCataKS) then
		AIO_Umbrella.InvokerCataclysmKillSteal(myHero, myMana, invoke)
	end

	if AIO_Umbrella.getInvokerSettings == nil then
		AIO_Umbrella.getInvokerSettings = Menu.GetValue(AIO_Umbrella.optionHeroInvokerDisableBuildInGetOption)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerDisableBuildIn) then
		if AIO_Umbrella.getInvokerSettings > 0 then
			if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then
    				Menu.SetValue(AIO_Umbrella.optionHeroInvokerDisableBuildInGetOption, 0)
			else
				Menu.SetValue(AIO_Umbrella.optionHeroInvokerDisableBuildInGetOption, 1)
			end
		end
	end

	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and not Menu.IsKeyDown(AIO_Umbrella.optionHeroInvokerAltKey) then
		if enemy and Entity.GetHealth(enemy) > 0 then
			if NPC.IsEntityInRange(myHero, enemy, 1500) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				if AIO_Umbrella.InvokerComboSelector == 0 then
					AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
				elseif AIO_Umbrella.InvokerComboSelector == 1 then
					AIO_Umbrella.InvokerComboCSAlacritySpirit(myHero, myMana, enemy, coldSnap, alacrity, forgeSpirit, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 2 then
					AIO_Umbrella.InvokerComboCSSpiritSunstrike(myHero, myMana, enemy, coldSnap, forgeSpirit, sunStrike, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 3 then
					AIO_Umbrella.InvokerComboTornadoEmpIcewall(myHero, myMana, enemy, tornado, emp, iceWall, coldSnap, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 4 then
					AIO_Umbrella.InvokerComboTornadoMeteorBlast(myHero, myMana, enemy, tornado, chaosMeteor, deafeningBlast, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 5 then
					AIO_Umbrella.InvokerComboEulsSunstrikeMeteorBlast(myHero, myMana, enemy, sunStrike, chaosMeteor, deafeningBlast, blink, euls, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 6 then
					AIO_Umbrella.InvokerComboAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 7 then
					AIO_Umbrella.InvokerComboAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 8 then
					AIO_Umbrella.InvokerComboRefresherAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 9 then
					AIO_Umbrella.InvokerComboRefresherAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 10 then
					AIO_Umbrella.InvokerComboRefresherAghaBlastMeteorSunstrike(myHero, myMana, enemy, deafeningBlast, chaosMeteor, sunStrike, blink, aghanims, refresher, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 11 then
					AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 12 then
					AIO_Umbrella.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 13 then
					AIO_Umbrella.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)
				elseif AIO_Umbrella.InvokerComboSelector == 14 then
					AIO_Umbrella.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)
				end
			else
				AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			end
		end
	else
		AIO_Umbrella.InvokerCanComboStart = false
	end

end

function AIO_Umbrella.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
	
	if not myHero then return end
	if not enemy then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end

	if not iceWall then return end
	if not Ability.IsReady(iceWall) or not Ability.IsCastable(iceWall, myMana) or not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, iceWall) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 600) then return end

	local betaRad = math.acos(200 / (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D())
	local beta = betaRad * 180 / math.pi
	local delta = math.acos((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Dot(Entity.GetRotation(myHero):GetForward()) / (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() * (Entity.GetRotation(myHero):GetForward()):Length2D()) * 180 / math.pi

	if NPC.IsEntityInRange(myHero, enemy, 275) then
		Ability.CastNoTarget(iceWall)
		return
	else
		if math.abs(delta - beta) > 7.5 then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5):Rotated(Angle(0, beta, 0)))
			return
		else
			Ability.CastNoTarget(iceWall)
			return
		end
	end

end

function AIO_Umbrella.InvokerComboCSAlacritySpirit(myHero, myMana, enemy, coldSnap, alacrity, forgeSpirit, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	AIO_Umbrella.itemUsage(myHero, enemy)

	if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and invoke and Ability.IsReady(invoke) then
	AIO_Umbrella.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + 400) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(400))
					return
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) then
				AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				return
			end
		else
			if AIO_Umbrella.SleepReady(0.05) and coldSnap and Ability.IsCastable(coldSnap, myMana) then
				Ability.CastTarget(coldSnap, enemy)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.05) and forgeSpirit and Ability.IsCastable(forgeSpirit, myMana) then
				Ability.CastNoTarget(forgeSpirit)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, alacrity) then
				AIO_Umbrella.invokerInvokeAbility(myHero, alacrity)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			if not AIO_Umbrella.InvokerCanComboStart then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end	




	if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) then
		if AIO_Umbrella.SleepReady(0.05) and alacrity and Ability.IsCastable(alacrity, myMana) then
			Ability.CastTarget(alacrity, myHero)
			AIO_Umbrella.lastTick = os.clock()
			return
		end
	end

	AIO_Umbrella.invokerForgedSpiritController(myHero, enemy)

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) and not Ability.IsReady(alacrity) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end

function AIO_Umbrella.InvokerComboCSSpiritSunstrike(myHero, myMana, enemy, coldSnap, forgeSpirit, sunStrike, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	AIO_Umbrella.itemUsage(myHero, enemy)

	if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and invoke and Ability.IsReady(invoke) then
	AIO_Umbrella.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + 400) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(400))
					return
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) then
				AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				return
			end
		else
			if AIO_Umbrella.SleepReady(0.05) and coldSnap and Ability.IsCastable(coldSnap, myMana) then
				Ability.CastTarget(coldSnap, enemy)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if not Ability.IsReady(coldSnap) and AIO_Umbrella.SleepReady(0.05) and forgeSpirit and Ability.IsCastable(forgeSpirit, myMana) then
				Ability.CastNoTarget(forgeSpirit)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if not Ability.IsReady(forgeSpirit) and AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
				AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			if not AIO_Umbrella.InvokerCanComboStart then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end
	
	AIO_Umbrella.invokerForgedSpiritController(myHero, enemy)

	if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) then
		if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if not Entity.IsTurning(enemy) then
				Ability.CastPosition(sunStrike, AIO_Umbrella.castPrediction(myHero, enemy, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) and not Ability.IsReady(sunStrike) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end


function AIO_Umbrella.InvokerComboTornadoEmpIcewall(myHero, myMana, enemy, tornado, emp, iceWall, coldSnap, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	local rangeChecker
		if 400 + (400 * Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1))) < 1000 then
			rangeChecker = 400 + (400 * Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)))
		else
			rangeChecker = 1000
		end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
		AIO_Umbrella.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		end
	end

	if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(emp), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	AIO_Umbrella.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 1000) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					AIO_Umbrella.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				AIO_Umbrella.noItemCastFor(0.5)
				return
			end
		else
			local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
			local tornadoTiming = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
			if tornadoTiming < 2.9 then
				if AIO_Umbrella.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
					if NPC.IsEntityInRange(myHero, enemy, 925) then
						Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.lastCastTime = os.clock()
						return
					else
						Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.lastCastTime = os.clock()
						return
					end
				end
				if not Ability.IsReady(emp) then
					if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
						if os.clock() - AIO_Umbrella.lastCastTime <= 2.9 - tornadoTiming - 0.5 then
							AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
							return
						else	
							if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
								local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
								AIO_Umbrella.lastTick = os.clock()
								AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
								return
							else
								Ability.CastPosition(tornado, Input.GetWorldCursorPos())
								AIO_Umbrella.lastTick = os.clock()
								AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
								return
							end
						end
					end
				end
			else
				if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.lastCastTime = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.lastCastTime = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if AIO_Umbrella.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
					local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
					local tornadoTiming = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
					if os.clock() - AIO_Umbrella.lastCastTime > tornadoTiming - 2.9 + 0.05 then
						if NPC.IsEntityInRange(myHero, enemy, 925) then
							Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
							AIO_Umbrella.lastTick = os.clock()
							return
						else
							Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			end
			if not Ability.IsReady(emp) and not Ability.IsReady(tornado) and NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				local distance = math.abs((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - 550)
				local timeToTarget = distance / NPC.GetMoveSpeed(myHero)
				if GameRules.GetGameTime() + timeToTarget <= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) then
					if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, iceWall) then
						AIO_Umbrella.invokerInvokeAbility(myHero, iceWall)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				else
					if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, coldSnap) then
						AIO_Umbrella.invokerInvokeAbility(myHero, coldSnap)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			if not AIO_Umbrella.InvokerCanComboStart then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(tornado) and not Ability.IsReady(emp) then
		if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, iceWall) then
			if AIO_Umbrella.SleepReady(0.05) and iceWall and Ability.IsCastable(iceWall, myMana) then
				if not NPC.IsEntityInRange(myHero, enemy, 550) then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(500), myHero)
				else
					AIO_Umbrella.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end
		if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, coldSnap) then
			if AIO_Umbrella.SleepReady(0.05) and coldSnap and Ability.IsCastable(coldSnap, myMana) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
						AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero) - 25), myHero)
					end
				else
					Ability.CastTarget(coldSnap, enemy)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(emp) and (not Ability.IsReady(coldSnap) or not Ability.IsReady(iceWall)) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

end

function AIO_Umbrella.InvokerComboTornadoMeteorBlast(myHero, myMana, enemy, tornado, chaosMeteor, deafeningBlast, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
		AIO_Umbrella.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		end
	end	

	if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	AIO_Umbrella.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 950) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					AIO_Umbrella.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				AIO_Umbrella.noItemCastFor(0.5)
				return
			end
		else
			local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
			local tornadoTiming = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
			if tornadoTiming < 1.3 then
				if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
					Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250))
					AIO_Umbrella.lastTick = os.clock()
					AIO_Umbrella.lastCastTime = os.clock()
					return
				end
				if not Ability.IsReady(chaosMeteor) then
					if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
						if os.clock() - AIO_Umbrella.lastCastTime <= 1.3 - tornadoTiming then
							AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
							return
						else	
							if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
								local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
								AIO_Umbrella.lastTick = os.clock()
								return
							else
								Ability.CastPosition(tornado, Input.GetWorldCursorPos())
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
				end
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if AIO_Umbrella.SleepReady(0.05) and not Ability.IsReady(tornado) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, deafeningBlast) then
						AIO_Umbrella.invokerInvokeAbility(myHero, deafeningBlast)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			else
				if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if AIO_Umbrella.SleepReady(0.05) and not Ability.IsReady(tornado) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, deafeningBlast) then
						AIO_Umbrella.invokerInvokeAbility(myHero, deafeningBlast)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			if not AIO_Umbrella.InvokerCanComboStart then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(tornado) then
		if Ability.IsReady(chaosMeteor) and NPC.HasModifier(enemy, "modifier_invoker_tornado") then
			local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
				if distance < 0 then
					distance = 0
				end
			local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
			if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
				if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
							Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			else
				if not NPC.IsEntityInRange(myHero, enemy, 950) then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
							Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			end
		else
			if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				else
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

end

function AIO_Umbrella.InvokerComboEulsSunstrikeMeteorBlast(myHero, myMana, enemy, sunStrike, chaosMeteor, deafeningBlast, blink, euls, invoke)

	if not euls then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(sunStrike)) and invoke and Ability.IsReady(invoke) then
	AIO_Umbrella.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 550) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					AIO_Umbrella.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(500))
					return
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_eul_cyclone") then
				AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy), myHero)
				AIO_Umbrella.noItemCastFor(0.5)
				return
			end
		else
			if AIO_Umbrella.SleepReady(0.05) and euls and Ability.IsCastable(euls, myMana) then
				Ability.CastTarget(euls, enemy)
				AIO_Umbrella.lastTick = os.clock()
				AIO_Umbrella.noItemCastFor(2.5)
				return
			else
				if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
					AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
			if NPC.HasModifier(enemy, "modifier_eul_cyclone") then
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone")) - 1.7 then
					if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
						Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
			if AIO_Umbrella.SleepReady(0.05) and not Ability.IsReady(sunStrike) and invoke and Ability.IsCastable(invoke, myMana) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, deafeningBlast) then
				AIO_Umbrella.invokerInvokeAbility(myHero, deafeningBlast)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			if not AIO_Umbrella.InvokerCanComboStart then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) and not Ability.IsReady(sunStrike) then
		if NPC.HasModifier(enemy, "modifier_eul_cyclone") then
			if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone")) - 1.3 then
				if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
					Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
			local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
			if not Ability.IsReady(chaosMeteor) then
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end
	end

	AIO_Umbrella.itemUsage(myHero, enemy)

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(sunStrike) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_eul_cyclone") then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

end


function AIO_Umbrella.InvokerComboAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
		AIO_Umbrella.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		end
	end

	if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(emp), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	AIO_Umbrella.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 1000) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					AIO_Umbrella.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				AIO_Umbrella.noItemCastFor(0.5)
				return
			end
		else
			if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
					local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
					AIO_Umbrella.lastTick = os.clock()
					AIO_Umbrella.lastCastTime = os.clock()
					AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				else
					Ability.CastPosition(tornado, Input.GetWorldCursorPos())
					AIO_Umbrella.lastTick = os.clock()
					AIO_Umbrella.lastCastTime = os.clock()
					AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				end
			end
			if not Ability.IsReady(tornado) then
				if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, chaosMeteor) then
					AIO_Umbrella.invokerInvokeAbility(myHero, chaosMeteor)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end	
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			if not AIO_Umbrella.InvokerCanComboStart then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(tornado) and AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(emp)) then
		if AIO_Umbrella.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
			local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
			local tornadoTiming = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
			if os.clock() - AIO_Umbrella.lastCastTime > tornadoTiming - 2.9 + 0.25 then
				if NPC.IsEntityInRange(myHero, enemy, 925) then
					Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				else
					Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end
		if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
			if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
				local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
					if distance < 0 then
						distance = 0
					end
				local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
				if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
					if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
						AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
							if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
								Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
				else
					if not NPC.IsEntityInRange(myHero, enemy, 950) then
						AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
							if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
								Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
				end
			end
		end			
	end
	if not Ability.IsReady(chaosMeteor) then
		if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, deafeningBlast) then
			AIO_Umbrella.invokerInvokeAbility(myHero, deafeningBlast)
			AIO_Umbrella.lastTick = os.clock()
			return
		end
		if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			else
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(emp) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

	
end

function AIO_Umbrella.InvokerComboAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
		AIO_Umbrella.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		end
	end

	if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(sunStrike), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	AIO_Umbrella.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 1000) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					AIO_Umbrella.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if AIO_Umbrella.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				AIO_Umbrella.noItemCastFor(0.5)
				return
			end
		else
			if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
					local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
					AIO_Umbrella.lastTick = os.clock()
					AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				else
					Ability.CastPosition(tornado, Input.GetWorldCursorPos())
					AIO_Umbrella.lastTick = os.clock()
					AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				end
			end
			if not Ability.IsReady(tornado) then
				if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, chaosMeteor) then
					AIO_Umbrella.invokerInvokeAbility(myHero, chaosMeteor)
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			if not AIO_Umbrella.InvokerCanComboStart then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end
		
	if NPC.HasModifier(enemy, "modifier_invoker_tornado") and AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(sunStrike)) then
		if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
			local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
				if distance < 0 then
					distance = 0
				end
			local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
			if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
				if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
						if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
							Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			else
				if not NPC.IsEntityInRange(myHero, enemy, 950) then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
						if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
							Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			end
		end			
		
		if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) then
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
					if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
						Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
		end
	end

	if not Ability.IsReady(chaosMeteor) then
		if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, deafeningBlast) then
			AIO_Umbrella.invokerInvokeAbility(myHero, deafeningBlast)
			AIO_Umbrella.lastTick = os.clock()
			return
		end
		if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			else
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastTick = os.clock()
				return
			end	
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return
		
end

function AIO_Umbrella.InvokerComboRefresherAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if not refresher then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
		AIO_Umbrella.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) or not Ability.IsReady(refresher) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		end
	end

	if Ability.IsReady(refresher) then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(sunStrike), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
		AIO_Umbrella.InvokerCanComboStart = true
			if not NPC.IsEntityInRange(myHero, enemy, 1000) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
						AIO_Umbrella.noItemCastFor(0.5)
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
						return
					else
						if AIO_Umbrella.SleepReady(0.1) then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
							AIO_Umbrella.lastTick = os.clock()
							AIO_Umbrella.noItemCastFor(0.5)
							return
						end
					end
				end
				if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
					AIO_Umbrella.noItemCastFor(0.5)
					return
				end
			else
				if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if not Ability.IsReady(tornado) then
					if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, chaosMeteor) then
						AIO_Umbrella.invokerInvokeAbility(myHero, chaosMeteor)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
		else
			if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
				if not AIO_Umbrella.InvokerCanComboStart then
					AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
		end
		
		if NPC.HasModifier(enemy, "modifier_invoker_tornado") and AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(sunStrike)) then
			if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
				local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
					if distance < 0 then
						distance = 0
					end
				local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
				if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
					if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
						AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
							if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
								Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
				else
					if not NPC.IsEntityInRange(myHero, enemy, 950) then
						AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
							if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
								Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
								AIO_Umbrella.lastTick = os.clock()
								return
							end
						end
					end
				end
			end			
		
			if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
							Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250))
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					end
				end
			end
		end
		

		if not Ability.IsReady(chaosMeteor) then
			if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, deafeningBlast) then
				AIO_Umbrella.invokerInvokeAbility(myHero, deafeningBlast)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				else
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end	
			end
		end

		if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			if refresher and Ability.IsCastable(refresher, myMana) then
				Ability.CastNoTarget(refresher)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	else
		if Ability.SecondsSinceLastUse(refresher) > 3 then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(refresher) and Ability.SecondsSinceLastUse(refresher) > 0 and Ability.SecondsSinceLastUse(refresher) < 3 then
		if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
			Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
			AIO_Umbrella.lastTick = os.clock()
			return
		end
		if not Ability.IsReady(chaosMeteor) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
				AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
		if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
					Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
					AIO_Umbrella.lastTick = os.clock()
					return
			end
		end
		if not Ability.IsReady(sunStrike) then
			if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(refresher) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(sunStrike) and not Ability.IsReady(deafeningBlast) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end
	
	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return		
end

function AIO_Umbrella.InvokerComboRefresherAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if not refresher then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
		AIO_Umbrella.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) or not Ability.IsReady(refresher) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		end
	end

	if Ability.IsReady(refresher) then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(emp), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
		AIO_Umbrella.InvokerCanComboStart = true
			if not NPC.IsEntityInRange(myHero, enemy, 1000) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
						AIO_Umbrella.noItemCastFor(0.5)
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
						return
					else
						if AIO_Umbrella.SleepReady(0.1) then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
							AIO_Umbrella.lastTick = os.clock()
							AIO_Umbrella.noItemCastFor(0.5)
							return
						end
					end
				end
				if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
					AIO_Umbrella.noItemCastFor(0.5)
					return
				end
			else
				if AIO_Umbrella.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.lastCastTime = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						AIO_Umbrella.lastTick = os.clock()
						AIO_Umbrella.lastCastTime = os.clock()
						AIO_Umbrella.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if not Ability.IsReady(tornado) then
					if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, chaosMeteor) then
						AIO_Umbrella.invokerInvokeAbility(myHero, chaosMeteor)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end	
			end
		else
			if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
				if not AIO_Umbrella.InvokerCanComboStart then
					AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
		end

		if not Ability.IsReady(tornado) and AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(emp)) then
			if AIO_Umbrella.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
				local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
				local tornadoTiming = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
				if os.clock() - AIO_Umbrella.lastCastTime > tornadoTiming - 2.9 + 0.25 then
					if NPC.IsEntityInRange(myHero, enemy, 925) then
						Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						return
					else
						Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
					local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
						if distance < 0 then
							distance = 0
						end
					local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
					if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
							AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
						else
							if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
								if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
									Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
									AIO_Umbrella.lastTick = os.clock()
									return
								end
							end
						end
					else
						if not NPC.IsEntityInRange(myHero, enemy, 950) then
							AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
						else
							if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
								if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
									Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
									AIO_Umbrella.lastTick = os.clock()
									return
								end
							end
						end
					end
				end
			end			
		end		

		if not Ability.IsReady(chaosMeteor) then
			if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, deafeningBlast) then
				AIO_Umbrella.invokerInvokeAbility(myHero, deafeningBlast)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
			if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				else
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			end
		end

		if not Ability.IsReady(tornado) and not Ability.IsReady(emp) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			if refresher and Ability.IsCastable(refresher, myMana) then
				Ability.CastNoTarget(refresher)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	else
		if Ability.SecondsSinceLastUse(refresher) > 3 then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(refresher) and Ability.SecondsSinceLastUse(refresher) > 0 and Ability.SecondsSinceLastUse(refresher) < 3 then
		if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
			Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
			AIO_Umbrella.lastTick = os.clock()
			return
		end
		if not Ability.IsReady(chaosMeteor) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, emp) then
			if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, emp) then
				AIO_Umbrella.invokerInvokeAbility(myHero, emp)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
		if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, emp) then
			if AIO_Umbrella.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
				if NPC.IsEntityInRange(myHero, enemy, 625) then
							Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
							AIO_Umbrella.lastTick = os.clock()
							return
						else
							Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
							AIO_Umbrella.lastTick = os.clock()
							return
						end
					Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
			end
		end
		if not Ability.IsReady(emp) then
			if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(refresher) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(emp) and not Ability.IsReady(deafeningBlast) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return		
end

function AIO_Umbrella.InvokerComboRefresherAghaBlastMeteorSunstrike(myHero, myMana, enemy, deafeningBlast, chaosMeteor, sunStrike, blink, aghanims, refresher, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if not refresher then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end
	AIO_Umbrella.itemUsage(myHero, enemy)

	if Ability.IsReady(refresher) then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(deafeningBlast), Ability.GetName(chaosMeteor)) and invoke and Ability.IsReady(invoke) then
		AIO_Umbrella.InvokerCanComboStart = true
			if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)-50))
						AIO_Umbrella.lastTick = os.clock()
						return
					else
						AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy), myHero)
						return
					end
				end
				if not blink or (blink and not Ability.IsReady(blink)) then
					AIO_Umbrella.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
					return
				end
			else
				if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end

				if not Ability.IsReady(deafeningBlast) then
					if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
						Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end

				if not Ability.IsReady(deafeningBlast) and not Ability.IsReady(chaosMeteor) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
					if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
						AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
						AIO_Umbrella.lastTick = os.clock()
						return
					end
				end
			end
		else
			if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
				if not AIO_Umbrella.InvokerCanComboStart then
					AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
		end
		
		if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") and AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(sunStrike), Ability.GetName(deafeningBlast)) then
			if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
				Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	
		if not Ability.IsReady(deafeningBlast) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(sunStrike) then
			if refresher and Ability.IsCastable(refresher, myMana) then
				Ability.CastNoTarget(refresher)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	else
		if Ability.SecondsSinceLastUse(refresher) > 3 then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
				AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(refresher) and Ability.SecondsSinceLastUse(refresher) > 0 and Ability.SecondsSinceLastUse(refresher) < 3 then
		if AIO_Umbrella.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) then
			if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") then
				local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_deafening_blast_knockback")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					AIO_Umbrella.lastTick = os.clock()
					return
				end
			else
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
		if not Ability.IsReady(deafeningBlast) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, chaosMeteor) then
			if AIO_Umbrella.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, chaosMeteor) then
				AIO_Umbrella.invokerInvokeAbility(myHero, chaosMeteor)
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
		if not Ability.IsReady(deafeningBlast) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, chaosMeteor) then
			if AIO_Umbrella.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
				Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
		if not Ability.IsReady(deafeningBlast) and AIO_Umbrella.InvokerIsAbilityInvoked(myHero, chaosMeteor) and not Ability.IsReady(sunStrike) then
			if AIO_Umbrella.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
				Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
				AIO_Umbrella.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if not Ability.IsReady(refresher) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(sunStrike) and not Ability.IsReady(deafeningBlast) then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end

	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end

function AIO_Umbrella.InvokerSkillProcessingTornado(myHero, myMana, enemy)

	if not enemy then return end

	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
		if not tornado then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local blastTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100
	local tornadoLiftDuration = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) <= 2.9 then
		if tornadoTiming > 2.95 then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) + 2.95 - tornadoTravelTime
		else
			delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
		end
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) <= 1.7 then
		if tornadoTiming > 1.75 then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.75 - tornadoTravelTime + 0.1
		else
			delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
		end
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) <= 1.3 + 2 then
		if tornadoTiming > 1.3 then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) + 3.0 - tornadoTravelTime
		else
			delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
		end
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) <= Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) * 0.25 + blastTravelTime then
		if tornadoTiming > Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) * 0.25 + blastTravelTime then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) * 0.25 + blastTravelTime - tornadoTravelTime
		else
			delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
		end
	elseif NPC.HasModifier(enemy, "modifier_invoker_cold_snap") then
		delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_cold_snap")) - 0.1 - tornadoTravelTime
	elseif  NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
		delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_sheepstick_debuff")) - 0.1 - tornadoTravelTime
	elseif AIO_Umbrella.TargetDisableTimer(myHero, enemy) > 0 then
		delay = AIO_Umbrella.TargetDisableTimer(myHero, enemy) + 0.05 - tornadoTravelTime
	else
		delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
	end
		

	return { delay, AIO_Umbrella.castLinearPrediction(myHero, enemy, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_tornado")) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)) }

end

function AIO_Umbrella.InvokerSkillProcessingEMP(myHero, myMana, enemy)

	if not enemy then return end

	local emp = NPC.GetAbility(myHero, "invoker_emp")
		if not emp then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if AIO_Umbrella.InvokerLastCastedSkill == nil then
		delay = 0.05
	else
		if Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "invoker_tornado" then
			if AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming > curTime + 2.9 then
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming - 2.9
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		else
			delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
		end
	end

	return { delay, Entity.GetAbsOrigin(enemy) }

end

function AIO_Umbrella.InvokerSkillProcessingMeteor(myHero, myMana, enemy)

	if not enemy then return end

	local chaosMeteor = NPC.GetAbility(myHero, "invoker_chaos_meteor")
		if not chaosMeteor then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if AIO_Umbrella.InvokerLastCastedSkill == nil then
		if AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) > 0 then
			local timing = AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) - 1.25
			delay = timing
		else
			delay = 0.05
		end
	else
		if Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "invoker_tornado" then
			if AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming > curTime + 1.3 then
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming - 1.3
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		else
			if AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) > 0 then
				local timing = AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) - 1.25
				delay = timing
			elseif not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > 0 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.5) then
					delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - 1.3
				else
					delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
				end
			elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		end
	end

	local position = Vector()
	if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") or Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
		position = Entity.GetAbsOrigin(enemy)
	elseif AIO_Umbrella.InvokerLastCastedSkill ~= nil and Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "invoker_deafening_blast" then
		position = Entity.GetAbsOrigin(enemy)
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100 + 0.25) then
		position = Entity.GetAbsOrigin(enemy)
	else
		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
	end

	return { delay, position }

end

function AIO_Umbrella.InvokerSkillProcessingBlast(myHero, myMana, enemy)

	if not enemy then return end

	local deafeningBlast = NPC.GetAbility(myHero, "invoker_deafening_blast")
		if not deafeningBlast then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration
	
	local curTime = GameRules.GetGameTime()

	local delay
	if AIO_Umbrella.InvokerLastCastedSkill == nil then
		if AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) > 0 then
			local timing = AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
			delay = timing
		else
			delay = 0.05
		end
	else
		if Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "invoker_tornado" then
			if AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming > curTime + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100 - 0.25 then
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		else
			if AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) > 0 then
				local timing = AIO_Umbrella.TargetIsInvulnarable(myHero, enemy) - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
				delay = timing
			elseif not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > 0 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.5) then
					delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
				else
					delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
				end
			elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		end
	end

	return { delay, Entity.GetAbsOrigin(enemy) }

end

function AIO_Umbrella.InvokerSkillProcessingSunstrike(myHero, myMana, enemy)

	if not enemy then return end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
		if not sunStrike then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if AIO_Umbrella.InvokerLastCastedSkill == nil then
		if AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
			local timing = AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1]
			delay = timing
		elseif NPC.HasItem(myHero, "item_rod_of_atos", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500 + 0.25) then
			delay = curTime + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500 + 0.25
		else
			delay = 0.05
		end
	else
		if Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "invoker_tornado" then
			if AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming > curTime + 1.7 then
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + tornadoTiming - 1.7
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		elseif Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "item_rod_of_atos" then
			delay = AIO_Umbrella.InvokerLastCastedSkillTime + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500
		elseif Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "item_cyclone" then
			if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_cyclone", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_cyclone", true)) < 2.55 then
				delay = curTime - Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_cyclone", true)) + 2.5 - 1.7
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end

		else
			if AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
				local timing = AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1]
				delay = timing
			elseif not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.5) then
					delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - 1.7
				else
					delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
				end
			elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7
			else
				delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		end
	end

	local position = Vector()
	if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") then
		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250))
--	elseif AIO_Umbrella.InvokerLastCastedSkill ~= nil and Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "invoker_deafening_blast" then
--		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300 - (curTime - AIO_Umbrella.InvokerLastCastedSkillTime)*150))
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100 + 0.25) then
		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
	elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		position = Entity.GetAbsOrigin(enemy)
	else
		if AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
			position = Entity.GetAbsOrigin(enemy)
		else
			position = AIO_Umbrella.castPrediction(myHero, enemy, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
		end
	end

	return { delay, position }

end

function AIO_Umbrella.InvokerSkillProcessingIcewall(myHero, myMana, enemy)

	if not enemy then return end

	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
		if not iceWall then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.1) then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - 0.5
	else
		delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
	end

	return { delay, nil }

end

function AIO_Umbrella.InvokerSkillProcessingEuls(myHero, myMana, enemy)

	if not enemy then return end

	local euls = NPC.GetItem(myHero, "item_cyclone", true)
		if not euls then return { 0.05, nil } end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.1) then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming + 0.15
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) < 2.95 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) + 2.95
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) < 1.8 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.8
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) < 2.5 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) + 2.5
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_cold_snap")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_cold_snap")) < 4 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) + 4
	else
		delay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
	end

	return { delay, enemy }
	

end

function AIO_Umbrella.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)

	if not myHero then return end
	if not enemy then return end
	if not NPC.IsEntityInRange(myHero, enemy, 1500) then return end
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	local skillTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher"
			}
		
	local skillOrder = {}
	if AIO_Umbrella.InvokerComboSelector == 12 then
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill5) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill5)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill6) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill6)])
		end
	elseif AIO_Umbrella.InvokerComboSelector == 13 then
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill5) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill5)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill6) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill6)])
		end
	elseif AIO_Umbrella.InvokerComboSelector == 14 then
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill5) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill5)])
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill6) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill6)])
		end
	end

	local skillProcessing = { 
		["invoker_tornado"] = { "position", AIO_Umbrella.InvokerSkillProcessingTornado(myHero, myMana, enemy) }, 
		["invoker_emp"] = { "position", AIO_Umbrella.InvokerSkillProcessingEMP(myHero, myMana, enemy) },
		["invoker_chaos_meteor"] = { "position", AIO_Umbrella.InvokerSkillProcessingMeteor(myHero, myMana, enemy) },
		["invoker_deafening_blast"] = { "position", AIO_Umbrella.InvokerSkillProcessingBlast(myHero, myMana, enemy) },
		["invoker_sun_strike"] = { "position", AIO_Umbrella.InvokerSkillProcessingSunstrike(myHero, myMana, enemy) },
		["invoker_ice_wall"] = { "no target", AIO_Umbrella.InvokerSkillProcessingIcewall(myHero, myMana, enemy) },
		["invoker_cold_snap"] = { "target", enemy },
		["invoker_forge_spirit"] = { "no target", nil },
		["invoker_alacrity"] = { "target", myHero },
		["item_cyclone"] = { "target", AIO_Umbrella.InvokerSkillProcessingEuls(myHero, myMana, enemy) },
		["item_rod_of_atos"] = { "target", enemy },
		["item_refresher"] = { "no target", nil }
				}

	local readyTable = {}
	for i = 1, #skillOrder do
		if skillOrder[i] == "item_refresher" then
			if NPC.HasItem(myHero, skillOrder[i], true) then
				if Ability.IsReady(NPC.GetItem(myHero, skillOrder[i], true)) then
					table.insert(readyTable, NPC.GetItem(myHero, skillOrder[i], true))
				end
			else
				break	
			end
		elseif skillOrder[i] == "item_cyclone" then
			if NPC.HasItem(myHero, skillOrder[i], true) then
				if Ability.IsReady(NPC.GetItem(myHero, skillOrder[i], true)) then
					table.insert(readyTable, NPC.GetItem(myHero, skillOrder[i], true))
				end
			end
		elseif skillOrder[i] == "item_rod_of_atos" then
			if NPC.HasItem(myHero, skillOrder[i], true) then
				if Ability.IsReady(NPC.GetItem(myHero, skillOrder[i], true)) then
					table.insert(readyTable, NPC.GetItem(myHero, skillOrder[i], true))
				end
			end
		else
			if Ability.IsReady(NPC.GetAbility(myHero, skillOrder[i])) then
				table.insert(readyTable, NPC.GetAbility(myHero, skillOrder[i]))
			end
		end
	end

	if NPC.HasItem(myHero, "item_refresher", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_refresher", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_refresher", true)) < 7 then
			for a, b in ipairs(skillOrder) do
				if b == "item_refresher" then
					readyTable = {}
					for i = a+1, #skillOrder do
						if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) then
							table.insert(readyTable, NPC.GetAbilityByIndex(myHero, 4))
						end
						if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
							table.insert(readyTable, NPC.GetAbilityByIndex(myHero, 3))
						end
						if skillOrder[i] == "item_cyclone" then
							if NPC.HasItem(myHero, "item_cyclone", true) then
								if Ability.IsReady(NPC.GetItem(myHero, "item_cyclone", true)) then
									table.insert(readyTable, NPC.GetItem(myHero, "item_cyclone", true))
								end
							end
						else
							if Ability.IsReady(NPC.GetAbility(myHero, skillOrder[i])) then
								table.insert(readyTable, NPC.GetAbility(myHero, skillOrder[i]))
							end
						end
					end
				end
			end
		end
	end

	local skill
		if #readyTable > 0 then
			skill = readyTable[1]
		else
			skill = nil
		end

	local invokeSkill
		if not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
			if #readyTable > 1 then
				invokeSkill = readyTable[2]
			else
				invokeSkill = nil
			end
		elseif not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
			if #readyTable > 0 then
				invokeSkill = readyTable[1]
			else
				invokeSkill = nil
			end
		end

	if invokeSkill then
		if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, invokeSkill) then
			if GameRules.GetGameTime() - AIO_Umbrella.lastCastTime3 > 0.05 and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, invokeSkill) then
				AIO_Umbrella.invokerInvokeAbility(myHero, invokeSkill)
				AIO_Umbrella.lastCastTime3 = GameRules.GetGameTime()
				return
			end
		end
	end

	local processingTempTable = {}
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				table.insert(processingTempTable, skillProcessing[Ability.GetName(skill)][2])
			elseif NPC.HasItem(myHero, "item_cyclone", true) and Ability.GetName(skill) == "item_cyclone" then
				table.insert(processingTempTable, skillProcessing[Ability.GetName(skill)][2])
			else
				processingTempTable = {}
			end
		end

	local targetingStyle
		if skill then
			targetingStyle = skillProcessing[Ability.GetName(skill)][1]
		end

	local targetingDelay
		if skill then
			if AIO_Umbrella.InvokerLastCastedSkill == nil then
				targetingDelay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			elseif Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				targetingDelay = processingTempTable[1][1]
			elseif NPC.HasItem(myHero, "item_cyclone", true) and Ability.GetName(skill) == "item_cyclone" then
				targetingDelay = processingTempTable[1][1]
			else
				targetingDelay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		end

	local targetingTarget	
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" then
				targetingTarget = processingTempTable[1][2]
			elseif NPC.HasItem(myHero, "item_cyclone", true) and Ability.GetName(skill) == "item_cyclone" then
				targetingTarget = processingTempTable[1][2]
			else
				targetingTarget = skillProcessing[Ability.GetName(skill)][2]
			end
		end

	if skill and Ability.GetName(skill) == "invoker_tornado" then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		else
			if not Ability.IsReady(skill) then
				AIO_Umbrella.itemUsage(myHero, enemy)
			end
		end
	else
		AIO_Umbrella.itemUsage(myHero, enemy)
	end

	if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		AIO_Umbrella.invokerForgedSpiritController(myHero, enemy)
	end

	if skill then
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)+200) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)-100))
					return
				end
			end
		else
			if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skill) or Ability.GetName(skill) == "item_refresher" or Ability.GetName(skill) == "item_cyclone" or Ability.GetName(skill) == "item_rod_of_atos" then
			AIO_Umbrella.InvokerCanComboStart = true
				if GameRules.GetGameTime() > targetingDelay then
					if Ability.IsCastable(skill, myMana) then
						if skillProcessing[Ability.GetName(skill)][1] == "position" then
							if Ability.GetName(skill) == "invoker_tornado" then
								Ability.CastPosition(skill, targetingTarget)
								AIO_Umbrella.noItemCastFor(((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + 0.5)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							else
								Ability.CastPosition(skill, targetingTarget)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "target" then
							if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastTarget(skill, targetingTarget)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "no target" then
							if Ability.GetName(skill) == "invoker_ice_wall" then
								if not NPC.IsEntityInRange(myHero, enemy, 600) then
									AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
									return
								else
									AIO_Umbrella.InvokerIceWallHelper(myHero, enemy, skill, myMana)
									AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime() + 0.1
									AIO_Umbrella.InvokerLastCastedSkill = skill
									return
								end
							else
								Ability.CastNoTarget(skill)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							end			
						end
					end
				end
			else
				if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
					if not AIO_Umbrella.InvokerCanComboStart then
						AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
						return
					end
				end
			end
		end
	else
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerForceDynamic) then
			AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerSwitch) then
		if next(readyTable) == nil then
			AIO_Umbrella.InvokerComboSelector = 11
		end
	end
	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)

		
end

function AIO_Umbrella.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)

	if not myHero then return end
	if not enemy then return end
	if not NPC.IsEntityInRange(myHero, enemy, 1500) then return end
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	local InvokerDynamicSpellsOrder = {}
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynCS) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynCS), "invoker_cold_snap" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynFS) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynFS), "invoker_forge_spirit" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynAL) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynAL), "invoker_alacrity" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynIW) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynIW), "invoker_ice_wall" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynTO) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynTO), "invoker_tornado" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynEMP) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynEMP), "invoker_emp" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynSS) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynSS), "invoker_sun_strike" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynCM) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynCM), "invoker_chaos_meteor" })
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynDB) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(AIO_Umbrella.optionHeroInvokerDynDB), "invoker_deafening_blast" })
	end

	table.sort(InvokerDynamicSpellsOrder, function(a, b)
        	return a[1] < b[1]
    	end)

	local skillPicker = {}
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerDynOrder) then
			i = 1
			repeat
				table.insert(skillPicker, InvokerDynamicSpellsOrder[i][2])
				i = i + 1
			until i > #InvokerDynamicSpellsOrder
		else
			skillPicker[1] = "invoker_cold_snap"
			skillPicker[2] = "invoker_forge_spirit"
			skillPicker[3] = "invoker_alacrity" 
			skillPicker[4] = "invoker_ice_wall"
			skillPicker[5] = "invoker_tornado"
			skillPicker[6] = "invoker_emp"
			skillPicker[7] = "invoker_sun_strike"
			skillPicker[8] = "invoker_chaos_meteor" 
			skillPicker[9] = "invoker_deafening_blast"
		end

	

	local skillProcessing = { 
		["invoker_tornado"] = { "position", AIO_Umbrella.InvokerSkillProcessingTornado(myHero, myMana, enemy) }, 
		["invoker_emp"] = { "position", AIO_Umbrella.InvokerSkillProcessingEMP(myHero, myMana, enemy) },
		["invoker_chaos_meteor"] = { "position", AIO_Umbrella.InvokerSkillProcessingMeteor(myHero, myMana, enemy) },
		["invoker_deafening_blast"] = { "position", AIO_Umbrella.InvokerSkillProcessingBlast(myHero, myMana, enemy) },
		["invoker_sun_strike"] = { "position", AIO_Umbrella.InvokerSkillProcessingSunstrike(myHero, myMana, enemy) },
		["invoker_ice_wall"] = { "no target", AIO_Umbrella.InvokerSkillProcessingIcewall(myHero, myMana, enemy) },
		["invoker_cold_snap"] = { "target", enemy },
		["invoker_forge_spirit"] = { "no target", nil },
		["invoker_alacrity"] = { "target", myHero }
				}

	local readyTable = {}
	for i = 1, #skillPicker do
		if Ability.IsReady(NPC.GetAbility(myHero, skillPicker[i])) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, NPC.GetAbility(myHero, skillPicker[i])) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, NPC.GetAbility(myHero, skillPicker[i])) then
			table.insert(readyTable, NPC.GetAbility(myHero, skillPicker[i]))
		end
	end

	local skill
	local invokeSkill
	if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_tornado" and AIO_Umbrella.TargetDisableTimer(myHero, enemy) == 0 then
		skill = NPC.GetAbilityByIndex(myHero, 3)	
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_ice_wall" then
		if NPC.IsEntityInRange(myHero, enemy, 800) then
			skill = NPC.GetAbilityByIndex(myHero, 4)
		else
			if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
				skill = NPC.GetAbilityByIndex(myHero, 3)
			else
				if next(readyTable) ~= nil then
					if #readyTable >= 1 then
						invokeSkill = readyTable[1]
					else
						skill = nil
						invokeSkill = nil
					end
				end
			end
		end
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_ghost_walk" then
		if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
			skill = NPC.GetAbilityByIndex(myHero, 3)
		else
			if next(readyTable) ~= nil then
				if #readyTable >= 1 then
					invokeSkill = readyTable[1]
				else
					skill = nil
					invokeSkill = nil
				end
			end
		end
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_ghost_walk" then
		if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) then
			skill = NPC.GetAbilityByIndex(myHero, 4)
		else
			if next(readyTable) ~= nil then
				if #readyTable >= 1 then
					invokeSkill = readyTable[1]
				else
					skill = nil
					invokeSkill = nil
				end
			end
		end
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_tornado" and AIO_Umbrella.TargetDisableTimer(myHero, enemy) > 0 then
		skill = NPC.GetAbilityByIndex(myHero, 3)
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) ~= "invoker_ghost_walk" and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) ~= "invoker_empty2" then
		skill = NPC.GetAbilityByIndex(myHero, 4)
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) ~= "invoker_ghost_walk"  and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) ~= "invoker_empty1" then
		skill = NPC.GetAbilityByIndex(myHero, 3)
	end

	
	if not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) then
		if next(readyTable) ~= nil then
			if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + AIO_Umbrella.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))) and NPC.GetCurrentLevel(myHero) >= 10 then
				if Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_emp" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_chaos_meteor")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_chaos_meteor")
					else
						if Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
							invokeSkill = NPC.GetAbility(myHero, "invoker_deafening_blast")
						else
							invokeSkill = readyTable[1]
						end
					end
				elseif Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_sun_strike" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_chaos_meteor")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_chaos_meteor")
					else
						if Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
							invokeSkill = NPC.GetAbility(myHero, "invoker_deafening_blast")
						else
							invokeSkill = readyTable[1]
						end
					end
				elseif Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_chaos_meteor" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_deafening_blast")
					else
						invokeSkill = readyTable[1]
					end
				else
					invokeSkill = readyTable[1]
				end
			else
				if AIO_Umbrella.InvokerLastCastedSkill ~= nil and Ability.GetName(AIO_Umbrella.InvokerLastCastedSkill) == "invoker_deafening_blast" and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_chaos_meteor" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_sun_strike")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_sun_strike")
					else
						invokeSkill = readyTable[1]
					end
				elseif  Ability.GetName(readyTable[1]) == "invoker_ice_wall" and #readyTable >= 1 then
					if NPC.IsEntityInRange(myHero, enemy, 800) then
						invokeSkill = readyTable[1]
					else
						if #readyTable > 1 then
							invokeSkill = readyTable[2]
						else
							invokeSkill = nil
						end
					end
				elseif  Ability.GetName(readyTable[1]) == "invoker_sun_strike" and #readyTable >= 1 then
					if AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
						invokeSkill = readyTable[1]
					else
						if NPC.HasModifier(enemy, "modifier_sheepstick_debuff") or NPC.HasModifier(enemy, "modifier_invoker_cold_snap") or NPC.HasModifier(enemy, "modifier_invoker_ice_wall_slow_debuff") then
							invokeSkill = readyTable[1]
						else
							if #readyTable > 1 then
								invokeSkill = readyTable[2]
							else
								invokeSkill = nil
							end
						end
					end
				else
					invokeSkill = readyTable[1]
				end
			end
		end
	end

	if invokeSkill then
		if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, invokeSkill) then
			if GameRules.GetGameTime() - AIO_Umbrella.lastCastTime3 > 0.05 and invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, invokeSkill) then
				AIO_Umbrella.invokerInvokeAbility(myHero, invokeSkill)
				AIO_Umbrella.lastCastTime3 = GameRules.GetGameTime()
				return
			end
		end
	end

	local processingTempTable = {}
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				table.insert(processingTempTable, skillProcessing[Ability.GetName(skill)][2])
			else
				processingTempTable = {}
			end
		end

	local targetingStyle
		if skill then
			targetingStyle = skillProcessing[Ability.GetName(skill)][1]
		end

	local targetingDelay
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				targetingDelay = processingTempTable[1][1]
			elseif Ability.GetName(skill) == "invoker_alacrity" or Ability.GetName(skill) == "invoker_forge_spirit" or Ability.GetName(skill) == "invoker_cold_snap" then
				targetingDelay = AIO_Umbrella.InvokerLastCastedSkillTime + 0.05
			end
		end

	local targetingTarget	
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" then
				targetingTarget = processingTempTable[1][2]
			else
				targetingTarget = skillProcessing[Ability.GetName(skill)][2]
			end
		end

	if skill and Ability.GetName(skill) == "invoker_tornado" then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoItems) then
			AIO_Umbrella.itemUsage(myHero, enemy)
		else
			if not Ability.IsReady(skill) then
				AIO_Umbrella.itemUsage(myHero, enemy)
			end
		end
	else
		AIO_Umbrella.itemUsage(myHero, enemy)
	end

	if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
		if skill and not Ability.GetName(skill) == "invoker_ice_wall" then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			AIO_Umbrella.invokerForgedSpiritController(myHero, enemy)
		elseif not skill or (skill and not Ability.IsCastable(skill, myMana)) then
			AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			AIO_Umbrella.invokerForgedSpiritController(myHero, enemy)
		end
	end

	if skill then
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)+200) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)-100))
					return
				end
			end
		else
			if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skill) then
				if GameRules.GetGameTime() > targetingDelay then
					if Ability.IsCastable(skill, myMana) then
						if skillProcessing[Ability.GetName(skill)][1] == "position" then
							if Ability.GetName(skill) == "invoker_tornado" then
								Ability.CastPosition(skill, targetingTarget)
								AIO_Umbrella.noItemCastFor(((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + 0.5)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							else
								Ability.CastPosition(skill, targetingTarget)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "target" then
							if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastTarget(skill, targetingTarget)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "no target" then
							if Ability.GetName(skill) == "invoker_ice_wall" then
								if not NPC.IsEntityInRange(myHero, enemy, 600) then
									AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
									return
								else
									AIO_Umbrella.InvokerIceWallHelper(myHero, enemy, skill, myMana)
									AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime() + 0.5
									AIO_Umbrella.InvokerLastCastedSkill = skill
									return
								end
							else
								Ability.CastNoTarget(skill)
								AIO_Umbrella.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								AIO_Umbrella.InvokerLastCastedSkill = skill
								return
							end		
						end
					end
				end
			end
		end
	end
	AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)
end

function AIO_Umbrella.InvokerFastIceWall(myHero, myMana, invoke, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerIcewallEnable) then return end
	if not myHero then return end
	if enemy then
		if not NPC.IsEntityInRange(myHero, enemy, 600) then
			enemy = nil
		end
	end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end
	
	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
		if not iceWall then return end
		if not Ability.IsReady(iceWall) then return end

	if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, iceWall) then
		if invoke and Ability.IsCastable(invoke, myMana-175) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, iceWall) then
			if enemy then
				AIO_Umbrella.invokerInvokeAbility(myHero, iceWall)
				AIO_Umbrella.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
				return
			else
				AIO_Umbrella.invokerInvokeAbility(myHero, iceWall)
				Ability.CastNoTarget(iceWall, true)
				return
			end
		end
	else
		if Ability.IsCastable(iceWall, myMana) then
			if enemy then
				AIO_Umbrella.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
			else
				Ability.CastNoTarget(iceWall)
				return
			end
		end
	end

end

function AIO_Umbrella.InvokerFastAlacrity(myHero, myMana, invoke, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAlacrityEnable) then return end
	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end
	
	local alacrity = NPC.GetAbility(myHero, "invoker_alacrity")
		if not alacrity then return end
		if not Ability.IsReady(alacrity) then return end
	
	if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, alacrity) then
		if invoke and Ability.IsCastable(invoke, myMana-60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, alacrity) then
			AIO_Umbrella.invokerInvokeAbility(myHero, alacrity)
			Ability.CastTarget(alacrity, myHero)
			return
		end
	else
		if Ability.IsCastable(alacrity, myMana) then
			Ability.CastTarget(alacrity, myHero)
			return
		end
	end

end

function AIO_Umbrella.InvokerFastTornado(myHero, myMana, invoke, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerTornadoEnable) then return end
	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 then return end

	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
		if not tornado then return end
		if not Ability.IsReady(tornado) then return end

	local tornadoRange = math.min(400 + 400 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_wex")), 2000)

	if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) then
		if invoke and Ability.IsCastable(invoke, myMana-150) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, tornado) then
			AIO_Umbrella.invokerInvokeAbility(myHero, tornado)
			if Menu.GetValue(AIO_Umbrella.optionHeroInvokerTornadoStyle) == 0 then
				if NPC.IsEntityInRange(myHero, enemy, tornadoRange) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
					return
				end
			else
				local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500)
				Ability.CastPosition(tornado, pos)
				return
			end
		end
	else
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerTornadoStyle) == 0 then
			if NPC.IsEntityInRange(myHero, enemy, tornadoRange) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, enemy, tornadoPrediction))
				return
			end
		else
			local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500)
			Ability.CastPosition(tornado, pos)
			return
		end
	end

end

function AIO_Umbrella.InvokerCataclysmKillSteal(myHero, myMana, invoke)

	if not myHero then return false end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	local cataclysm = NPC.GetAbility(myHero, "special_bonus_unique_invoker_4")
		if not cataclysm then return end
		if Ability.GetLevel(cataclysm) < 1 then return end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
		if not sunStrike then return end
		if not Ability.IsReady(sunStrike) then return end
		if not Ability.IsCastable(sunStrike, myMana) then return end

	local damage = (37.5 + 62.5 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort"))) * 0.95

	local ssSlot = 3
		if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_sun_strike" then
				ssSlot = 4
			end
		end

	local count = 0
	for i = 1, Heroes.Count(), 1 do
		local enemies = Heroes.Get(i)
		if enemies ~= nil and Entity.IsHero(enemies) and not Entity.IsSameTeam(myHero, enemies) then
			local enemy = AIO_Umbrella.targetChecker(enemies)
			if enemy then
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
					if Entity.GetHealth(enemy) + NPC.GetHealthRegen(enemy) * 2 <= damage then
						count = count + 1
					end
				end
			end
		end
	end

	if count > 0 then
		if count >= Menu.GetValue(AIO_Umbrella.optionHeroInvokerCataKSCount) then
			if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
				if invoke and Ability.IsCastable(invoke, myMana-175) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
					AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
					return
				end
			else
				if os.clock() - AIO_Umbrella.invokerChannellingKillstealTimer > 0.5 then
					Ability.CastTarget(sunStrike, myHero)
					AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
					return
				end
			end	
		end
	end

	return

end

function AIO_Umbrella.InvokerCancelTPingInFog(myHero, myMana, enemy, invoke, tornado)

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionComboKey) then return end
	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then return end

	if os.clock() - AIO_Umbrella.invokerChannellingKillstealTimer <= 3 then return end

	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	if not tornado then return end
	if not Ability.IsReady(tornado) then return end
	if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) and not Ability.IsCastable(invoke, myMana) then return end

	if AIO_Umbrella.TPParticleUnit ~= nil and NPC.IsDormant(AIO_Umbrella.TPParticleUnit) then
		if AIO_Umbrella.TPParticleTime > 0 and AIO_Umbrella.TPParticlePosition:__tostring() ~= Vector(0.0, 0.0, 0.0):__tostring() and not AIO_Umbrella.invokerSunstrikeKSParticleProcess(myHero) then
			if (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.TPParticlePosition):Length2D() < 2250 then
				if GameRules.GetGameTime() + ((Entity.GetAbsOrigin(myHero) - AIO_Umbrella.TPParticlePosition):Length2D() / 1000) < AIO_Umbrella.TPParticleTime + 2.75 then
					if NPC.IsPositionInRange(myHero, AIO_Umbrella.TPParticlePosition, (400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400), 0) then
						if tornado and Ability.IsReady(tornado) then
							if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) then
								if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(tornado, myMana - 60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, tornado) then
									AIO_Umbrella.invokerInvokeAbility(myHero, tornado)
									Ability.CastPosition(tornado, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.TPParticlePosition - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250), true)
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									return
								end
							else
								if Ability.IsCastable(tornado, myMana) then
									Ability.CastPosition(tornado, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.TPParticlePosition - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250))
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									return
								end
							end
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.InvokerCancelBaraCharge(myHero, myMana, enemy, invoke, coldSnap, tornado, deafeningBlast)

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionComboKey) then return end
	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then return end

	if os.clock() - AIO_Umbrella.invokerChannellingKillstealTimer <= 3 then return end

	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	if not coldSnap or not tornado or not deafeningBlast then return end
	if not Ability.IsReady(coldSnap) and not Ability.IsReady(tornado) and not Ability.IsReady(deafeningBlast) then return end
	if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, coldSnap) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, deafeningBlast) and not Ability.IsCastable(invoke, myMana) then return end

	local skillSelector
	if Ability.IsReady(coldSnap) then
		skillSelector = coldSnap
	else
		if Ability.IsReady(tornado) then
			skillSelector = tornado
		else
			if Ability.IsReady(deafeningBlast) then
				skillSelector = deafeningBlast
			end
		end
	end

	if not skillSelector then return end

	local castRange = 950
	if skillSelector ~= nil and skillSelector == tornado then
		castRange = 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400
	end
	if castRange > 1750 then
		castRange = 1750
	end

	local cancelEnemies = NPC.GetHeroesInRadius(myHero, castRange, Enum.TeamType.TEAM_ENEMY)
	for _, cancelEnemy in ipairs(cancelEnemies) do
		if cancelEnemy and not NPC.IsDormant(cancelEnemy) and not NPC.IsIllusion(cancelEnemy) and Entity.IsAlive(cancelEnemy) then
			if NPC.HasModifier(cancelEnemy, "modifier_spirit_breaker_charge_of_darkness") then
				if not NPC.HasState(cancelEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then	
					if not NPC.IsLinkensProtected(cancelEnemy) then
						if skillSelector == coldSnap then
							if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skillSelector) then
								if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, skillSelector) then
									AIO_Umbrella.invokerInvokeAbility(myHero, skillSelector)
									Ability.CastTarget(skillSelector, cancelEnemy, true)
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							else
								if Ability.IsCastable(skillSelector, myMana) then
									Ability.CastTarget(skillSelector, cancelEnemy)
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							end
						elseif skillSelector == deafeningBlast then
							local deafeningBlastPrediction = Ability.GetCastPoint(skillSelector) + (Entity.GetAbsOrigin(cancelEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) + NPC.GetTimeToFace(myHero, cancelEnemy) + 1
							if NPC.IsRunning(cancelEnemy) and AIO_Umbrella.GetMoveSpeed(cancelEnemy) > 500 then
								if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skillSelector) then
									if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, skillSelector) then
										AIO_Umbrella.invokerInvokeAbility(myHero, skillSelector)
										Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.castLinearPrediction(myHero, cancelEnemy, deafeningBlastPrediction) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(50), true)
										AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								else
									if Ability.IsCastable(skillSelector, myMana) then
										Ability.CastPosition(deafeningBlast, AIO_Umbrella.castLinearPrediction(myHero, cancelEnemy, deafeningBlastPrediction))
										AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								end
							end
						end
					end		
					if skillSelector == tornado then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(cancelEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) * 1.25 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) + 0.75 + NPC.GetTimeToFace(myHero, cancelEnemy)
						if NPC.IsRunning(cancelEnemy) and AIO_Umbrella.GetMoveSpeed(cancelEnemy) > 500 and not NPC.IsDormant(cancelEnemy) then
							if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) then
								if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, skillSelector) then
									AIO_Umbrella.invokerInvokeAbility(myHero, tornado)
									Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, cancelEnemy, tornadoPrediction), true)
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							else
								if Ability.IsCastable(tornado, myMana) then
									Ability.CastPosition(tornado, AIO_Umbrella.castLinearPrediction(myHero, cancelEnemy, tornadoPrediction))
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
		
end

function AIO_Umbrella.InvokerCancelVisibleChannellingAbilities(myHero, myMana, enemy, invoke, coldSnap, tornado)

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionComboKey) then return end
	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then return end

	if os.clock() - AIO_Umbrella.invokerChannellingKillstealTimer <= 3 then return end

	if not myHero then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	if not coldSnap or not tornado then return end
	if not Ability.IsReady(coldSnap) and not Ability.IsReady(tornado) then return end
	if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, coldSnap) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) and not Ability.IsCastable(invoke, myMana) then return end

	local channellingTable = {
		npc_dota_hero_bane = { "bane_fiends_grip", { 5, 5, 5 } },
		npc_dota_hero_crystal_maiden = { "crystal_maiden_freezing_field", { 10, 10, 10} },
		npc_dota_hero_enigma = { "enigma_black_hole", { 4, 4, 4 } },
		npc_dota_hero_oracle = { "oracle_fortunes_end", { 2.5, 2.5, 2.5, 2.5 } },
		npc_dota_hero_pudge = { "pudge_dismember", { 3, 3, 3 } },
		npc_dota_hero_pugna = { "pugna_life_drain", { 10, 10, 10 } },
		npc_dota_hero_sand_king = { "sandking_epicenter", { 2, 2, 2} },
		npc_dota_hero_shadow_shaman = { "shadow_shaman_shackles", { 2.75, 3.5, 4.25, 5 } },
		npc_dota_hero_tinker = { "tinker_rearm", { 3, 1.5, 0.75 } },
		npc_dota_hero_warlock = { "warlock_upheaval", { 16, 16, 16, 16 } },
		npc_dota_hero_witch_doctor = { "witch_doctor_death_ward", { 8, 8, 8} }
				}

	local cancelEnemies = NPC.GetHeroesInRadius(myHero, 1750, Enum.TeamType.TEAM_ENEMY)
	for _, cancelEnemy in ipairs(cancelEnemies) do
		if cancelEnemy and not NPC.IsDormant(cancelEnemy) and not NPC.IsIllusion(cancelEnemy) and Entity.IsAlive(cancelEnemy) then
			if not NPC.HasState(cancelEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				for i, v in pairs(channellingTable) do
					if (NPC.GetUnitName(cancelEnemy) == i and Ability.IsChannelling(NPC.GetAbility(cancelEnemy, v[1]))) or NPC.HasModifier(cancelEnemy, "modifier_teleporting") then
						local enemyRange = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(cancelEnemy)):Length2D()
						local skillSelector
							if AIO_Umbrella.InvokerIsAbilityInvoked(myHero, coldSnap) then
								if Ability.IsReady(coldSnap) and enemyRange < 950 then
									skillSelector = coldSnap
								else
									if Ability.IsReady(tornado) and enemyRange < 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400 then
										if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) then
											if Ability.IsReady(invoke) then
												skillSelector = tornado
											end
										else
											skillSelector = tornado
										end
									end
								end
							elseif AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) then
								if Ability.IsReady(tornado) and enemyRange < 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400 then
									skillSelector = tornado
								else
									if Ability.IsReady(coldSnap) and enemyRange < 950 then
										if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, coldSnap) then
											if Ability.IsReady(invoke) then
												skillSelector = coldSnap
											end
										else
											skillSelector = coldSnap
										end
									end
								end
							elseif not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, coldSnap) and not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, tornado) then
								if Ability.IsReady(invoke) then
									if Ability.IsReady(coldSnap) and enemyRange < 950 then
										skillSelector = coldSnap
									else
										if Ability.IsReady(tornado) and enemyRange < 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400 then
											skillSelector = tornado
										end
									end
								end
							end
						if skillSelector == nil then
							break
							return
						end

						if skillSelector == coldSnap then
							if not NPC.IsLinkensProtected(cancelEnemy) then
								if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skillSelector) then
									if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, skillSelector) then
										AIO_Umbrella.invokerInvokeAbility(myHero, skillSelector)
										Ability.CastTarget(skillSelector, cancelEnemy, true)
										AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								else
									if Ability.IsCastable(skillSelector, myMana) then
										Ability.CastTarget(coldSnap, cancelEnemy)
										AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								end
							end
						elseif skillSelector == tornado then
							if NPC.GetUnitName(cancelEnemy) == i and Ability.IsChannelling(NPC.GetAbility(cancelEnemy, v[1])) then
								if Ability.GetChannelStartTime(NPC.GetAbility(cancelEnemy, v[1])) + v[2][Ability.GetLevel(NPC.GetAbility(cancelEnemy, v[1]))] > GameRules.GetGameTime() + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1000) then
									if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skillSelector) then
										if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, skillSelector) then
											AIO_Umbrella.invokerInvokeAbility(myHero, skillSelector)
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy), true)
											AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									else
										if Ability.IsCastable(skillSelector, myMana) then
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy))
											AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									end
								end
							elseif NPC.HasModifier(cancelEnemy, "modifier_teleporting") then
								if GameRules.GetGameTime() + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1000) < Modifier.GetDieTime(NPC.GetModifier(cancelEnemy, "modifier_teleporting")) and Ability.IsReady(tornado) then
									if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skillSelector) then
										if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, skillSelector) then
											AIO_Umbrella.invokerInvokeAbility(myHero, skillSelector)
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy), true)
											AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									else
										if Ability.IsCastable(skillSelector, myMana) then
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy))
											AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end

end

function AIO_Umbrella.InvokerIsSkillInvokable(myHero, skill)

	if not myHero then return false end
	if not skill then return false end

	local skillName = Ability.GetName(skill)

	for i, v in pairs(AIO_Umbrella.invokerInvokeOrder) do
		if i == skillName then
			for k, l in ipairs(v) do
				if not NPC.GetAbilityByIndex(myHero, l) or (NPC.GetAbilityByIndex(myHero, l) and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, l)) < 1) then
					return false
				end
			end
		end
	end

	return true

end

function AIO_Umbrella.InvokerPreInvoke(myHero, myMana, invoke)

	if not myHero then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if os.clock() - AIO_Umbrella.lastTick < 0.5 then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		AIO_Umbrella.PreInvokeSkills = {}
		return
	end

	local skill1
	local skill2
	for _, v in ipairs(AIO_Umbrella.PreInvokeSkills) do
		if v then
			skill1 = v[1]
			skill2 = v[2]
		end
	end

	if not AIO_Umbrella.InvokerIsSkillInvokable(myHero, skill1) or not AIO_Umbrella.InvokerIsSkillInvokable(myHero, skill2) then
		AIO_Umbrella.PreInvokeSkills = {}
		return
	end
		
	local invokeChecker = AIO_Umbrella.InvokerInvokedChecker(myHero, Ability.GetName(skill1), Ability.GetName(skill2))

	if invokeChecker then
		AIO_Umbrella.PreInvokeSkills = {}
		return
	end

	if next(AIO_Umbrella.PreInvokeSkills) == nil then return end

	if Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == Ability.GetName(skill1) or Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == Ability.GetName(skill1) then
		if invoke and Ability.IsCastable(invoke, myMana) then
			AIO_Umbrella.invokerInvokeAbility(myHero, NPC.GetAbilityByIndex(myHero, 4))
			AIO_Umbrella.lastTick = os.clock()
			return
		end
	end

	if Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) ~= Ability.GetName(skill2) then
		if invoke and Ability.IsCastable(invoke, myMana) then
			AIO_Umbrella.invokerInvokeAbility(myHero, skill2)
			AIO_Umbrella.lastTick = os.clock()
			return
		end
	end

	if Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == Ability.GetName(skill2) then
		if invoke and Ability.IsCastable(invoke, myMana) then
			AIO_Umbrella.invokerInvokeAbility(myHero, skill1)
			AIO_Umbrella.lastTick = os.clock()
			return
		end
	end
end
			
function AIO_Umbrella.InvokerIsAbilityInvoked(myHero, skill)

	for i = 3, 4 do
		if Ability.GetName(NPC.GetAbilityByIndex(myHero, i)) == Ability.GetName(skill) then
			return true
		end
	end
	
	return false

end
	

function AIO_Umbrella.InvokerInvokedChecker(myHero, skill1, skill2)

	if Ability.GetName(NPC.GetAbilityByIndex(myHero,3)) == skill1 and Ability.GetName(NPC.GetAbilityByIndex(myHero,4)) == skill2 then
		return true
	end
	
	return false

end

function AIO_Umbrella.invokerInvokeAbility(myHero, ability)
	
	if not myHero then return end
	if not ability then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if not AIO_Umbrella.InvokerIsSkillInvokable(myHero, ability) then return end

	local skillName = Ability.GetName(ability)
    		if not skillName then return end

	local invokeOrder = AIO_Umbrella.invokerInvokeOrder[skillName]
    		if not invokeOrder then return end

	local invoke = NPC.GetAbility(myHero, "invoker_invoke")
		if not invoke then return end

	for i, v in ipairs(invokeOrder) do
        	local orb = NPC.GetAbilityByIndex(myHero, v)

        	if orb then
			Ability.CastNoTarget(orb)
		end
	end

	Ability.CastNoTarget(invoke)

end

function AIO_Umbrella.invokerProcessInstancesWhileComboing(myHero)

	if not myHero then return end
	if os.clock() - AIO_Umbrella.invokerCaptureGhostwalkActivation < 1.5 then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Ability.GetCooldownTimeLeft(NPC.GetAbility(myHero, "invoker_invoke")) < 0.25 then return end
	if Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then return end
	
	if os.clock() - AIO_Umbrella.InvokerCaptureManualInstances < 2.5 then return end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 1 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end
	
	if os.clock() - AIO_Umbrella.InvokerLastChangedInstance < 0.75 then return end

	local instanceTable = {}
	local modifiers = NPC.GetModifiers(myHero)
	for _, modifier in ipairs(modifiers) do
		if modifier then
			local modifierName = Modifier.GetName(modifier)
			if modifierName == "modifier_invoker_quas_instance" or modifierName == "modifier_invoker_wex_instance" or modifierName == "modifier_invoker_exort_instance" then
				table.insert(instanceTable, modifierName)
			end
		end
	end

	if #instanceTable < 3 then return end

	if Entity.GetHealth(myHero) < Entity.GetMaxHealth(myHero) * 0.25 then
		if instanceTable[1] ~= "modifier_invoker_quas_instance" or instanceTable[2] ~= "modifier_invoker_quas_instance" or instanceTable[3] ~= "modifier_invoker_quas_instance" then
			AIO_Umbrella.invokerChangeInstances(myHero, "QQQ")
			AIO_Umbrella.InvokerLastChangedInstance = os.clock()
		end
	else
		if instanceTable[1] ~= "modifier_invoker_exort_instance" or instanceTable[2] ~= "modifier_invoker_exort_instance" or instanceTable[3] ~= "modifier_invoker_exort_instance" then
			AIO_Umbrella.invokerChangeInstances(myHero, "EEE")
			AIO_Umbrella.InvokerLastChangedInstance = os.clock()
		end
	end

end

function AIO_Umbrella.invokerProcessInstances(myHero, order)

	if not myHero then return end
	if not order then return end
	if os.clock() - AIO_Umbrella.invokerCaptureGhostwalkActivation < 1.5 then return end
	if os.clock() - AIO_Umbrella.InvokerCaptureManualInstances < 2.5 then return end
	if next(AIO_Umbrella.PreInvokeSkills) ~= nil then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		return
	end

	if os.clock() - AIO_Umbrella.InvokerLastChangedInstance < Menu.GetValue(AIO_Umbrella.optionHeroInvokerInstanceDelay) * 0.25 then return end

	local instanceTable = {}
	local modifiers = NPC.GetModifiers(myHero)
	for _, modifier in ipairs(modifiers) do
		if modifier then
			local modifierName = Modifier.GetName(modifier)
			if modifierName == "modifier_invoker_quas_instance" or modifierName == "modifier_invoker_wex_instance" or modifierName == "modifier_invoker_exort_instance" then
				table.insert(instanceTable, modifierName)
			end
		end
	end

	if #instanceTable < 3 then return end

	if order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION or order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET then
		if Entity.GetHealth(myHero) < Entity.GetMaxHealth(myHero) then
			if instanceTable[1] ~= "modifier_invoker_quas_instance" or instanceTable[2] ~= "modifier_invoker_quas_instance" or instanceTable[3] ~= "modifier_invoker_quas_instance" then
				AIO_Umbrella.invokerChangeInstances(myHero, "QQQ")
				AIO_Umbrella.InvokerLastChangedInstance = os.clock()
			end
		else
			if instanceTable[1] ~= "modifier_invoker_wex_instance" or instanceTable[2] ~= "modifier_invoker_wex_instance" or instanceTable[3] ~= "modifier_invoker_wex_instance" then
				AIO_Umbrella.invokerChangeInstances(myHero, "WWW")
				AIO_Umbrella.InvokerLastChangedInstance = os.clock()
			end
		end
	end

	if order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE or order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
		local exort = NPC.GetAbilityByIndex(myHero, 2)
		if exort and Ability.GetLevel(exort) > 0 then
			if instanceTable[1] ~= "modifier_invoker_exort_instance" or instanceTable[2] ~= "modifier_invoker_exort_instance" or instanceTable[3] ~= "modifier_invoker_exort_instance" then
				AIO_Umbrella.invokerChangeInstances(myHero, "EEE")
				AIO_Umbrella.InvokerLastChangedInstance = os.clock()
			end
		else
			if instanceTable[1] ~= "modifier_invoker_wex_instance" or instanceTable[2] ~= "modifier_invoker_wex_instance" or instanceTable[3] ~= "modifier_invoker_wex_instance" then
				AIO_Umbrella.invokerChangeInstances(myHero, "WWW")
				AIO_Umbrella.InvokerLastChangedInstance = os.clock()
			end
		end
	end

end		

function AIO_Umbrella.invokerChangeInstances(myHero, instance)

	if not myHero then return end
	if not instance then return end

	if os.clock() - AIO_Umbrella.invokerCaptureGhostwalkActivation < 1.5 then return end
	
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		return
	end

	local invokeOrder = {}
	if instance == "QQQ" then
		local quas = NPC.GetAbilityByIndex(myHero, 0)
		if quas and Ability.GetLevel(quas) > 0 then
			invokeOrder = {0,0,0}
		end
	elseif instance == "WWW" then
		local wex = NPC.GetAbilityByIndex(myHero, 1)
		if wex and Ability.GetLevel(wex) > 0 then
			invokeOrder = {1,1,1}
		end
	elseif instance == "EEE" then
		local exort = NPC.GetAbilityByIndex(myHero, 2)
		if exort and Ability.GetLevel(exort) > 0 then
			invokeOrder = {2,2,2}
		end
	end

	for i, v in ipairs(invokeOrder) do
        	local orb = NPC.GetAbilityByIndex(myHero, v)

        	if orb then
			Ability.CastNoTarget(orb)
		end
	end

end

function AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	if not sunStrike or (sunStrike and not Ability.IsReady(sunStrike)) then return end
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local sunStrikeDMG = 37.5 + (62.5 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			sunStrikeDMG = 37.5 + (62.5 * (Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")) + 1))
		end

	local curTime = GameRules.GetGameTime()

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_rod_of_atos_debuff",
		"modifier_eul_cyclone",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption",
		"modifier_teleporting",
		"modifier_invoker_tornado"
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if not searchMod then return { 0, 0 } end

	local timing = 0
	local HPtreshold = 0
	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				if Modifier.GetCreationTime(searchMod) + 4 - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 2 * AIO_Umbrella.GetTeammateAbilityLevel(myHero, "enigma_black_hole") * 37
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				if Modifier.GetCreationTime(searchMod) + (3.5 + AIO_Umbrella.GetTeammateAbilityLevel(myHero, "faceless_void_chronosphere") * 0.5) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * 1.25
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_axe_berserkers_call" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * 1.35
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_bane_fiends_grip" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 2 * (45 + AIO_Umbrella.GetTeammateAbilityLevel(myHero, "bane_fiends_grip") * 55)
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_legion_commander_duel" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * 1.35
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_pudge_dismember" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 2 * (22 + AIO_Umbrella.GetTeammateAbilityLevel(myHero, "pudge_dismember") * 22)
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_crystal_maiden_frostbite" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 75
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_ember_spirit_searing_chains" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 85
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_eul_cyclone" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.05
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_obsidian_destroyer_astral_imprisonment_prison" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.15
					HPtreshold = sunStrikeDMG + (25 + AIO_Umbrella.GetTeammateAbilityLevel(myHero, "obsidian_destroyer_astral_imprisonment") * 75) * 0.75
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_shadow_demon_disruption" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.1
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_invoker_tornado" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.05
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_teleporting" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			else
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * (1 + Menu.GetValue(AIO_Umbrella.optionKillStealInvokerTreshold) / 100)
				else
					timing = 0
					HPtreshold = 0
				end
			end
		else
			timing = 0
			HPtreshold = 0
		end
	else
		timing = 0
		HPtreshold = 0
	end

	return { timing, HPtreshold }

end

function AIO_Umbrella.invokerSunstrikeKSParticleProcess(myHero)

	if not myHero then return false end
	if AIO_Umbrella.TPParticlePosition:__tostring() == Vector(0.0, 0.0, 0.0):__tostring() then return false end
	if NPC.GetMana(myHero) < 175 then return false end	

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	if not sunStrike or (sunStrike and not Ability.IsReady(sunStrike)) then return false end
	if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) and not Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then return false end
	
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local sunStrikeDMG = 37.5 + (62.5 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			sunStrikeDMG = 37.5 + (62.5 * (Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")) + 1))
		end

	if AIO_Umbrella.TPParticleTime > 0 and AIO_Umbrella.TPParticleUnit ~= nil then
		for hero, data in pairs(AIO_Umbrella.enemyHeroTable) do
			local heroHP = data[1]
			local heroHPreg = data[2]
			local timeStamp = data[3]
			if hero and NPC.IsDormant(hero) and hero == AIO_Umbrella.TPParticleUnit then
				if GameRules.GetGameTime() - timeStamp <= 10 then
					if heroHP + heroHPreg * (math.ceil(GameRules.GetGameTime() - timeStamp)) <= sunStrikeDMG and heroHP > 0 then
						return true
					end
				end
			end
		end
	end
	return false

end

function AIO_Umbrella.InvokerDrawShort(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvoker) then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerPanelShort) then return end
	if AIO_Umbrella.Toggler then return end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	local startX = w/2 + Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelShortXPos)
	local startY = h/2 + Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelShortYPos)

	local numberCombos = 1
	local maxSkills = 6

	local invokeTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher"
			}

	local imageHandleSnap = AIO_Umbrella.invokerCachedIcons["invoker_cold_snap"]
	local imageHandleSunStrike = AIO_Umbrella.invokerCachedIcons["invoker_sun_strike"]
	local imageHandleEmp = AIO_Umbrella.invokerCachedIcons["invoker_emp"]
	local imageHandleTornado = AIO_Umbrella.invokerCachedIcons["invoker_tornado"]
	local imageHandleAlacrity = AIO_Umbrella.invokerCachedIcons["invoker_alacrity"]
	local imageHandleBlast = AIO_Umbrella.invokerCachedIcons["invoker_deafening_blast"]
	local imageHandleMeteor = AIO_Umbrella.invokerCachedIcons["invoker_chaos_meteor"]
	local imageHandleIcewall = AIO_Umbrella.invokerCachedIcons["invoker_ice_wall"]
	local imageHandleSpirit = AIO_Umbrella.invokerCachedIcons["invoker_forge_spirit"]
	local imageHandleGhost = AIO_Umbrella.invokerCachedIcons["invoker_ghost_walk"]
	local imageHandleAgha = AIO_Umbrella.invokerCachedIcons["item_ultimate_scepter"]
	local imageHandleRefresher = AIO_Umbrella.invokerCachedIcons["item_refresher"]
	local imageHandleDagger = AIO_Umbrella.invokerCachedIcons["item_blink"]
	local imageHandleEul = AIO_Umbrella.invokerCachedIcons["item_cyclone"]
	local imageHandleAtos = AIO_Umbrella.invokerCachedIcons["item_rod_of_atos"]

	local skillTranslator = {
		imageHandleTornado,
		imageHandleEmp,
		imageHandleMeteor, 
		imageHandleBlast,
		imageHandleSunStrike,
		imageHandleIcewall,
		imageHandleSnap,
		imageHandleSpirit,
		imageHandleAlacrity,
		imageHandleEul,
		imageHandleAtos,
		imageHandleRefresher
			}

		-- custom mode 1
	if AIO_Umbrella.InvokerComboSelector == 12 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)], invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)], startX+2+25*0, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)], startX+2+25*1, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)], startX+2+25*2, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4)], startX+2+25*3, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill5) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill5)], startX+2+25*4, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill6) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill6)], startX+2+25*5, startY+2, 25, 25)
		end
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(AIO_Umbrella.font, startX-20, startY+1, "1", 0)
	end
		-- custom mode 2
	if AIO_Umbrella.InvokerComboSelector == 13 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)], invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)], startX+2+25*0, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)], startX+2+25*1, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)], startX+2+25*2, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4)], startX+2+25*3, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill5) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill5)], startX+2+25*4, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill6) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill6)], startX+2+25*5, startY+2, 25, 25)
		end
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(AIO_Umbrella.font, startX-20, startY+1, "2", 0)
	end
		-- custom mode 3
	if AIO_Umbrella.InvokerComboSelector == 14 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)], invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)], startX+2+25*0, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)], startX+2+25*1, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)], startX+2+25*2, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4)], startX+2+25*3, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill5) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill5)], startX+2+25*4, startY+2, 25, 25)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill6) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill6)], startX+2+25*5, startY+2, 25, 25)
		end
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(AIO_Umbrella.font, startX-20, startY+1, "3", 0)
	end

	if AIO_Umbrella.InvokerComboSelector == 11 then
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(AIO_Umbrella.font, startX+2+25*2, startY+1, "dyn", 0)
		Renderer.SetDrawColor(0, 0, 0, 100)
		Renderer.DrawFilledRect(startX, startY, (25 * maxSkills) + 4, (25 * numberCombos) + 4)
	end

end

function AIO_Umbrella.InvokerDraw(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroInvoker) then return end

	if AIO_Umbrella.invokerPanelNeedsInit then
        	AIO_Umbrella.invokerPanelInit()
        	AIO_Umbrella.invokerPanelNeedsInit = false
    	end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	local startX = w - 300 - Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelXPos)
	local startY = 300 + Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelYPos)

	local numberCombos = 11
	local maxSkills = 6

	local imageSize = AIO_Umbrella.invokerPanelBoxSize

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroInvokerToggleKey) then
		AIO_Umbrella.Toggler = not AIO_Umbrella.Toggler
	end

	if not AIO_Umbrella.Toggler then return end
		
	 -- black background
	Renderer.SetDrawColor(0, 0, 0, 150)
	Renderer.DrawFilledRect(startX, startY, (imageSize * maxSkills) + 4, ((imageSize+2) * numberCombos) + 12)
	Renderer.DrawFilledRect(startX, startY+(imageSize+2)*12+12, (imageSize * maxSkills) + 4, (imageSize+2)*3 + 4)

	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY, (imageSize * maxSkills) + 4, ((imageSize+2) * numberCombos) + 12)
	Renderer.DrawOutlineRect(startX, startY+(imageSize+2)*12+12, (imageSize * maxSkills) + 4, (imageSize+2)*3 + 4)

	local hoveringOverCombo1 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*0 + 0, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo2 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*1 + 1, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo3 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*2 + 2, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo4 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*3 + 3, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo5 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*4 + 4, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo6 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*5 + 5, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo7 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*6 + 6, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo8 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*7 + 7, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo9 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*8 + 8, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo10 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*9 + 9, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo11 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*10 + 10, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo12 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*12 + 12, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo13 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*13 + 13, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo14 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*14 + 14, (imageSize * maxSkills)+2 , (imageSize+2))

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	local emp = NPC.GetAbility(myHero, "invoker_emp")
	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
	local deafeningBlast = NPC.GetAbility(myHero, "invoker_deafening_blast")
	local chaosMeteor = NPC.GetAbility(myHero, "invoker_chaos_meteor")
	local coldSnap = NPC.GetAbility(myHero, "invoker_cold_snap")
	local forgeSpirit = NPC.GetAbility(myHero, "invoker_forge_spirit")
	local alacrity = NPC.GetAbility(myHero, "invoker_alacrity")
	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
	local euls = NPC.GetItem(myHero, "item_cyclone", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)

	local invokeTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher"
			}

	if hoveringOverCombo1 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 1 then
				AIO_Umbrella.PreInvokeSkills = {{coldSnap, forgeSpirit}}
				AIO_Umbrella.InvokerComboSelector = 1
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 1 then
				AIO_Umbrella.InvokerComboSelector = 1
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo2 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 2 then
				AIO_Umbrella.PreInvokeSkills = {{coldSnap, forgeSpirit}}
				AIO_Umbrella.InvokerComboSelector = 2
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 2 then
				AIO_Umbrella.InvokerComboSelector = 2
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo3 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 3 then
				AIO_Umbrella.PreInvokeSkills = {{emp, tornado}}
				AIO_Umbrella.InvokerComboSelector = 3
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 3 then
				AIO_Umbrella.InvokerComboSelector = 3
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo4 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 4 then
				AIO_Umbrella.PreInvokeSkills = {{chaosMeteor, tornado}}
				AIO_Umbrella.InvokerComboSelector = 4
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 4 then
				AIO_Umbrella.InvokerComboSelector = 4
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo5 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 5 then
				AIO_Umbrella.PreInvokeSkills = {{chaosMeteor, sunStrike}}
				AIO_Umbrella.InvokerComboSelector = 5
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 5 then
				AIO_Umbrella.InvokerComboSelector = 5
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo6 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 6 then
				AIO_Umbrella.PreInvokeSkills = {{emp, tornado}}
				AIO_Umbrella.InvokerComboSelector = 6
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 6 then
				AIO_Umbrella.InvokerComboSelector = 6
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo7 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 7 then
				AIO_Umbrella.PreInvokeSkills = {{sunStrike, tornado}}
				AIO_Umbrella.InvokerComboSelector = 7
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 7 then
				AIO_Umbrella.InvokerComboSelector = 7
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo8 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 8 then
				AIO_Umbrella.PreInvokeSkills = {{sunStrike, tornado}}
				AIO_Umbrella.InvokerComboSelector = 8
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 8 then
				AIO_Umbrella.InvokerComboSelector = 8
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo9 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 9 then
				AIO_Umbrella.PreInvokeSkills = {{emp, tornado}}
				AIO_Umbrella.InvokerComboSelector = 9
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 9 then
				AIO_Umbrella.InvokerComboSelector = 9
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo10 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 10 then
				AIO_Umbrella.PreInvokeSkills = {{deafeningBlast, chaosMeteor}}
				AIO_Umbrella.InvokerComboSelector = 10
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 10 then
				AIO_Umbrella.InvokerComboSelector = 10
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo11 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if AIO_Umbrella.InvokerComboSelector ~= 11 then
			AIO_Umbrella.InvokerComboSelector = 11
		else
			AIO_Umbrella.InvokerComboSelector = 0
		end
	elseif hoveringOverCombo12 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 12 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 0 then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) <= 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					else
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 12
					end
				else
					AIO_Umbrella.InvokerComboSelector = 0
				end	
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 12 then
				AIO_Umbrella.InvokerComboSelector = 12
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo13 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 13 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 0 then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) <= 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					else
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 13
					end
				else
					AIO_Umbrella.InvokerComboSelector = 0
				end	
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 13 then
				AIO_Umbrella.InvokerComboSelector = 13
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo14 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(AIO_Umbrella.optionHeroInvokerAutoInvoke) then
			if AIO_Umbrella.InvokerComboSelector ~= 14 then
				if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 0 then
					if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) <= 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) <= 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					elseif Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 9 then
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					else
						AIO_Umbrella.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)])}}
						AIO_Umbrella.InvokerComboSelector = 14
					end
				else
					AIO_Umbrella.InvokerComboSelector = 0
				end	
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		else
			if AIO_Umbrella.InvokerComboSelector ~= 14 then
				AIO_Umbrella.InvokerComboSelector = 14
			else
				AIO_Umbrella.InvokerComboSelector = 0
			end
		end
	end

	-- border
	if AIO_Umbrella.InvokerComboSelector == 1 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*0 + 0, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 2 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*1 + 1, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 3 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*2 + 2, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 4 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*3 + 3, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 5 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*4 + 4, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 6 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*5 + 5, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 7 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*6 + 6, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 8 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*7 + 7, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 9 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*8 + 8, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 10 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*9 + 9, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 11 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*10 + 10, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 12 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*12 + 12, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 13 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*13 + 13, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if AIO_Umbrella.InvokerComboSelector == 14 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*14 + 14, (imageSize * maxSkills)+2 , (imageSize+2))
	end

	local imageHandleSnap = AIO_Umbrella.invokerCachedIcons["invoker_cold_snap"]
	local imageHandleSunStrike = AIO_Umbrella.invokerCachedIcons["invoker_sun_strike"]
	local imageHandleEmp = AIO_Umbrella.invokerCachedIcons["invoker_emp"]
	local imageHandleTornado = AIO_Umbrella.invokerCachedIcons["invoker_tornado"]
	local imageHandleAlacrity = AIO_Umbrella.invokerCachedIcons["invoker_alacrity"]
	local imageHandleBlast = AIO_Umbrella.invokerCachedIcons["invoker_deafening_blast"]
	local imageHandleMeteor = AIO_Umbrella.invokerCachedIcons["invoker_chaos_meteor"]
	local imageHandleIcewall = AIO_Umbrella.invokerCachedIcons["invoker_ice_wall"]
	local imageHandleSpirit = AIO_Umbrella.invokerCachedIcons["invoker_forge_spirit"]
	local imageHandleGhost = AIO_Umbrella.invokerCachedIcons["invoker_ghost_walk"]
	local imageHandleAgha = AIO_Umbrella.invokerCachedIcons["item_ultimate_scepter"]
	local imageHandleRefresher = AIO_Umbrella.invokerCachedIcons["item_refresher"]
	local imageHandleDagger = AIO_Umbrella.invokerCachedIcons["item_blink"]
	local imageHandleEul = AIO_Umbrella.invokerCachedIcons["item_cyclone"]
	local imageHandleAtos = AIO_Umbrella.invokerCachedIcons["item_rod_of_atos"]

	

	-- combo CS, Forge, Alacrity
	if AIO_Umbrella.InvokerComboSelector == 1 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleSnap, startX+2+imageSize*0, startY+2, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(coldSnap) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*0+4, startY+2+4, math.floor(Ability.GetCooldownTimeLeft(coldSnap)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSpirit, startX+2+imageSize*1, startY+2, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(forgeSpirit) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1+4, startY+2+4, math.floor(Ability.GetCooldownTimeLeft(forgeSpirit)), 0)
			end
		end
	Renderer.DrawImage(imageHandleAlacrity, startX+2+imageSize*2, startY+2, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(alacrity) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+2+4, math.floor(Ability.GetCooldownTimeLeft(alacrity)), 0)
			end
		end

	-- combo CS, Forge, SS
	if AIO_Umbrella.InvokerComboSelector == 2 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleSnap, startX+2+imageSize*0, startY+3+(imageSize+2)*1, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(coldSnap) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*0+4, startY+3+(imageSize+2)*1+4, math.floor(Ability.GetCooldownTimeLeft(coldSnap)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSpirit, startX+2+imageSize*1, startY+3+(imageSize+2)*1, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(forgeSpirit) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1+4, startY+3+(imageSize+2)*1+4, math.floor(Ability.GetCooldownTimeLeft(forgeSpirit)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*2, startY+3+(imageSize+2)*1, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+3+(imageSize+2)*1+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end

	-- combo Tornado, EMP, Icewall
	if AIO_Umbrella.InvokerComboSelector == 3 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_emp", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*0, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*0+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleEmp, startX+2+imageSize*1, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(emp) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(emp)), 0)
			end
		end
	Renderer.DrawImage(imageHandleIcewall, startX+2+imageSize*2, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(iceWall) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(iceWall)), 0)
			end
		end
	Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+math.floor(imageSize/3)+imageSize*3, startY+4+(imageSize+2)*2+math.floor(imageSize/5), "or", 1)
	Renderer.DrawImage(imageHandleSnap, startX+2+imageSize*4, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(coldSnap) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*4+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(coldSnap)), 0)
			end
		end

	-- combo Tornado, Meteor, Blast
	if AIO_Umbrella.InvokerComboSelector == 4 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_chaos_meteor", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*0, startY+5+(imageSize+2)*3, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*0+4, startY+5+(imageSize+2)*3+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*1, startY+5+(imageSize+2)*3, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1+4, startY+5+(imageSize+2)*3+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*2, startY+5+(imageSize+2)*3, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+5+(imageSize+2)*3+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Eul, Sunstrike, Meteor, Blast
	if AIO_Umbrella.InvokerComboSelector == 5 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_chaos_meteor", "invoker_sun_strike") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleEul, startX+2+imageSize*0, startY+6+(imageSize+2)*4, imageSize, imageSize)
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*1, startY+6+(imageSize+2)*4, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1+4, startY+6+(imageSize+2)*4+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*2, startY+6+(imageSize+2)*4, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+6+(imageSize+2)*4+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*3, startY+6+(imageSize+2)*4, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*3+4, startY+6+(imageSize+2)*4+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, EMP, Meteor, Blast
	if AIO_Umbrella.InvokerComboSelector == 6 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_emp", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*0, startY+7+(imageSize+2)*5, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*1, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleEmp, startX+2+imageSize*2, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(emp) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(emp)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*3, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*3+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*4, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*4+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, Sunstrike, Meteor, Blast
	if AIO_Umbrella.InvokerComboSelector == 7 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_sun_strike", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*0, startY+8+(imageSize+2)*6, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*1, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*2, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*3, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*3+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*4, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*4+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, Sunstrike, Meteor, Blast, Refresher
	if AIO_Umbrella.InvokerComboSelector == 8 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_sun_strike", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleRefresher, startX+2+imageSize*0, startY+9+(imageSize+2)*7, imageSize, imageSize)
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*1, startY+9+(imageSize+2)*7, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*2, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*3, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*3+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*4, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*4+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*5, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*5+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, Sunstrike, Meteor, Blast, Refresher
	if AIO_Umbrella.InvokerComboSelector == 9 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_emp", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleRefresher, startX+2+imageSize*0, startY+10+(imageSize+2)*8, imageSize, imageSize)
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*1, startY+10+(imageSize+2)*8, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*2, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*2+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleEmp, startX+2+imageSize*3, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(emp) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*3+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(emp)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*4, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*4+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*5, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*5+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Dagger, Blast, Meteor, Sunstrike
	if AIO_Umbrella.InvokerComboSelector == 10 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, "invoker_deafening_blast", "invoker_chaos_meteor") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleRefresher, startX+2+imageSize*0, startY+11+(imageSize+2)*9, imageSize, imageSize)
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*1, startY+11+(imageSize+2)*9, imageSize, imageSize)
	Renderer.DrawImage(imageHandleDagger, startX+2+imageSize*2, startY+11+(imageSize+2)*9, imageSize, imageSize)
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*3, startY+11+(imageSize+2)*9, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*3+4, startY+11+(imageSize+2)*9+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*4, startY+11+(imageSize+2)*9, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*4+4, startY+11+(imageSize+2)*9+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*5, startY+11+(imageSize+2)*9, imageSize, imageSize)
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*5+4, startY+11+(imageSize+2)*9+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end

	-- dynamic mode
	if AIO_Umbrella.InvokerComboSelector == 11 then
		Renderer.SetDrawColor(0, 205, 0, 255)
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleBlast, startX+2+(imageSize/2)*0, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleMeteor, startX+2+(imageSize/2)*1, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleSunStrike, startX+2+(imageSize/2)*0, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleTornado, startX+2+(imageSize/2)*1, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleEmp, startX+2+(imageSize/2)*2, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleSnap, startX+2+(imageSize/2)*3, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleSpirit, startX+2+(imageSize/2)*2, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleAlacrity, startX+2+(imageSize/2)*3, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleIcewall, startX+2+(imageSize/2)*4, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleGhost, startX+2+(imageSize/2)*4, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))

	Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+(imageSize/2)*6, startY+12+(imageSize+2)*10+math.floor(imageSize/6), "dynamic", 1)


	-- custom mode
	local skillTranslator = {
		imageHandleTornado,
		imageHandleEmp,
		imageHandleMeteor, 
		imageHandleBlast,
		imageHandleSunStrike,
		imageHandleIcewall,
		imageHandleSnap,
		imageHandleSpirit,
		imageHandleAlacrity,
		imageHandleEul,
		imageHandleAtos,
		imageHandleRefresher
			}
		-- custom mode 1
	if AIO_Umbrella.InvokerComboSelector == 12 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)], invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)], startX+2+imageSize*0, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)], startX+2+imageSize*1, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)], startX+2+imageSize*2, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill4)], startX+2+imageSize*3, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill5) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill5)], startX+2+imageSize*4, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill6) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill6)], startX+2+imageSize*5, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
		-- custom mode 2
	if AIO_Umbrella.InvokerComboSelector == 13 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)], invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)], startX+2+imageSize*0, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)], startX+2+imageSize*1, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)], startX+2+imageSize*2, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill4)], startX+2+imageSize*3, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill5) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill5)], startX+2+imageSize*4, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill6) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill6)], startX+2+imageSize*5, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
		-- custom mode 3
	if AIO_Umbrella.InvokerComboSelector == 14 then
		if AIO_Umbrella.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)], invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)], startX+2+imageSize*0, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)], startX+2+imageSize*1, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)], startX+2+imageSize*2, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill4)], startX+2+imageSize*3, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill5) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill5)], startX+2+imageSize*4, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill6) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill6)], startX+2+imageSize*5, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
		-- custom combo text
	Renderer.SetDrawColor(255, 50, 0, 150)
	Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+2+imageSize*1, startY+11+math.floor(imageSize/3)+(imageSize+2)*11, "custom combo", 1)
	
	-- longest CDs
	if Menu.GetValue(AIO_Umbrella.optionHeroInvokerPanelCD) == 1 then
		Renderer.SetDrawColor(255, 0, 0, 150)
		if AIO_Umbrella.GetLongestCooldown(myHero, coldSnap, forgeSpirit, alacrity) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+2+(imageSize+2)*0+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, coldSnap, forgeSpirit, alacrity), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, coldSnap, forgeSpirit, sunStrike) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+3+(imageSize+2)*1+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, coldSnap, forgeSpirit, sunStrike), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, coldSnap, iceWall, tornado, emp) > 0 then
		Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+4+(imageSize+2)*2+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, coldSnap, iceWall, tornado, emp), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, tornado, chaosMeteor, deafeningBlast) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+5+(imageSize+2)*3+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, tornado, chaosMeteor, deafeningBlast), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, euls, sunStrike, chaosMeteor, deafeningBlast) > 0 then
		Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+6+(imageSize+2)*4+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, euls, sunStrike, chaosMeteor, deafeningBlast), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+7+(imageSize+2)*5+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+8+(imageSize+2)*6+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast, refresher) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+9+(imageSize+2)*7+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast, refresher), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast, refresher) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+10+(imageSize+2)*8+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast, refresher), 1)
		end
		if AIO_Umbrella.GetLongestCooldown(myHero, sunStrike, chaosMeteor, deafeningBlast, refresher) > 0 then
			Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+11+(imageSize+2)*9+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, sunStrike, chaosMeteor, deafeningBlast, refresher), 1)
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3) > 0 then
			if AIO_Umbrella.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)])) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+14+(imageSize+2)*12+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo1Skill3)])), 1)
			end
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3) > 0 then
			if AIO_Umbrella.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)])) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+15+(imageSize+2)*13+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo2Skill3)])), 1)
			end
		end
		if Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2) > 0 and Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3) > 0 then
			if AIO_Umbrella.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)])) > 0 then
				Renderer.DrawText(AIO_Umbrella.invokerPanelFont, startX+1-imageSize, startY+16+(imageSize+2)*14+math.floor(imageSize/9), AIO_Umbrella.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(AIO_Umbrella.optionHeroInvokerCombo3Skill3)])), 1)
			end
		end
	end

end

function AIO_Umbrella.invokerPanelInit()

	AIO_Umbrella.invokerPanelBoxSize = Menu.GetValue(AIO_Umbrella.invokerPanelSizeOption)

	AIO_Umbrella.invokerPanelFont = Renderer.LoadFont("Tahoma", math.floor(AIO_Umbrella.invokerPanelBoxSize * 0.6), Enum.FontWeight.BOLD)

	local iconsTempTable = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher",
		"item_blink",
		"item_ultimate_scepter",
		"invoker_ghost_walk"
			}

	for i = 1, #iconsTempTable do
		local imageHandle = AIO_Umbrella.invokerCachedIcons[iconsTempTable[i]]
		if imageHandle == nil then
			if iconsTempTable[i] ~= "item_cyclone" and iconsTempTable[i] ~= "item_rod_of_atos" and iconsTempTable[i] ~= "item_refresher" and iconsTempTable[i] ~= "item_blink" and iconsTempTable[i] ~= "item_ultimate_scepter" then
				imageHandle = Renderer.LoadImage("resource/flash3/images/spellicons/" .. iconsTempTable[i] .. ".png")	
				AIO_Umbrella.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			else
				imageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. string.gsub(iconsTempTable[i], "item_", "") .. ".png")
				AIO_Umbrella.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			end
		end
	end
	
end

function AIO_Umbrella.invokerDisplayInit()

	AIO_Umbrella.invokerDisplayBoxSize = Menu.GetValue(AIO_Umbrella.invokerDisplaySizeOption)
	AIO_Umbrella.invokerDisplayInnerBoxSize = AIO_Umbrella.invokerDisplayBoxSize - 2

	AIO_Umbrella.invokerDisplayFont = Renderer.LoadFont("Tahoma", math.floor(AIO_Umbrella.invokerDisplayInnerBoxSize * 0.643), Enum.FontWeight.BOLD)

	local iconsTempTable = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher",
		"item_blink",
		"item_ultimate_scepter",
		"invoker_ghost_walk"
			}

	for i = 1, #iconsTempTable do
		local imageHandle = AIO_Umbrella.invokerCachedIcons[iconsTempTable[i]]
		if imageHandle == nil then
			if iconsTempTable[i] ~= "item_cyclone" and iconsTempTable[i] ~= "item_rod_of_atos" and iconsTempTable[i] ~= "item_refresher" and iconsTempTable[i] ~= "item_blink" and iconsTempTable[i] ~= "item_ultimate_scepter" then
				imageHandle = Renderer.LoadImage("resource/flash3/images/spellicons/" .. iconsTempTable[i] .. ".png")	
				AIO_Umbrella.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			else
				imageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. string.gsub(iconsTempTable[i], "item_", "") .. ".png")
				AIO_Umbrella.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			end
		end
	end

end

function AIO_Umbrella.invokerDisplayDrawDisplay(myHero)

	if not Menu.IsEnabled(AIO_Umbrella.invokerDisplayOption) then return end

	if AIO_Umbrella.invokerDisplayNeedsInit then
        	AIO_Umbrella.invokerDisplayInit()
        	AIO_Umbrella.invokerDisplayNeedsInit = false
    	end

	local w, h = Renderer.GetScreenSize()
	x = math.floor(w/2);
	y = math.floor(h/5*3);
	y = y+Menu.GetValue(AIO_Umbrella.invokerDisplayY)
	x = x+Menu.GetValue(AIO_Umbrella.invokerDisplayX)

	local abilities = {}

	for i = 3, 15 do
        	local ability = NPC.GetAbilityByIndex(myHero, i)
		local name = Ability.GetName(ability)
        	if ability ~= nil and Entity.IsAbility(ability) and not Ability.IsAttributes(ability) and name~="invoker_invoke" and name ~= "invoker_empty1" and name~= "invoker_empty2"then
            		if Ability.GetCooldownTimeLeft(ability)==0 then
               			table.insert(abilities, 1, ability)
            		else 
                		table.insert(abilities, #abilities+1, ability)
            		end 
        	end
    	end

    	if Menu.IsEnabled(AIO_Umbrella.invokerDisplaySortAbilitiesOption) then
        	table.sort(abilities, function(a, b) return Ability.GetName(a) < Ability.GetName(b) end)
    	end

    	local startX = x - math.floor(((#abilities) / 2) * AIO_Umbrella.invokerDisplayBoxSize)

    	Renderer.SetDrawColor(0, 0, 0, 150)
    	Renderer.DrawFilledRect(startX + 1, y - 1, (AIO_Umbrella.invokerDisplayBoxSize * #abilities) + 2, AIO_Umbrella.invokerDisplayBoxSize + 2)

   	for i, ability in ipairs(abilities) do
        	AIO_Umbrella.invokerDisplayDrawAbilitySquare(myHero, ability, startX, y, i - 1)
    	end


    	Renderer.SetDrawColor(0, 0, 0, 255)
    	Renderer.DrawOutlineRect(startX + 1, y - 1, (AIO_Umbrella.invokerDisplayBoxSize * #abilities) + 2, AIO_Umbrella.invokerDisplayBoxSize + 2)

end

function AIO_Umbrella.invokerDisplayDrawAbilitySquare(myHero, ability, x, y, index)

    	local abilityName = Ability.GetName(ability)
    	local imageHandle = AIO_Umbrella.invokerCachedIcons[abilityName]
		if imageHandle == nil then
			AIO_Umbrella.invokerPanelInit()
		end
			

    	local realX = x + (index * AIO_Umbrella.invokerDisplayBoxSize) + 2

    	local castable = Ability.IsCastable(ability, NPC.GetMana(myHero), true)

    	local imageColor = { 255, 255, 255 }
    	local outlineColor = { 0, 255 , 0 }

    	if not castable then
        	if Ability.GetLevel(ability) == 0 then
            		imageColor = { 125, 125, 125 }
            		outlineColor = { 255, 0, 0 }
        	elseif Ability.GetManaCost(ability) > NPC.GetMana(myHero) then
            		imageColor = { 150, 150, 255 }
            		outlineColor = { 0, 0, 255 }
        	else
            		imageColor = { 255, 150, 150 }
            		outlineColor = { 255, 0, 0 }
        	end
    	end

    	local hoveringOver = Input.IsCursorInRect(realX, y, AIO_Umbrella.invokerDisplayBoxSize, AIO_Umbrella.invokerDisplayBoxSize)

    	local boxSize = AIO_Umbrella.invokerDisplayBoxSize

    	if hoveringOver then
        	boxSize = math.floor(boxSize * 1.25)
    	end

    	Renderer.SetDrawColor(imageColor[1], imageColor[2], imageColor[3], 255)
    	Renderer.DrawImage(imageHandle, realX, y, AIO_Umbrella.invokerDisplayBoxSize, AIO_Umbrella.invokerDisplayBoxSize)

    	Renderer.SetDrawColor(outlineColor[1], outlineColor[2], outlineColor[3], 255)
    	Renderer.DrawOutlineRect(realX, y, AIO_Umbrella.invokerDisplayBoxSize, AIO_Umbrella.invokerDisplayBoxSize)

    	local cdLength = Ability.GetCooldownLength(ability)

    	if not Ability.IsReady(ability) and cdLength > 0.0 then
        	local cooldownRatio = Ability.GetCooldown(ability) / cdLength
        	local cooldownSize = math.floor(AIO_Umbrella.invokerDisplayBoxSize * cooldownRatio)

        	Renderer.SetDrawColor(255, 255, 255, 50)
        	Renderer.DrawFilledRect(realX + 1, y + (AIO_Umbrella.invokerDisplayInnerBoxSize - cooldownSize) + 1, AIO_Umbrella.invokerDisplayInnerBoxSize, cooldownSize)

        	Renderer.SetDrawColor(255, 255, 255)
        	Renderer.DrawText(AIO_Umbrella.invokerDisplayFont, realX + 1, y, math.floor(Ability.GetCooldown(ability)), 0)
    	elseif hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
        	AIO_Umbrella.invokerInvokeAbility(myHero, ability)
    	end

end
				
-- killsteal functions
function AIO_Umbrella.AutoNukeKillSteal(myHero)

	if not myHero then return end
	local myMana = NPC.GetMana(myHero)

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	for _, stealEnemyEntity in ipairs(NPC.GetHeroesInRadius(myHero, 2000, Enum.TeamType.TEAM_ENEMY)) do
		if not stealEnemyEntity then return end

	local stealEnemy = AIO_Umbrella.targetChecker(stealEnemyEntity)
		if not stealEnemy then return end
		if NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return end

		for n, v in ipairs(AIO_Umbrella.AbilityList) do
			local heroName = v[1]
	      		local skillName = v[2]
			local skillType = v[3]
			local targetMode = v[4]
			local specialAttribute = v[5]
		
			if AIO_Umbrella.myUnitName == heroName then
				if skillType == "nuke" and NPC.GetAbility(myHero, skillName) ~= nil and not Ability.IsUltimate(NPC.GetAbility(myHero, skillName)) and Ability.IsCastable(NPC.GetAbility(myHero, skillName), myMana) then
					if Entity.GetHealth(stealEnemy) > 0 and not NPC.HasModifier(stealEnemy, "modifier_templar_assassin_refraction_absorb") then
						if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetCastRange(NPC.GetAbility(myHero, skillName))) or skillName == "rattletrap_rocket_flare" then
							local skillDamage = Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0)
							if skillDamage < 1 then
								if skillName == "skywrath_mage_arcane_bolt" then
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute) + (1.6 * Hero.GetIntellectTotal(myHero))
								else
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
								end
							end
							if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
								if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				
									if targetMode == "target" and not NPC.IsLinkensProtected(stealEnemy) then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), stealEnemy)
										break
										return
									end
									if targetMode == "position" then
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(stealEnemy))
										break
										return
									end
									if targetMode == "no target" then
										Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
										break
										return
									end
									if targetMode == "skillshot" then
										if skillName == "windrunner_powershot" then
											local powershotPrediction = 1 + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 3000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castLinearPrediction(myHero, stealEnemy, powershotPrediction))
											break
											return
										end
										if skillName == "death_prophet_carrion_swarm" then
											local carrionPrediction = 0.5 + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castLinearPrediction(myHero, stealEnemy, carrionPrediction))
											break
											return
										end
										if skillName == "kunkka_torrent" then
											local kunkkaPrediction = 2 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castPrediction(myHero, stealEnemy, kunkkaPrediction))
											break
											return
										end
										if skillName == "lina_dragon_slave" then
											local dragonSlavePrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1200) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castLinearPrediction(myHero, stealEnemy, dragonSlavePrediction))
											break
											return
										end
										if skillName == "magnataur_shockwave" then
											local shockwavePrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1050) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castLinearPrediction(myHero, stealEnemy, shockwavePrediction))
											break
											return
										end
										if skillName == "pugna_nether_blast" then
											local blastPrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + 0.9 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castPrediction(myHero, stealEnemy, blastPrediction))
											break
											return
										end
										if skillName == "rattletrap_rocket_flare" then
											local flairPrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1750) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castLinearPrediction(myHero, stealEnemy, flairPrediction))
											break
											return
										end
										if skillName == "tusk_ice_shards" then
											local shardsPrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castLinearPrediction(myHero, stealEnemy, shardsPrediction))
											break
											return
										end
										if skillName == "vengefulspirit_wave_of_terror" then
											local wavePrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), AIO_Umbrella.castLinearPrediction(myHero, stealEnemy, wavePrediction))
											break
											return
										end
									end
								end
							end	
						end
						if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetCastRange(NPC.GetAbility(myHero, skillName))) and targetMode == "special" then
							if skillName == "nyx_assassin_mana_burn" then
								local skillDamage = Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, skillName), "float_multiplier") * Hero.GetIntellectTotal(stealEnemy) * (1 + Hero.GetIntellectTotal(myHero) / 14 / 100)
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) and NPC.GetMana(stealEnemy) >= Entity.GetHealth(stealEnemy) then
									if NPC.GetAbility(myHero, skillName) and not NPC.IsLinkensProtected(stealEnemy) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), stealEnemy)
										break
										return
									end
								end
							end
						end
						if skillName == "queenofpain_scream_of_pain" then
							if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "area_of_effect")) and targetMode == "special" then
								if Entity.GetHealth(stealEnemy) <= (1 - NPC.GetMagicalArmorValue(stealEnemy))*Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0) + (Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0) * (Hero.GetIntellectTotal(myHero) / 14 / 100)) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
										break
										return
									end
								end
							end
						end
						if skillName == "nevermore_shadowraze1" and targetMode == "special" then
							local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(200)
							local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
							local predictedPos = AIO_Umbrella.castPrediction(myHero, stealEnemy, razePrediction)
							local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
							if disRazePOSpredictedPOS <= 200 and not Entity.IsTurning(myHero) then
								local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "shadowraze_damage")
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										if os.clock() - AIO_Umbrella.lastCastTime2 >= 0.55 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											AIO_Umbrella.lastCastTime2 = os.clock()
											break
											return
										end
									end
								end
							end
						end
						if skillName == "nevermore_shadowraze2" and targetMode == "special" then
							local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(450)
							local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
							local predictedPos = AIO_Umbrella.castPrediction(myHero, stealEnemy, razePrediction)
							local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
							if disRazePOSpredictedPOS <= 200 and not Entity.IsTurning(myHero) then
								local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "shadowraze_damage")
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										if os.clock() - AIO_Umbrella.lastCastTime2 >= 0.55 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											AIO_Umbrella.lastCastTime2 = os.clock()
											break
											return
										end
									end
								end
							end
						end
						if skillName == "nevermore_shadowraze3" and targetMode == "special" then
							local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(700)
							local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
							local predictedPos = AIO_Umbrella.castPrediction(myHero, stealEnemy, razePrediction)
							local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
							if disRazePOSpredictedPOS <= 200 and not Entity.IsTurning(myHero) then
								local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "shadowraze_damage")
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										if os.clock() - AIO_Umbrella.lastCastTime2 >= 0.55 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											AIO_Umbrella.lastCastTime2 = os.clock()
											break
											return
										end
									end
								end
							end
						end
						if skillName == "skywrath_mage_concussive_shot" and targetMode == "special" then
							local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
							if NPC.IsEntityInRange(myHero, stealEnemy, 1600, 0) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									local enemyDis = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(stealEnemy)):Length2D()
									local aghanimsBuffed = false
										if NPC.HasItem(myHero, "item_ultimate_scepter", true) or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
											aghanimsBuffed = true
										end
									if not aghanimsBuffed then
										if #Entity.GetHeroesInRadius(myHero, enemyDis, Enum.TeamType.TEAM_ENEMY) <= 1 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											break
											return
										end
									else
										if #Entity.GetHeroesInRadius(myHero, enemyDis, Enum.TeamType.TEAM_ENEMY) <= 2 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											break
											return
										end
									end
								end
							end
						end
						if skillName == "pangolier_swashbuckle" and targetMode == "special" and not NPC.HasModifier(myHero, "modifier_pangolier_gyroshell") then
							local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
								if NPC.HasAbility(myHero, "special_bonus_unique_pangolier_3") then
									if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pangolier_3")) > 0 then
										skillDamage = skillDamage + 30
									end
								end
							local trueSkillDamage = NPC.GetDamageMultiplierVersus(myHero, stealEnemy) * (skillDamage * NPC.GetArmorDamageMultiplier(stealEnemy)) * 4
							local castRange = 1000
							local slashRange = 900
							if NPC.IsEntityInRange(myHero, stealEnemy, castRange + slashRange, 0) then
								if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) <= trueSkillDamage then
									if NPC.IsEntityInRange(myHero, stealEnemy, castRange, 0) then
										local swashPrediction = 0.2 + ((Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() - 100) / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
										local pos = AIO_Umbrella.castPrediction(myHero, stealEnemy, swashPrediction) + (Entity.GetAbsOrigin(myHero) - AIO_Umbrella.castPrediction(myHero, stealEnemy, swashPrediction)):Normalized():Scaled(100)
									    	Player.PrepareUnitOrders(Players.GetLocal(), 30, nil, pos, NPC.GetAbility(myHero, skillName), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, myHero)
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(myHero), true)
										break
										return
									else
										local swashPrediction = 0.2 + ((Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() - 100) / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
										local pos = Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.castPrediction(myHero, stealEnemy, swashPrediction) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(999)
									    	Player.PrepareUnitOrders(Players.GetLocal(), 30, nil, pos, NPC.GetAbility(myHero, skillName), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, myHero)
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(myHero), true)
										break
										return
									end
								end
							end
						end
						if skillName == "winter_wyvern_splinter_blast" and targetMode == "special" then	
							local skillDamage = Ability.GetDamage(NPC.GetAbility(myHero, skillName))
							local skillTrueDamage = ((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
							if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) < skillTrueDamage then
								if NPC.IsEntityInRange(myHero, stealEnemy, 1600, 0) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
									local target
									for _, possibleTargets in ipairs(Heroes.InRadius(Entity.GetAbsOrigin(stealEnemy), 499, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)) do
										if possibleTargets and possibleTargets ~= stealEnemy and Entity.IsHero(possibleTargets) and Entity.IsAlive(possibleTargets) and not NPC.HasState(possibleTargets, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(possibleTargets) then
											if NPC.IsEntityInRange(myHero, possibleTargets, 1199) then
												target = possibleTargets
												break
											end
										end
									end
									if target ~= nil then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), target)
										break
										return
									end
								end
							end
						end
					end
				end
				if skillType == "pure" and NPC.GetAbility(myHero, skillName) ~= nil and not Ability.IsUltimate(NPC.GetAbility(myHero, skillName)) and Ability.IsCastable(NPC.GetAbility(myHero, skillName), myMana) then
					if Entity.GetHealth(stealEnemy) > 0 then
						if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetCastRange(NPC.GetAbility(myHero, skillName))) then
							local skillDamage = Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0)
							if  skillDamage < 1 then
								if skillName == "skywrath_mage_arcane_bolt" then
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute) + (1.6 * Hero.GetIntellectTotal(myHero))
								else
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
								end
							end
							if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) <= skillDamage then
								if NPC.GetAbility(myHero, skillName) and Ability.IsCastable(NPC.GetAbility(myHero, skillName), myMana) then
									if targetMode == "target" and not NPC.IsLinkensProtected(stealEnemy) then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), stealEnemy)
										break
										return
									end
									if targetMode == "position" then
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(stealEnemy))
										break
										return
									end
									if targetMode == "no target" then
										Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
										break
										return
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function AIO_Umbrella.AutoSunstrikeKillStealNew(myHero)

	if not myHero then return end
	if os.clock() - AIO_Umbrella.invokerChannellingKillstealTimer <= 3 then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 
	if AIO_Umbrella.IsHeroInvisible(myHero) == true then return end

	if Menu.IsKeyDownOnce(AIO_Umbrella.optionComboKey) then return end
	if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) then return end

	local myMana = NPC.GetMana(myHero)

	local exort = NPC.GetAbility(myHero, "invoker_exort")
	local invoke = NPC.GetAbility(myHero, "invoker_invoke")
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	local sunStrikeDMG = 37.5 + (62.5 * Ability.GetLevel(exort))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			sunStrikeDMG = 37.5 + (62.5 * (Ability.GetLevel(exort) + 1))
		end
	
	if not sunStrike then return end
	if not Ability.IsReady(sunStrike) then return end
	if not Ability.IsCastable(sunStrike, myMana) then return end

	if Menu.IsEnabled(AIO_Umbrella.optionKillStealInvokerTPpartice) then
		if AIO_Umbrella.invokerSunstrikeKSParticleProcess(myHero) == true then
			if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
				if Menu.IsEnabled(AIO_Umbrella.optionKillStealAutoInvoke) then
					if invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
						AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
						Ability.CastPosition(sunStrike, AIO_Umbrella.TPParticlePosition, true)
						AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
						return
					end
				else
					return
				end
			else
				Ability.CastPosition(sunStrike, AIO_Umbrella.TPParticlePosition)
				AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionKillStealInvokerImmobil) then
		for _, immobilizedEntity in ipairs(NPC.GetHeroesInRadius(myHero, 99999, Enum.TeamType.TEAM_ENEMY)) do
			if immobilizedEntity then
				local immobilizedEnemy = AIO_Umbrella.targetChecker(immobilizedEntity)
				if immobilizedEnemy and Entity.IsAlive(immobilizedEnemy) and not NPC.HasModifier(immobilizedEnemy, "modifier_templar_assassin_refraction_absorb") then
					local enemyProcessing = AIO_Umbrella.invokerSunstrikeKSdisabledTargetProcess(myHero, immobilizedEnemy)
					if next(enemyProcessing) ~= nil then
						if enemyProcessing[1] > 0 and enemyProcessing[2] > 0 then
							local timing = enemyProcessing[1]
							local HPthreshold = enemyProcessing[2]
							if Entity.GetHealth(immobilizedEnemy) < HPthreshold then
								if GameRules.GetGameTime() >= timing then
									if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
										if Menu.IsEnabled(AIO_Umbrella.optionKillStealAutoInvoke) then
											if invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
												AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
												Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(immobilizedEnemy), true)
												AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
												return
											end
										else
											return
										end
									else
										Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(immobilizedEnemy))
										AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
										return
									end
								end
							end
						end
					end
				end
			end
		end
	end

	if AIO_Umbrella.InvokerKSparticleProcess[1][5]:__tostring() ~= Vector():__tostring() then
		local processData = table.remove(AIO_Umbrella.InvokerKSparticleProcess, 1)
		AIO_Umbrella.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
		local name = processData[2]
		local time = processData[3]
		local pos = processData[5]

		for _, v in ipairs(Heroes.InRadius(pos, 175, Entity.GetTeamNum(myHero), Enum.UnitType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not NPC.IsIllusion(v) and Entity.IsAlive(v) and not not NPC.HasModifier(v, "modifier_templar_assassin_refraction_absorb") then
				if Entity.GetHealth(v) < sunStrikeDMG * (1 + Menu.GetValue(AIO_Umbrella.optionKillStealInvokerTreshold) / 100) then
					local duration
					if name == "rattletrap_cog_deploy" then
						duration = 2 + AIO_Umbrella.GetTeammateAbilityLevel(myHero, "rattletrap_cog")
					elseif name == "furion_sprout" then
						duration = 2 + AIO_Umbrella.GetTeammateAbilityLevel(myHero, "furion_sprout")
					end
					if GameRules.GetGameTime() + 1.5 < time + duration then
						if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
							if Menu.IsEnabled(AIO_Umbrella.optionKillStealAutoInvoke) then
								if invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
									AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
									Ability.CastPosition(sunStrike, pos, true)
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									return
								end
							else
								return
							end
						else
							Ability.CastPosition(sunStrike, pos)
							AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
							return
						end
					end
				end
			end
		end
	end		
	
	if AIO_Umbrella.GlimpseParticleTime > 0 and AIO_Umbrella.GlimpseParticleUnit ~= nil and AIO_Umbrella.GlimpseParticlePosition ~= Vector() and AIO_Umbrella.GlimpseParticlePositionStart ~= Vector() then
		if not NPC.IsIllusion(AIO_Umbrella.GlimpseParticleUnit) and Entity.IsAlive(AIO_Umbrella.GlimpseParticleUnit) and not NPC.HasModifier(AIO_Umbrella.GlimpseParticleUnit, "modifier_templar_assassin_refraction_absorb") then
			if Entity.GetHealth(AIO_Umbrella.GlimpseParticleUnit) < sunStrikeDMG - 25 then
				local glimpseTiming
					if (AIO_Umbrella.GlimpseParticlePositionStart - AIO_Umbrella.GlimpseParticlePosition):Length2D() / 600 >= 1.8 then
						glimpseTiming = 1.8
					else
						glimpseTiming = (AIO_Umbrella.GlimpseParticlePositionStart - AIO_Umbrella.GlimpseParticlePosition):Length2D() / 600
					end
				if glimpseTiming > 1.5 then
					if GameRules.GetGameTime() >= AIO_Umbrella.GlimpseParticleTime + glimpseTiming - 1.65 then
						if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
							if Menu.IsEnabled(AIO_Umbrella.optionKillStealAutoInvoke) then
								if invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
									AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
									Ability.CastPosition(sunStrike, AIO_Umbrella.GlimpseParticlePosition, true)
									AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
									AIO_Umbrella.GlimpseParticleUnit = nil
									return
								end
							else
								return
							end
						else
							Ability.CastPosition(sunStrike, AIO_Umbrella.GlimpseParticlePosition)
							AIO_Umbrella.invokerChannellingKillstealTimer = os.clock()
							AIO_Umbrella.GlimpseParticleUnit = nil
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionKillStealInvokerRunning) then
		for _, stealEnemyEntity in ipairs(NPC.GetHeroesInRadius(myHero, 99999, Enum.TeamType.TEAM_ENEMY)) do
			local sunStrikeEnemy = AIO_Umbrella.targetChecker(stealEnemyEntity)
			if sunStrikeEnemy and Entity.IsAlive(sunStrikeEnemy) and not NPC.HasModifier(sunStrikeEnemy, "modifier_templar_assassin_refraction_absorb") then
				local bestTarget
				local maxAgi = 0
				if Entity.GetHealth(sunStrikeEnemy) <= sunStrikeDMG and Hero.GetAgilityTotal(sunStrikeEnemy) > maxAgi then
					bestTarget = sunStrikeEnemy
					maxAgi = Hero.GetAgilityTotal(sunStrikeEnemy)
				end
				if Entity.GetHealth(sunStrikeEnemy) > sunStrikeDMG or Entity.GetHealth(sunStrikeEnemy) < 1  then
					bestTarget = nil
					maxAgi = 0
				end
				if bestTarget then
					if not NPC.IsRunning(bestTarget) then
						return
					else
						if AIO_Umbrella.isEnemyTurning(bestTarget) == false then
							if Ability.IsReady(sunStrike) and Ability.IsCastable(sunStrike, myMana) then
								if not AIO_Umbrella.InvokerIsAbilityInvoked(myHero, sunStrike) then
									if Menu.IsEnabled(AIO_Umbrella.optionKillStealAutoInvoke) then
										if invoke and Ability.IsCastable(invoke, myMana) and AIO_Umbrella.InvokerIsSkillInvokable(myHero, sunStrike) then
											AIO_Umbrella.invokerInvokeAbility(myHero, sunStrike)
											Ability.CastPosition(sunStrike, AIO_Umbrella.castPrediction(myHero, bestTarget, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)), true)
											return
										end
									else
										return
									end
								else
									Ability.CastPosition(sunStrike, AIO_Umbrella.castPrediction(myHero, bestTarget, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)))
									return
								end
							end
						end
					end
				end
			end
		end
	end
end

function AIO_Umbrella.TinkerCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroTinker) then return end

  	local laser = NPC.GetAbilityByIndex(myHero, 0)
 	local missile = NPC.GetAbilityByIndex(myHero, 1)
 	local march = NPC.GetAbilityByIndex(myHero, 2)
 	local rearm = NPC.GetAbility(myHero, "tinker_rearm")

	local lens = NPC.GetItem(myHero, "item_aether_lens", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero) - 75

	local travels = NPC.GetItem(myHero, "item_travel_boots", true) or NPC.GetItem(myHero, "item_travel_boots_2", true)

	AIO_Umbrella.itemUsage(myHero, enemy)
	AIO_Umbrella.TinkerPanicBlink(myHero, blink, rearm)

	if enemy and NPC.IsEntityInRange(myHero, enemy, 2400) then
		if Menu.IsKeyDown(AIO_Umbrella.optionComboKey) and Entity.IsAlive(enemy) then
			AIO_Umbrella.TinkerStatus = 1
			AIO_Umbrella.TinkerFullCombo(myHero, enemy, myMana, laser, missile, march, rearm, blink)
		else
			if AIO_Umbrella.TinkerStatus == 1 then
				AIO_Umbrella.TinkerStatus = 0
			end
		end
	end

	if Menu.GetValue(AIO_Umbrella.optionHeroTinkerPushMode) == 1 then
		if Menu.IsKeyDown(AIO_Umbrella.optionHeroTinkerPushKey) then
			AIO_Umbrella.TinkerStatus = 2
 			AIO_Umbrella.TinkerPush(myHero, myMana, march, rearm, blink, travels)
		else
			if AIO_Umbrella.TinkerStatus == 2 then
				AIO_Umbrella.TinkerStatus = 0
			end
		end
	else
		if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroTinkerPushKey) then
			AIO_Umbrella.TinkerPusher = not AIO_Umbrella.TinkerPusher
		end
	end

	if Menu.GetValue(AIO_Umbrella.optionHeroTinkerPushMode) < 1 then
		if AIO_Umbrella.TinkerPusher then
			AIO_Umbrella.TinkerStatus = 2
			AIO_Umbrella.TinkerPush(myHero, myMana, march, rearm, blink, travels)
		else
			if AIO_Umbrella.TinkerStatus == 2 then
				AIO_Umbrella.TinkerStatus = 0
			end
		end
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerRocket) then
		if Menu.IsKeyDown(AIO_Umbrella.optionHeroTinkerRocketKey) then
			AIO_Umbrella.TinkerStatus = 3	
			AIO_Umbrella.TinkerRocketSpam(myHero, myMana, missile, rearm, blink)
		else
			if AIO_Umbrella.TinkerStatus == 3 then
				AIO_Umbrella.TinkerStatus = 0
			end
		end
	end	

end

function AIO_Umbrella.TinkerPanicBlink(myHero, blink, rearm)

	if not myHero then return end
	if not blink then return end
	if not rearm then return end

	if AIO_Umbrella.TinkerPanicRearmBlink < 1 then return end
	if os.clock() - AIO_Umbrella.TinkerPanicRearmBlink > Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING) then return end
	
	if Ability.IsChannelling(rearm) then return end

	local blinkPos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(1150)
	Ability.CastPosition(blink, blinkPos)

	return

end

function AIO_Umbrella.TinkerFullCombo(myHero, enemy, myMana, laser, missile, march, rearm, blink)

	if not myHero then return end
	if not enemy then return end
	if NPC.IsChannellingAbility(myHero) then return end
	
	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then

		if not NPC.IsEntityInRange(myHero, enemy, 900) then
			if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(AIO_Umbrella.optionHeroTinkerBlinkRange)) then
				Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(AIO_Umbrella.optionHeroTinkerBlinkRange))))
				AIO_Umbrella.lastTick = os.clock() + 0.15
				return
			end
		end	

		if os.clock() > AIO_Umbrella.lastTick then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				if missile and Ability.IsCastable(missile, myMana) then
					Ability.CastNoTarget(missile)
					AIO_Umbrella.lastTick = os.clock() + 0.15
					return
				end
				
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(laser)) then
					if laser and Ability.IsCastable(laser, myMana) then
						Ability.CastTarget(laser, enemy)
						AIO_Umbrella.lastTick = os.clock() + 0.4
						return
					end
				end
			end
			if AIO_Umbrella.TinkerCheckForFullDMGRearm(myHero, myMana, rearm) then
				if rearm and Ability.IsCastable(rearm, myMana) then
					Ability.CastNoTarget(rearm)
					AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.53 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end
		end
	end
				
	AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end

function AIO_Umbrella.TinkerCheckForFullDMGRearm(myHero, myMana, rearm)

	if not myHero then return false end
	if not rearm then return false end

	local rearmMana = Ability.GetManaCost(rearm)

	local laser = NPC.GetAbilityByIndex(myHero, 0)
 	local missile = NPC.GetAbilityByIndex(myHero, 1)
	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local shivas = NPC.GetItem(myHero, "item_shivas_guard", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end
	
	if (laser and Ability.GetLevel(laser) < 1) or (missile and Ability.GetLevel(missile) < 1) then return false end

	local neededMana = 0
		if laser and Ability.GetLevel(laser) > 0 then
			neededMana = neededMana + Ability.GetManaCost(laser)
		end
		if missile and Ability.GetLevel(missile) > 0 then
			neededMana = neededMana + Ability.GetManaCost(missile)
		end
		if soulRing and Menu.IsEnabled(AIO_Umbrella.optionItemSoulring) then
			neededMana = neededMana - 150
		end
		
		if neededMana + rearmMana > myMana then return false end

	if laser and Ability.IsReady(laser) then return false end
	if missile and Ability.IsReady(missile) then return false end

	if Menu.GetValue(AIO_Umbrella.optionItemeBlade) > 0 and eBlade and Ability.IsReady(eBlade) then return false end
	if Menu.GetValue(AIO_Umbrella.optionItemShivas) > 0 and shivas and Ability.IsReady(shivas) then return false end
	if Menu.GetValue(AIO_Umbrella.optionItemDagon) > 0 and dagon and Ability.IsReady(dagon) then return false end

	return true

end

function AIO_Umbrella.TinkerRocketSpam(myHero, myMana, missile, rearm, blink)

	if not myHero then return end
	if NPC.IsChannellingAbility(myHero) then return end

	local mousePos = Input.GetWorldCursorPos()
	local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)

	if not missile then return end
		if Ability.GetLevel(missile) < 1 then return end

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 

	local harassTarget = nil
		for _, hero in ipairs(Entity.GetHeroesInRadius(myHero, 2350, Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
				if Entity.IsAlive(hero) and not NPC.HasState(hero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
        				harassTarget = hero
					break
				end
      			end			
		end

	if os.clock() < AIO_Umbrella.lastTick then return end

	if harassTarget ~= nil then

		if soulRing and Ability.IsReady(soulRing) then
			Ability.CastNoTarget(soulRing)
			AIO_Umbrella.lastTick = os.clock() + 0.05
			return	
		end

		if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerMiscGlimmer) then
			if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > AIO_Umbrella.TinkerGlimmerCastTime then
				Ability.CastTarget(glimmer, myHero)
				AIO_Umbrella.lastTick = os.clock() + 0.05
				AIO_Umbrella.TinkerGlimmerCastTime = os.clock() + 5
				return
			end
		end

		local bottle = NPC.GetItem(myHero, "item_bottle", true)
		if bottle then
			if Item.GetCurrentCharges(bottle) > 0 then	
				if not NPC.HasModifier(myHero, "modifier_bottle_regeneration") then
					local hpGap = Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)
					local manaGap = NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)
					if hpGap > 0.8 or manaGap > 0.8 then
						Ability.CastNoTarget(bottle)
						AIO_Umbrella.lastTick = os.clock() + 0.05
						return
					end
				end
			end
		end
	
		if missile and Ability.IsCastable(missile, myMana) then
			Ability.CastNoTarget(missile)
			AIO_Umbrella.lastTick = os.clock() + 0.05
			return
		end

		if rearm and Ability.IsCastable(rearm, myMana) then
			if myMana > Ability.GetManaCost(missile) + Ability.GetManaCost(rearm) then
				Ability.CastNoTarget(rearm)
				AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.53 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING)
				return
			end
		end

	else
		if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
			if not Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerRocketBlink) then
				if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerRocketMove) then
					AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
					return
				end
			else
				if not NPC.IsPositionInRange(myHero, mousePos, Menu.GetValue(AIO_Umbrella.optionHeroTinkerRocketBlinkMin), 0) then
					if blink and Ability.IsReady(blink) then
						if NPC.IsPositionInRange(myHero, mousePos, 1180, 0) then
							Ability.CastPosition(blink, mousePos)
							return
						else
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(myHero) + (mousePos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1180)))
							return
						end
					else
						AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
						return
					end
				else
					AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
					return
				end
			end
		end
	end

	return	

end

function AIO_Umbrella.TinkerAmIAtFountain(myHero)

	if not myHero then return false end

	local myFountainPos = AIO_Umbrella.GetMyFountainPos(myHero)
	local myPos = Entity.GetAbsOrigin(myHero)

	local dist = (myFountainPos - myPos):Length2D()

	if dist < 1600 then
		return true
	end

	return false
	
end

function AIO_Umbrella.TinkerIsFarmTupleAlive(myHero, camp1, camp2)

	if not myHero then return false end
	if next(AIO_Umbrella.JungleTrackTable) == nil then return false end

	local check = false
	local checkPos = false
	for _, info in ipairs(AIO_Umbrella.JungleTrackTable) do
		if info then
			local pos = info[1]
			local alive = info[2]
			if (camp1 - pos):Length2D() < 250 and alive then
				checkPos = true
			end
			if checkPos then
				if (camp2 - pos):Length2D() < 250 and alive then
					check = true
					break
				end
			end
		end
	end

	return check

end

function AIO_Umbrella.TinkerSetCampsToCleared(myHero, pos)

	if not myHero then return end
	if not pos then return end
		pos:SetZ(0)

	local minute = math.floor((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60)

	for i, v in ipairs(AIO_Umbrella.JungleTrackTable) do
		if v then
			local campPos = v[1]
			local alive = v[2]
			if (pos - campPos):Length2D() < 1500 then
				if alive then
					AIO_Umbrella.JungleTrackTable[i][2] = false
					AIO_Umbrella.JungleTrackTable[i][3] = minute
				end
			end
		end
	end

	return

end

function AIO_Umbrella.TinkerIsShrineAlive(myHero, pos)
	
	if not myHero then return false end
	if not pos then return false end

	for i = 1, NPCs.Count() do
		local npcs = NPCs.Get(i)
		if npcs and Entity.IsNPC(npcs) and Entity.IsSameTeam(myHero, npcs) and NPC.IsStructure(npcs) and Entity.IsAlive(npcs) then
			if Entity.GetClassName(npcs) == "C_DOTA_BaseNPC_Healer" then
				local entityPos = Entity.GetAbsOrigin(npcs)
				if (entityPos - pos):Length2D() < 6000 then
					return true
				end
			end
		end
	end

	return false

end

function AIO_Umbrella.GenericJungleTracker(myHero)

	if not myHero then return end
	if GameRules.GetGameStartTime() < 1 then return end
	if GameRules.GetGameTime() - GameRules.GetGameStartTime() < 59 then return end

	local minute = math.floor((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60)
	local respawnChecker = false
		if (((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60) - minute) > 0.99 or (((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60) - minute) < 0.02 then
			respawnChecker = true
		end
	
	if next(AIO_Umbrella.JungleTrackTable) == nil then
		for i = 1, 14 do
			table.insert(AIO_Umbrella.JungleTrackTable, { AIO_Umbrella.JunglePositionTable[i][1], true, minute, AIO_Umbrella.JunglePositionTable[i][4], AIO_Umbrella.JunglePositionTable[i][2], AIO_Umbrella.JunglePositionTable[i][3] })
		end
	end

	if next(AIO_Umbrella.ShrinePositionTable) == nil then
		if AIO_Umbrella.GetMyFaction(myHero) == "radiant" then
			AIO_Umbrella.ShrinePositionTable = {	
				top = Vector(-4389, 211, 0),
				bot = Vector(1313, -4163, 0)
					}
		else
			AIO_Umbrella.ShrinePositionTable = {	
				bot = Vector(3443, 316, 0),
				top = Vector(-1221, 3905, 0)
					}
		end
	end

	if respawnChecker then
		for key, info in ipairs(AIO_Umbrella.JungleTrackTable) do
			if info then
				local update = info[3]
				local pos = info[1]
				if minute > update then
					if #Heroes.InRadius(pos, 800, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH) < 1 then
						AIO_Umbrella.JungleTrackTable[key][2] = true
						AIO_Umbrella.JungleTrackTable[key][3] = minute
					else
						AIO_Umbrella.JungleTrackTable[key][3] = minute
					end
				end
			end
		end
	end

	return	

end

function AIO_Umbrella.TinkerGetJunglePos(myHero, march, rearm)

	if not myHero then return end
	if next(AIO_Umbrella.JungleTrackTable) == nil then return end
	if not march then return end
		if Ability.GetLevel(march) < 4 then return end
	if not rearm then return end

	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
	local myMaxMana = NPC.GetMaxMana(myHero)
		local marchCount = 3
		if NPC.HasAbility(myHero, "special_bonus_unique_tinker_2") and Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_tinker_2")) > 0 then
			marchCount = 2
		end
		local neededMana = Ability.GetManaCost(rearm) * (marchCount - 1) + Ability.GetManaCost(march) * marchCount
			if soulRing then
				neededMana = neededMana - (marchCount * 150)
			end
		if myMaxMana < neededMana then return end

	local farmRadiantTop = {{ Vector(-4862, -477, 0), Vector(-3707, 878, 0) }}
	local farmRadiantBottom = {{ Vector(-1845, -4214, 0), Vector(-416, -3345, 0) }, { Vector(4591, -4354, 0), Vector(2889, -4558, 0) }}
	local farmDireBottom = {{ Vector(4411, 847, 0), Vector(2554, 81, 0) }}
	local farmDireTop = {{ Vector(-2000, 4275, 0), Vector(-2677, 4593, 0) }, { Vector(1349, 3317, 0), Vector(-227, 3396, 0) }}

	local myFaction = AIO_Umbrella.GetMyFaction(myHero)

	if next(AIO_Umbrella.TinkerJungleFarmPos) == nil then
		if myFaction == "radiant" then
			if AIO_Umbrella.TinkerIsFarmTupleAlive(myHero, farmRadiantTop[1][1], farmRadiantTop[1][2]) then
				if AIO_Umbrella.TinkerIsShrineAlive(myHero, farmRadiantTop[1][1]) then
					AIO_Umbrella.TinkerJungleFarmPos = { Vector(-4620, 156, 256), Vector(-4568, 252, 256) }
				end
			elseif AIO_Umbrella.TinkerIsFarmTupleAlive(myHero, farmRadiantBottom[1][1], farmRadiantBottom[1][2]) then
				if AIO_Umbrella.TinkerIsShrineAlive(myHero, farmRadiantBottom[1][1]) then
					AIO_Umbrella.TinkerJungleFarmPos = { Vector(-903, -4109, 384), Vector(-1033, -3828, 256) }
				end
			elseif AIO_Umbrella.TinkerIsFarmTupleAlive(myHero, farmRadiantBottom[2][1], farmRadiantBottom[2][2]) then
				if AIO_Umbrella.TinkerIsShrineAlive(myHero, farmRadiantBottom[1][1]) then
					AIO_Umbrella.TinkerJungleFarmPos = { Vector(3670, -4655, 256), Vector(3757, -4497, 256) }
				end
			end
		else
			if AIO_Umbrella.TinkerIsFarmTupleAlive(myHero, farmDireBottom[1][1], farmDireBottom[1][2]) then
				if AIO_Umbrella.TinkerIsShrineAlive(myHero, farmDireBottom[1][1]) then
					AIO_Umbrella.TinkerJungleFarmPos = { Vector(3520, 155, 384), Vector(3696, 321, 384) }
				end
			elseif AIO_Umbrella.TinkerIsFarmTupleAlive(myHero, farmDireTop[1][1], farmDireTop[1][2]) then
				if AIO_Umbrella.TinkerIsShrineAlive(myHero, farmDireTop[1][1]) then
					AIO_Umbrella.TinkerJungleFarmPos = { Vector(-2406, 3738, 256), Vector(-2409, 3863, 256) }
				end
			elseif AIO_Umbrella.TinkerIsFarmTupleAlive(myHero, farmDireTop[2][1], farmDireTop[2][2]) then
				if AIO_Umbrella.TinkerIsShrineAlive(myHero, farmDireTop[1][1]) then
					AIO_Umbrella.TinkerJungleFarmPos = { Vector(474, 3788, 384), Vector(583, 3650, 384) }
				end
			end
		end
	end

	return
	
end

function AIO_Umbrella.TinkerJungleFarm(myHero, myMana, march, rearm, blink, travels)

	if not myHero then return end

	if next(AIO_Umbrella.TinkerJungleFarmPos) == nil then return end

	local movePos = AIO_Umbrella.TinkerJungleFarmPos[1]
	local castPos = AIO_Umbrella.TinkerJungleFarmPos[2]

	local marchCount = 3
		if NPC.HasAbility(myHero, "special_bonus_unique_tinker_2") and Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_tinker_2")) > 0 then
			marchCount = 2
		end

	if not NPC.IsPositionInRange(myHero, movePos, 35, 0) then
		if blink and Ability.IsCastable(blink, myMana) and (Entity.GetAbsOrigin(myHero) - movePos):Length2D() > 500 then
			if (Entity.GetAbsOrigin(myHero) - movePos):Length2D() > 1190 then
				local blinkPos = Entity.GetAbsOrigin(myHero) + (movePos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1190)
				if #Trees.InRadius(blinkPos, 150, true) < 1 then
					Ability.CastPosition(blink, blinkPos)
					AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			else
				Ability.CastPosition(blink, movePos)
				AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			end
		end
		AIO_Umbrella.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, movePos)
	end

	if not NPC.IsRunning(myHero) and NPC.IsPositionInRange(myHero, movePos, 35, 0) then
		if AIO_Umbrella.TinkerMarched < marchCount then	
			if Ability.IsCastable(march, myMana) then
				Ability.CastPosition(march, castPos)
				AIO_Umbrella.TinkerMarched = AIO_Umbrella.TinkerMarched + 1
				AIO_Umbrella.lastTick = os.clock() + 0.65 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			else
				if rearm and Ability.IsCastable(rearm, myMana) then
					Ability.CastNoTarget(rearm)
					AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				else
					if Ability.IsCastable(travels, myMana) then
						Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
						AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						AIO_Umbrella.TinkerMarched = 0
						AIO_Umbrella.TinkerJungle = false
						AIO_Umbrella.TinkerJungleFarmPos = {}
						AIO_Umbrella.TinkerSetCampsToCleared(myHero, castPos)
						return
					end
				end
			end
		else
			if Ability.IsCastable(travels, myMana) then
				Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
				AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				AIO_Umbrella.TinkerMarched = 0
				AIO_Umbrella.TinkerJungle = false
				AIO_Umbrella.TinkerJungleFarmPos = {}
				AIO_Umbrella.TinkerSetCampsToCleared(myHero, castPos)
				return
			else
				if rearm and Ability.IsCastable(rearm, myMana) then
					Ability.CastNoTarget(rearm)
					AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end
		end
	end

	return	
				
end

function AIO_Umbrella.TinkerPush(myHero, myMana, march, rearm, blink, travels)

	if not myHero then return end
	if NPC.IsChannellingAbility(myHero) then return end

	local mousePos = Input.GetWorldCursorPos()

	if not travels then return end

	if not march then return end
		if Ability.GetLevel(march) < 1 then return end

	local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)

	if AIO_Umbrella.heroCanCastSpells(myHero, enemy) == false then return end
	if AIO_Umbrella.isHeroChannelling(myHero) == true then return end 

	if os.clock() < AIO_Umbrella.lastTick then 
		return 
	else
		if NPC.IsRunning(myHero) and AIO_Umbrella.TinkerJungle == false then
			Player.HoldPosition(Players.GetLocal(), myHero, false)
		end
	end

	if AIO_Umbrella.TinkerFarmDANGER(myHero) then
		if AIO_Umbrella.TinkerPushDefend then
			local hex = NPC.GetItem(myHero, "item_sheepstick", true)
			local blood = NPC.GetItem(myHero, "item_bloodthorn", true)
			local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
			local orchid = NPC.GetItem(myHero, "item_orchid", true)
			if AIO_Umbrella.TinkerFarmFindDANGERnpc(myHero) ~= nil then
				local target = AIO_Umbrella.TinkerFarmFindDANGERnpc(myHero)
				if hex and Ability.IsCastable(blink, myMana) then
					Ability.CastTarget(hex, target)
					AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
				if eBlade and Ability.IsCastable(eBlade, myMana) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_HEXED) then
					Ability.CastTarget(eBlade, target)
					AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
				if blood and Ability.IsCastable(blood, myMana) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_HEXED) then
					Ability.CastTarget(blood, target)
					AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
				if orchid and Ability.IsCastable(orchid, myMana) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_HEXED) then
					Ability.CastTarget(orchid, target)
					AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end
		end	
		if blink and Ability.IsCastable(blink, myMana) then
			local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
			if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
				Ability.CastPosition(blink, saveSpot)
				AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			else
				Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
				AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			end
		end
	end
		
	if NPC.HasModifier(myHero, "modifier_fountain_aura_buff") and AIO_Umbrella.TinkerAmIAtFountain(myHero) then
		if not Ability.IsReady(march) or Ability.SecondsSinceLastUse(travels) > -1 then
			if rearm and Ability.IsCastable(rearm, myMana) then
				Ability.CastNoTarget(rearm)
				AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			end
		end

		if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.8 then
			if AIO_Umbrella.TinkerPorted then
				AIO_Umbrella.TinkerPorted = false
				AIO_Umbrella.TinkerJungleFarmPos = {}
				AIO_Umbrella.TinkerJungle = false
				return
			end
		end
	end

	if not AIO_Umbrella.TinkerPorted then
		if AIO_Umbrella.TinkerAmIAtFountain(myHero) then
			if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.8 then	
				if AIO_Umbrella.TinkerPort(myHero, blink) ~= nil then
					if Ability.IsCastable(travels, myMana) then
						Ability.CastPosition(travels, AIO_Umbrella.TinkerPort(myHero, blink))
						AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						AIO_Umbrella.TinkerPorted = true
						AIO_Umbrella.TinkerMarched = 0
						if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerMiscGlimmer) then
							if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > AIO_Umbrella.TinkerGlimmerCastTime then
								Ability.CastTarget(glimmer, myHero)
								AIO_Umbrella.TinkerGlimmerCastTime = os.clock() + 5
								return
							end
						end
						return
					end
				else
					if AIO_Umbrella.TinkerPushJungle then
						AIO_Umbrella.TinkerGetJunglePos(myHero, march, rearm)
						if next(AIO_Umbrella.TinkerJungleFarmPos) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								Ability.CastPosition(travels, AIO_Umbrella.TinkerJungleFarmPos[1])
								AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								AIO_Umbrella.TinkerPorted = true
								AIO_Umbrella.TinkerJungle = true
								AIO_Umbrella.TinkerMarched = 0
								return
							end
						end
					end
				end
			end
		else
			if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.6 then	
				if AIO_Umbrella.TinkerPort(myHero, blink) ~= nil then
					if Ability.IsCastable(travels, myMana) then
						Ability.CastPosition(travels, AIO_Umbrella.TinkerPort(myHero, blink))
						AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						AIO_Umbrella.TinkerPorted = true
						AIO_Umbrella.TinkerMarched = 0
						if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerMiscGlimmer) then
							if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > AIO_Umbrella.TinkerGlimmerCastTime then
								Ability.CastTarget(glimmer, myHero)
								AIO_Umbrella.TinkerGlimmerCastTime = os.clock() + 5
								return
							end
						end
						return
					end
				else
					if AIO_Umbrella.TinkerPushJungle then
						AIO_Umbrella.TinkerGetJunglePos(myHero, march, rearm)
						if next(AIO_Umbrella.TinkerJungleFarmPos) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								Ability.CastPosition(travels, AIO_Umbrella.TinkerJungleFarmPos[1])
								AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								AIO_Umbrella.TinkerPorted = true
								AIO_Umbrella.TinkerJungle = true
								AIO_Umbrella.TinkerMarched = 0
								return
							end
						end
					end
				end
			else
				if Ability.IsCastable(travels, myMana) then
					Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
					AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					AIO_Umbrella.TinkerPorted = false
					AIO_Umbrella.TinkerMarched = 0
					AIO_Umbrella.TinkerJungle = false
					return
				end
			end
		end
	end

	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
		if soulRing and Ability.IsReady(soulRing) then
			if not AIO_Umbrella.TinkerAmIAtFountain(myHero) then
				Ability.CastNoTarget(soulRing)
				Player.HoldPosition(Players.GetLocal(), myHero, true)
				AIO_Umbrella.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			else
				if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.7 then
					Ability.CastNoTarget(soulRing)
					Player.HoldPosition(Players.GetLocal(), myHero, true)
					AIO_Umbrella.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end	
		end

		if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerMiscGlimmer) then
			if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > AIO_Umbrella.TinkerGlimmerCastTime then
				Ability.CastTarget(glimmer, myHero)
				AIO_Umbrella.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				AIO_Umbrella.TinkerGlimmerCastTime = os.clock() + 5
				return
			end
		end

	local bottle = NPC.GetItem(myHero, "item_bottle", true)
		if bottle then
			if Item.GetCurrentCharges(bottle) > 0 then	
				if not NPC.HasModifier(myHero, "modifier_bottle_regeneration") then
					local hpGap = Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)
					local manaGap = NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)
					if hpGap < 0.8 or manaGap < 0.8 then
						Ability.CastNoTarget(bottle)
						AIO_Umbrella.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						return
					end
				end
			end
		end
	
	local targetCreep = nil
	for _, v in ipairs(Entity.GetUnitsInRadius(myHero, 1150, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsNPC(v) and Entity.IsAlive(v) and not Entity.IsDormant(v) and NPC.IsLaneCreep(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= nil and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
			if AIO_Umbrella.TinkerPortGetCreepCount(myHero, myHero, 1250) >= 2 + AIO_Umbrella.TinkerMarched then
				targetCreep = v
				break
			end
		end
	end

	if AIO_Umbrella.TinkerJungle then
		AIO_Umbrella.TinkerJungleFarm(myHero, myMana, march, rearm, blink, travels)
	else
		if targetCreep ~= nil then
			if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
				local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, targetCreep, blink)
				if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
					Ability.CastPosition(blink, saveSpot)
					Player.HoldPosition(Players.GetLocal(), myHero, true)
					AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end

			if AIO_Umbrella.TinkerMarched < Menu.GetValue(AIO_Umbrella.optionHeroTinkerPushMarch) then
				if Ability.IsCastable(march, myMana) then
					Ability.CastPosition(march, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(targetCreep) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(Ability.GetCastRange(march) - 1))
					AIO_Umbrella.lastTick = os.clock() + 0.75 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					AIO_Umbrella.TinkerMarched = AIO_Umbrella.TinkerMarched + 1
					return
				else
					if rearm and Ability.IsCastable(rearm, myMana) then
						Ability.CastNoTarget(rearm)
						AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						return
					else
						if Ability.IsCastable(travels, myMana) then
							Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
							AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							AIO_Umbrella.TinkerMarched = 0
							if AIO_Umbrella.TinkerPushMode then
								AIO_Umbrella.TinkerPusher = false
							end
							return
						end
					end
				end
			else
				if AIO_Umbrella.TinkerPushMode then
					if Ability.IsCastable(travels, myMana) then
						if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
							local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
							if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
								Ability.CastPosition(blink, saveSpot)
								AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							else
								Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
								AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
						Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
						AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						AIO_Umbrella.TinkerMarched = 0
						AIO_Umbrella.TinkerPusher = false
						return
					else
						if rearm and Ability.IsCastable(rearm, myMana) then
							Ability.CastNoTarget(rearm)
							AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							return
						end
					end
				else	
					if NPC.GetMana(myHero) / NPC.GetMaxMana(myHero) < 0.6 then
						if Ability.IsCastable(travels, myMana) then
							if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
								local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
								if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
									Ability.CastPosition(blink, saveSpot)
									AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								else
									Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
									AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
							Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
							AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							AIO_Umbrella.TinkerMarched = 0
							return
						else
							if rearm and Ability.IsCastable(rearm, myMana) then
								Ability.CastNoTarget(rearm)
								AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
					else
						if AIO_Umbrella.TinkerPort(myHero, blink) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
									local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								if blink and Ability.IsReady(blink) then
									AIO_Umbrella.TinkerPorted = false
									AIO_Umbrella.TinkerMarched = 0
									return
								else
									Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
									AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									AIO_Umbrella.TinkerMarched = 0
									return
								end	
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						else
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
									local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
								AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								AIO_Umbrella.TinkerMarched = 0
								return
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						end
					end
				end
			end
		else
			if not AIO_Umbrella.TinkerAmIAtFountain(myHero) then
				if AIO_Umbrella.TinkerPushMode then
					if Ability.IsCastable(travels, myMana) then
						if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
							local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
							if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
								Ability.CastPosition(blink, saveSpot)
								AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							else
								Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
								AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
						Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
						AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						AIO_Umbrella.TinkerMarched = 0
						AIO_Umbrella.TinkerPusher = false
						return
					else
						if rearm and Ability.IsCastable(rearm, myMana) then
							Ability.CastNoTarget(rearm)
							AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							return
						end
					end
				else	
					if NPC.GetMana(myHero) / NPC.GetMaxMana(myHero) < 0.6 then
						if AIO_Umbrella.TinkerPorted then
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
									local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
								AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								AIO_Umbrella.TinkerMarched = 0
								return
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						end
					else
						if AIO_Umbrella.TinkerPort(myHero, blink) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
									local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								if blink and Ability.IsReady(blink) then
									AIO_Umbrella.TinkerPorted = false
									AIO_Umbrella.TinkerMarched = 0
									return
								else
									Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
									AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									AIO_Umbrella.TinkerMarched = 0
									return
								end	
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						else
							if AIO_Umbrella.TinkerPorted then
								if Ability.IsCastable(travels, myMana) then
									if blink and Ability.IsCastable(blink, myMana) and not AIO_Umbrella.TinkerFarmAmISave(myHero) then
										local saveSpot = AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, myHero, blink)
										if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
											Ability.CastPosition(blink, saveSpot)
											AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
											return
										else
											Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (AIO_Umbrella.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
											AIO_Umbrella.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
											return
										end
									end
									Ability.CastPosition(travels, AIO_Umbrella.GetMyFountainPos(myHero))
									AIO_Umbrella.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									AIO_Umbrella.TinkerMarched = 0
									return
								else
									if rearm and Ability.IsCastable(rearm, myMana) then
										Ability.CastNoTarget(rearm)
										AIO_Umbrella.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
							end
						end
					end
				end
			end
		end
	end

	return

end

function AIO_Umbrella.TinkerFarmAmISave(myHero)

	if not myHero then return false end

	local myPos = Entity.GetAbsOrigin(myHero)

	for _, hero in ipairs(Entity.GetHeroesInRadius(myHero, 200, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) then
			if AIO_Umbrella.targetChecker(hero) ~= nil then
				return false
			end
		end
	end

	local saveSpotTable = {
		{ Vector(-7332.3, -3269.6, 384.0), 5},
		{ Vector(-7233.3, -1376.7, 384.0), 10}, 
		{ Vector(-7200.2, -1017.2, 384.0), 8}, 
		{ Vector(-7212.0, -551.6, 384.0), 8}, 
		{ Vector(-7125.0, -81.5, 384.0), 8},
		{ Vector(-7114.0, 337.9, 384.0), 5}, 
		{ Vector(-7194.7, 732.3, 384.0), 5}, 
		{ Vector(-7129.5, 1337.3, 384.0), 7},
		{ Vector(-7140.7, 1645.0, 384.0), 7},
		{ Vector(-7176.3, 2070.1, 384.0), 6}, 
		{ Vector(-7089.6, 2307.1, 512.0), 5}, 
		{ Vector(-6847.4, 3532.0, 384.0), 5}, 
		{ Vector(-7226.3, 3989.3, 384.0), 7}, 
		{ Vector(-6994.7, 4915.7, 384.0), 7}, 
		{ Vector(-6900.2, 5118.8, 384.0), 7}, 
		{ Vector(-6732.6, 5540.4, 384.0), 4}, 
		{ Vector(-6581.3, 5919.3, 384.0), 6}, 
		{ Vector(-6273.9, 6178.2, 384.0), 6}, 
		{ Vector(-6104.3, 6542.5, 384.0), 6}, 
		{ Vector(-5458.8, 6709.4, 384.0), 11}, 
		{ Vector(-5130.0, 6783.1, 384.0), 7}, 
		{ Vector(-4631.4, 6760.8, 384.0), 6}, 
		{ Vector(-4308.8, 6977.7, 384.0), 6}, 
		{ Vector(-3791.8, 6757.7, 384.0), 11}, 
		{ Vector(-3497.5, 6873.4, 384.0), 8}, 
		{ Vector(-3117.5, 6930.3, 384.0), 9}, 
		{ Vector(-2696.9, 6878.1, 384.0), 7}, 
		{ Vector(-2321.5, 6938.8, 384.0), 7}, 
		{ Vector(-1731.7, 6864.3, 384.0), 8}, 
		{ Vector(-1100.2, 6951.0, 384.0), 9}, 
		{ Vector(-767.3, 7021.9, 384.0), 11}, 
		{ Vector(-82.5, 6823.9, 384.0), 7}, 
		{ Vector(183.7, 6728.6, 384.0), 7},
		{ Vector(673.7, 6884.9, 384.0), 13}, 
		{ Vector(1009.9, 6861.5, 384.0), 10}, 
		{ Vector(1561.7, 6964.7, 384.0), 6}, 
		{ Vector(2540.2, 6960.1, 384.0), 4}, 
		{ Vector(3445.1, 6863.7, 384.0), 5}, 
		{ Vector(7400.6, 2808.3, 384.0), 6}, 
		{ Vector(7456.3, 2090.7, 256.0), 6}, 
		{ Vector(7226.0, 866.5, 384.0), 7}, 
		{ Vector(7029.8, 494.1, 384.0), 7}, 
		{ Vector(7086.8, -37.7, 384.0), 8}, 
		{ Vector(6932.5, -577.0, 384.0), 4}, 
		{ Vector(6918.2, -908.3, 384.0), 8}, 
		{ Vector(7080.6, -1472.4, 384.0), 7}, 
		{ Vector(7171.4, -1807.0, 384.0), 7}, 
		{ Vector(7297.8, -2177.6, 384.0), 9}, 
		{ Vector(7031.2, -3224.0, 384.0), 5}, 
		{ Vector(6898.3, -3549.7, 384.0), 7}, 
		{ Vector(7460.4, -4648.6, 384.0), 8}, 
		{ Vector(6924.8, -4814.6, 384.0), 6}, 
		{ Vector(6891.3, -5163.1, 384.0), 7}, 
		{ Vector(6701.0, -5480.9, 384.0), 5}, 
		{ Vector(6647.3, -5824.5, 384.0), 10},
		{ Vector(6583.7, -6132.0, 384.0), 11}, 
		{ Vector(6381.3, -6424.0, 384.0), 9}, 
		{ Vector(6059.3, -6451.0, 384.0), 9}, 
		{ Vector(6021.2, -6588.0, 384.0), 8}, 
		{ Vector(5650.1, -6737.3, 384.0), 5}, 
		{ Vector(5378.8, -6735.7, 384.0), 7}, 
		{ Vector(4971.6, -6738.0, 384.0), 7}, 
		{ Vector(4536.9, -6652.2, 384.0), 6}, 
		{ Vector(4333.0, -6725.9, 384.0), 8}, 
		{ Vector(3879.9, -6734.2, 384.0), 10}, 
		{ Vector(3364.7, -6777.9, 384.0), 9}, 
		{ Vector(3013.5, -6804.8, 384.0), 10}, 
		{ Vector(2696.2, -6795.6, 384.0), 9}, 
		{ Vector(2388.5, -6791.8, 384.0), 9}, 
		{ Vector(1970.3, -6840.6, 384.0), 5}, 
		{ Vector(1594.9, -6898.8, 384.0), 2}, 
		{ Vector(1150.0, -6852.4, 384.0), 6}, 
		{ Vector(759.1, -6957.8, 384.0), 6}, 
		{ Vector(289.0, -6964.5, 384.0), 5}, 
		{ Vector(-330.1, -6876.5, 384.0), 8},
		{ Vector(-623.6, -6858.6, 384.0), 6}, 
		{ Vector(-1073.9, -6927.4, 384.0), 5}, 
		{ Vector(-2947.8, -6995.1, 256.0), 1}, 
		{ Vector(-3990.3, -7001.3, 384.0), 7}, 
		{ Vector(-530.9, -5611.3, 384.0), 7}, 
		{ Vector(2463.7, -5622.4, 384.0), 8}, 
		{ Vector(3951.0, -5522.6, 384.0), 7}, 
		{ Vector(5655.3, -3890.3, 384.0), 6}, 
		{ Vector(5565.6, -1369.1, 384.0), 7}, 
		{ Vector(5690.3, 995.4, 384.0), 6}, 
		{ Vector(2228.6, 2684.7, 256.0), 6}, 
		{ Vector(2939.3, 1222.4, 256.0), 8}, 
		{ Vector(1008.6, 1594.0, 256.0), 8}, 
		{ Vector(489.5, 1282.0, 256.0), 7}, 
		{ Vector(1283.7, 19.7, 256.0), 8}, 
		{ Vector(-907.4, -1464.5, 256.0), 7}, 
		{ Vector(-2041.0, -936.2, 256.0), 7}, 
		{ Vector(-2490.0, -1083.8, 256.0), 5}, 
		{ Vector(-1236.1, -1858.3, 256.0), 7}, 
		{ Vector(-2032.8, -2420.4, 256.0), 7}, 
		{ Vector(-2303.3, -2759.6, 256.0), 6}, 
		{ Vector(-2832.8, -1435.9, 256.0), 5}, 
		{ Vector(-3888.1, -2336.0, 256.0), 3}, 
		{ Vector(-2676.4, 5523.4, 384.0), 8}, 
		{ Vector(-1180.0, 5551.6, 384.0), 8}
			}

	for _, saveInfo in ipairs(saveSpotTable) do
		local savePos = saveInfo[1]
		if savePos then
			local distance = (myPos - savePos):Length2D()
			if distance < 75 then
				return true
			end
		end
	end

	if #Trees.InRadius(myPos, 250, true) >= 4 then
		return true
	end

	return false

end

function AIO_Umbrella.TinkerFarmDANGER(myHero)

	if not myHero then return false end
	if AIO_Umbrella.TinkerAmIAtFountain(myHero) then return false end

	if next(AIO_Umbrella.dodgeItTable) ~= nil then return true end
	if AIO_Umbrella.TargetGotDisableModifier(myHero, myHero) == true then return true end
	if NPC.IsSilenced(myHero) then return true end

	for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			if NPC.FindFacingNPC(v) == myHero then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
					if NPC.IsAttacking(v) then
						return true
					end
				end
			end
		end	
	end

	return false

end

function AIO_Umbrella.TinkerFarmFindDANGERnpc(myHero)

	if not myHero then return end

	local npc = nil
	for _, v in ipairs(Entity.GetHeroesInRadius(myHero, 750, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			if NPC.IsAttacking(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
					if NPC.FindFacingNPC(v) == myHero then
						npc = v
						break
					end
				end
			end
			for ability, info in pairs(AIO_Umbrella.RawDamageAbilityEstimation) do
				if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
					local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
					local abilityRadius = info[3]
					if AIO_Umbrella.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
						npc = v
						break
					end
				end
			end	
		end
	end

	return npc

end

function AIO_Umbrella.TinkerFarmGetSaveSpot(myHero, target, blink)

	if not myHero then return end
	if not target then return end
	if not blink then return end

	local targetPos = Entity.GetAbsOrigin(target)
	local myPos = Entity.GetAbsOrigin(myHero)

	local saveSpotTable = {
		{ Vector(-7332.3, -3269.6, 384.0), 5},
		{ Vector(-7233.3, -1376.7, 384.0), 10}, 
		{ Vector(-7200.2, -1017.2, 384.0), 8}, 
		{ Vector(-7212.0, -551.6, 384.0), 8}, 
		{ Vector(-7125.0, -81.5, 384.0), 8},
		{ Vector(-7114.0, 337.9, 384.0), 5}, 
		{ Vector(-7194.7, 732.3, 384.0), 5}, 
		{ Vector(-7129.5, 1337.3, 384.0), 7},
		{ Vector(-7140.7, 1645.0, 384.0), 7},
		{ Vector(-7176.3, 2070.1, 384.0), 6}, 
		{ Vector(-7089.6, 2307.1, 512.0), 5}, 
		{ Vector(-6847.4, 3532.0, 384.0), 5}, 
		{ Vector(-7226.3, 3989.3, 384.0), 7}, 
		{ Vector(-6994.7, 4915.7, 384.0), 7}, 
		{ Vector(-6900.2, 5118.8, 384.0), 7}, 
		{ Vector(-6732.6, 5540.4, 384.0), 4}, 
		{ Vector(-6581.3, 5919.3, 384.0), 6}, 
		{ Vector(-6273.9, 6178.2, 384.0), 6}, 
		{ Vector(-6104.3, 6542.5, 384.0), 6}, 
		{ Vector(-5458.8, 6709.4, 384.0), 11}, 
		{ Vector(-5130.0, 6783.1, 384.0), 7}, 
		{ Vector(-4631.4, 6760.8, 384.0), 6}, 
		{ Vector(-4308.8, 6977.7, 384.0), 6}, 
		{ Vector(-3791.8, 6757.7, 384.0), 11}, 
		{ Vector(-3497.5, 6873.4, 384.0), 8}, 
		{ Vector(-3117.5, 6930.3, 384.0), 9}, 
		{ Vector(-2696.9, 6878.1, 384.0), 7}, 
		{ Vector(-2321.5, 6938.8, 384.0), 7}, 
		{ Vector(-1731.7, 6864.3, 384.0), 8}, 
		{ Vector(-1100.2, 6951.0, 384.0), 9}, 
		{ Vector(-767.3, 7021.9, 384.0), 11}, 
		{ Vector(-82.5, 6823.9, 384.0), 7}, 
		{ Vector(183.7, 6728.6, 384.0), 7},
		{ Vector(673.7, 6884.9, 384.0), 13}, 
		{ Vector(1009.9, 6861.5, 384.0), 10}, 
		{ Vector(1561.7, 6964.7, 384.0), 6}, 
		{ Vector(2540.2, 6960.1, 384.0), 4}, 
		{ Vector(3445.1, 6863.7, 384.0), 5}, 
		{ Vector(7400.6, 2808.3, 384.0), 6}, 
		{ Vector(7456.3, 2090.7, 256.0), 6}, 
		{ Vector(7226.0, 866.5, 384.0), 7}, 
		{ Vector(7029.8, 494.1, 384.0), 7}, 
		{ Vector(7086.8, -37.7, 384.0), 8}, 
		{ Vector(6932.5, -577.0, 384.0), 4}, 
		{ Vector(6918.2, -908.3, 384.0), 8}, 
		{ Vector(7080.6, -1472.4, 384.0), 7}, 
		{ Vector(7171.4, -1807.0, 384.0), 7}, 
		{ Vector(7297.8, -2177.6, 384.0), 9}, 
		{ Vector(7031.2, -3224.0, 384.0), 5}, 
		{ Vector(6898.3, -3549.7, 384.0), 7}, 
		{ Vector(7460.4, -4648.6, 384.0), 8}, 
		{ Vector(6924.8, -4814.6, 384.0), 6}, 
		{ Vector(6891.3, -5163.1, 384.0), 7}, 
		{ Vector(6701.0, -5480.9, 384.0), 5}, 
		{ Vector(6647.3, -5824.5, 384.0), 10},
		{ Vector(6583.7, -6132.0, 384.0), 11}, 
		{ Vector(6381.3, -6424.0, 384.0), 9}, 
		{ Vector(6059.3, -6451.0, 384.0), 9}, 
		{ Vector(6021.2, -6588.0, 384.0), 8}, 
		{ Vector(5650.1, -6737.3, 384.0), 5}, 
		{ Vector(5378.8, -6735.7, 384.0), 7}, 
		{ Vector(4971.6, -6738.0, 384.0), 7}, 
		{ Vector(4536.9, -6652.2, 384.0), 6}, 
		{ Vector(4333.0, -6725.9, 384.0), 8}, 
		{ Vector(3879.9, -6734.2, 384.0), 10}, 
		{ Vector(3364.7, -6777.9, 384.0), 9}, 
		{ Vector(3013.5, -6804.8, 384.0), 10}, 
		{ Vector(2696.2, -6795.6, 384.0), 9}, 
		{ Vector(2388.5, -6791.8, 384.0), 9}, 
		{ Vector(1970.3, -6840.6, 384.0), 5}, 
		{ Vector(1594.9, -6898.8, 384.0), 2}, 
		{ Vector(1150.0, -6852.4, 384.0), 6}, 
		{ Vector(759.1, -6957.8, 384.0), 6}, 
		{ Vector(289.0, -6964.5, 384.0), 5}, 
		{ Vector(-330.1, -6876.5, 384.0), 8},
		{ Vector(-623.6, -6858.6, 384.0), 6}, 
		{ Vector(-1073.9, -6927.4, 384.0), 5}, 
		{ Vector(-2947.8, -6995.1, 256.0), 1}, 
		{ Vector(-3990.3, -7001.3, 384.0), 7}, 
		{ Vector(-530.9, -5611.3, 384.0), 7}, 
		{ Vector(2463.7, -5622.4, 384.0), 8}, 
		{ Vector(3951.0, -5522.6, 384.0), 7}, 
		{ Vector(5655.3, -3890.3, 384.0), 6}, 
		{ Vector(5565.6, -1369.1, 384.0), 7}, 
		{ Vector(5690.3, 995.4, 384.0), 6}, 
		{ Vector(2228.6, 2684.7, 256.0), 6}, 
		{ Vector(2939.3, 1222.4, 256.0), 8}, 
		{ Vector(1008.6, 1594.0, 256.0), 8}, 
		{ Vector(489.5, 1282.0, 256.0), 7}, 
		{ Vector(1283.7, 19.7, 256.0), 8}, 
		{ Vector(-907.4, -1464.5, 256.0), 7}, 
		{ Vector(-2041.0, -936.2, 256.0), 7}, 
		{ Vector(-2490.0, -1083.8, 256.0), 5}, 
		{ Vector(-1236.1, -1858.3, 256.0), 7}, 
		{ Vector(-2032.8, -2420.4, 256.0), 7}, 
		{ Vector(-2303.3, -2759.6, 256.0), 6}, 
		{ Vector(-2832.8, -1435.9, 256.0), 5}, 
		{ Vector(-3888.1, -2336.0, 256.0), 3}, 
		{ Vector(-2676.4, 5523.4, 384.0), 8}, 
		{ Vector(-1180.0, 5551.6, 384.0), 8}
			}

	for _, saveInfo in ipairs(saveSpotTable) do
		local savePos = saveInfo[1]
		local treesAround = saveInfo[2]
		if savePos and #Trees.InRadius(savePos, 251, true) >= treesAround - 1 then
			local distance = (myPos - savePos):Length2D()
			if distance > 200 and distance < 1125 then
				local distanceCreep = (savePos - targetPos):Length2D()
				if distanceCreep < 1050 then
					return savePos
				end
			end
		end
	end

	local treeCount = 0
	local targetTree = nil
	for _, tree in ipairs(Trees.InRadius(targetPos, 900, true)) do
		if tree then
			local treePos = Entity.GetAbsOrigin(tree)
			local myDist = myPos:__sub(treePos):Length2D()
			if myDist >= 315 and myDist < 1100 then
				local treesAround = #Trees.InRadius(treePos, 350, true)
				if treesAround > treeCount then
					treeCount = treesAround
					targetTree = tree
				end
			end
		end
	end

	local treeTargetPos = nil
	if treeCount >= 4 then
		if targetTree ~= nil then
			local bestPos = AIO_Umbrella.getBestPosition(Trees.InRadius(Entity.GetAbsOrigin(targetTree), 400, true), 200)
			if bestPos ~= nil and bestPos:__sub(targetPos):Length2D() < 1000 and bestPos:__sub(myPos):Length2D() < 1125 then
				treeTargetPos = bestPos
			end		
		end
	end

	if treeTargetPos ~= nil then
		if #Trees.InRadius(treeTargetPos, 25, true) > 0 then
			return (treeTargetPos + (treeTargetPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(35))
		else
			return treeTargetPos
		end
	else
		local myFountainPos = AIO_Umbrella.GetMyFountainPos(myHero)
		local myDist = myPos:__sub(targetPos):Length2D()
		local gap = 1050 - myDist
		local searchPosition =  myPos + (myFountainPos - myPos):Normalized():Scaled(gap)
		local treesArcoundPos = Trees.InRadius(searchPosition, gap, true)
		local myPosZ = myPos:GetZ()
		for _, tree in ipairs(treesArcoundPos) do
			if tree then
				local treePos = Entity.GetAbsOrigin(tree)
				local treePosZ = treePos:GetZ()
				if (treePos - myPos):Length2D() < 1050 then
					if treePosZ > myPosZ and math.abs(treePosZ - myPosZ) > 50 then
						return myPos + (treePos - myPos):Scaled(0.9)
					end
				end
			end
		end
	end

	return

end

function AIO_Umbrella.TinkerPortGetCreepCount(myHero, target, range)

	if not myHero then return 0 end
	if not target then return 0 end

	local count = 0
	for _, npc in ipairs(Entity.GetUnitsInRadius(target, range, Enum.TeamType.TEAM_ENEMY)) do
		if npc and Entity.IsNPC(npc) and Entity.IsAlive(npc) and NPC.IsLaneCreep(npc) and not NPC.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
			if (Entity.GetHealth(npc) / Entity.GetMaxHealth(npc)) > 0.6 then
				count = count + 1
			end
		end
	end

	return count
		
end

function AIO_Umbrella.TinkerPortGetHeroCount(myHero, target, range)

	if not myHero then return 0 end
	if not target then return 0 end

	local count = 0
	for _, hero in ipairs(Entity.GetHeroesInRadius(target, range, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and Entity.IsAlive(hero) and not NPC.IsDormant(hero) and not NPC.IsIllusion(hero) then
			count = count + 1
		end
	end

	return count
		
end

function AIO_Umbrella.TinkerPort(myHero, blink)

	if not myHero then return end

	local enemyFountainPos = AIO_Umbrella.GetEnemyFountainPos(myHero)
	local myFountainPos = AIO_Umbrella.GetMyFountainPos(myHero)

	if AIO_Umbrella.TinkerPushMode then
		local targetCreep
		local maxDistance = 99999
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and Entity.IsAlive(npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not NPC.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if npc ~= nil then
						local creepPosition = Entity.GetAbsOrigin(npc)
						local distanceToMouse = (creepPosition - Input.GetWorldCursorPos()):Length2D()
						if distanceToMouse < maxDistance then
							targetCreep = npc
							maxDistance = distanceToMouse
						end
					end
				end
			end
		end

		if targetCreep == nil then
			maxDistance = 99999
		end

		if targetCreep then
			return Entity.GetAbsOrigin(targetCreep)
		end
	else
		local targetCreep = nil
		local creepCount = 0
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not NPC.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if (Entity.GetHealth(npc) / Entity.GetMaxHealth(npc)) >= 0.6 and #Entity.GetUnitsInRadius(npc, 500, Enum.TeamType.TEAM_FRIEND) >= 2 then
						if (Entity.GetAbsOrigin(npc) - Entity.GetAbsOrigin(myHero)):Length2D() > 3000 then	
							if AIO_Umbrella.TinkerPortGetCreepCount(myHero, npc, 900) >= AIO_Umbrella.TinkerPushCreeps and AIO_Umbrella.TinkerPortGetHeroCount(myHero, npc, 900) <= AIO_Umbrella.TinkerPushEnemies and #Entity.GetHeroesInRadius(npc, 900, Enum.TeamType.TEAM_FRIEND) <= AIO_Umbrella.TinkerPushAllies then
								if AIO_Umbrella.TinkerPushSave then
									if not blink then
										if AIO_Umbrella.TinkerPortGetCreepCount(myHero, npc, 900) > creepCount then
											creepCount = AIO_Umbrella.TinkerPortGetCreepCount(myHero, npc, 900)
											targetCreep = npc
										end
									else
										if AIO_Umbrella.TinkerFarmGetSaveSpot(npc, npc, blink) ~= nil then
											if AIO_Umbrella.TinkerPortGetCreepCount(myHero, npc, 900) > creepCount then
												creepCount = AIO_Umbrella.TinkerPortGetCreepCount(myHero, npc, 900)
												targetCreep = npc
											end
										end
									end
								else
									if AIO_Umbrella.TinkerPortGetCreepCount(myHero, npc, 900) > creepCount then
										creepCount = AIO_Umbrella.TinkerPortGetCreepCount(myHero, npc, 900)
										targetCreep = npc
									end
								end
							end
						end
					end
				end
			end
		end

		if targetCreep == nil then
			creepCount = 0
		end

		if targetCreep ~= nil then
			return Entity.GetAbsOrigin(targetCreep)
		end
	end

	return
end

function AIO_Umbrella.drawTinkerPanel(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(AIO_Umbrella.optionHeroTinker) then return end
	
	if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroTinkerPanelKey) then
		AIO_Umbrella.Toggler = not AIO_Umbrella.Toggler
	end
	
	if AIO_Umbrella.Toggler then return end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	if AIO_Umbrella.TinkerPanelX ~= Config.ReadInt("tinker", "panelX", w/2) then
		AIO_Umbrella.TinkerPanelX = Config.ReadInt("tinker", "panelX", w/2)
	end
	if AIO_Umbrella.TinkerPanelY ~= Config.ReadInt("tinker", "panelY", h/2) then
		AIO_Umbrella.TinkerPanelY = Config.ReadInt("tinker", "panelY", h/2)
	end

	if Menu.IsEnabled(AIO_Umbrella.optionHeroTinkerPanelMove) then
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_UP) then
			AIO_Umbrella.TinkerPanelY = AIO_Umbrella.TinkerPanelY - 10
			Config.WriteInt("tinker", "panelY", AIO_Umbrella.TinkerPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_DOWN) then
			AIO_Umbrella.TinkerPanelY = AIO_Umbrella.TinkerPanelY + 10
			Config.WriteInt("tinker", "panelY", AIO_Umbrella.TinkerPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_LEFT) then
			AIO_Umbrella.TinkerPanelX = AIO_Umbrella.TinkerPanelX - 10
			Config.WriteInt("tinker", "panelX", AIO_Umbrella.TinkerPanelX)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_RIGHT) then
			AIO_Umbrella.TinkerPanelX = AIO_Umbrella.TinkerPanelX + 10
			Config.WriteInt("tinker", "panelX", AIO_Umbrella.TinkerPanelX)
		end
	end

	local startX = AIO_Umbrella.TinkerPanelX
	local startY = AIO_Umbrella.TinkerPanelY

	local width = 140
	local height = 320

	 -- black background
	Renderer.SetDrawColor(0, 0, 0, 125)
	Renderer.DrawFilledRect(startX, startY, width, height)


	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY, width, height)

	Renderer.SetDrawColor(255, 0, 0, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startX + width/2, startY + 10, "PUSH OPTIONS", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startX+1, startY+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startX + width/2, startY + 30, "Push target", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+21, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY+40, width/2, 20)
	Renderer.DrawOutlineRect(startX + width/2, startY+40, width/2, 20)

	local hoveringOverAuto = Input.IsCursorInRect(startX, startY+40, width/2, 20)
	local hoveringOverCursor = Input.IsCursorInRect(startX + width/2, startY+40, width/2, 20)

	if hoveringOverAuto and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if AIO_Umbrella.TinkerPushMode then
			AIO_Umbrella.TinkerPushMode = not AIO_Umbrella.TinkerPushMode
		end
	end

	if hoveringOverCursor and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if not AIO_Umbrella.TinkerPushMode then
			AIO_Umbrella.TinkerPushMode = not AIO_Umbrella.TinkerPushMode
		end
	end
	
	if not AIO_Umbrella.TinkerPushMode then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	end

	Renderer.SetDrawColor(0, 191, 255, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startX + width/2, startY + 70, "Auto line options", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+61, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)

	Renderer.DrawOutlineRect(startX + width/4*3, startY+80, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)	
	Renderer.DrawText(AIO_Umbrella.arcWardenfont, startX + 5, startY + 81, "Min. creeps", 1)

	local hoveringOverCreeps = Input.IsCursorInRect(startX + width/4*3, startY+80, width/4, 20)
	if hoveringOverCreeps and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not AIO_Umbrella.TinkerPushMode then
		if AIO_Umbrella.TinkerPushCreeps < 5 then
			AIO_Umbrella.TinkerPushCreeps = AIO_Umbrella.TinkerPushCreeps + 1
		end
	end

	if hoveringOverCreeps and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_RIGHT) and not AIO_Umbrella.TinkerPushMode then
		if AIO_Umbrella.TinkerPushCreeps > 1 then
			AIO_Umbrella.TinkerPushCreeps = AIO_Umbrella.TinkerPushCreeps - 1
		end
	end

	if AIO_Umbrella.TinkerPushCreeps > 0 then
		if not AIO_Umbrella.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 0, 255)	
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 81, AIO_Umbrella.TinkerPushCreeps, 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 81, AIO_Umbrella.TinkerPushCreeps, 0)
	end	

	
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+100, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(AIO_Umbrella.arcWardenfont, startX + 5, startY + 101, "Max. enemies", 1)

	local hoveringOverEnemies = Input.IsCursorInRect(startX + width/4*3, startY+100, width/4, 20)
	if hoveringOverEnemies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not AIO_Umbrella.TinkerPushMode then
		if AIO_Umbrella.TinkerPushEnemies < 5 then
			AIO_Umbrella.TinkerPushEnemies = AIO_Umbrella.TinkerPushEnemies + 1
		end
	end

	if hoveringOverEnemies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_RIGHT) and not AIO_Umbrella.TinkerPushMode then
		if AIO_Umbrella.TinkerPushEnemies > 0 then
			AIO_Umbrella.TinkerPushEnemies = AIO_Umbrella.TinkerPushEnemies - 1
		end
	end

	if AIO_Umbrella.TinkerPushEnemies > 0 then
		if not AIO_Umbrella.TinkerPushMode then
			Renderer.SetDrawColor(255, 64, 64, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 101, AIO_Umbrella.TinkerPushEnemies, 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 101, AIO_Umbrella.TinkerPushEnemies, 0)
	end

	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+120, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(AIO_Umbrella.arcWardenfont, startX + 5, startY + 121, "Max. allies", 1)

	local hoveringOverAllies = Input.IsCursorInRect(startX + width/4*3, startY+120, width/4, 20)
	if hoveringOverAllies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not AIO_Umbrella.TinkerPushMode then
		if AIO_Umbrella.TinkerPushAllies < 5 then
			AIO_Umbrella.TinkerPushAllies = AIO_Umbrella.TinkerPushAllies + 1
		end
	end

	if hoveringOverAllies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_RIGHT) and not AIO_Umbrella.TinkerPushMode then
		if AIO_Umbrella.TinkerPushAllies > 0 then
			AIO_Umbrella.TinkerPushAllies = AIO_Umbrella.TinkerPushAllies - 1
		end
	end

	if AIO_Umbrella.TinkerPushAllies > 0 then
		if not AIO_Umbrella.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 255, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 121, AIO_Umbrella.TinkerPushAllies, 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 121, AIO_Umbrella.TinkerPushAllies, 0)
	end

	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+140, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(AIO_Umbrella.arcWardenfont, startX + 5, startY + 141, "Only save TP", 1)

	local hoveringOverSave = Input.IsCursorInRect(startX + width/4*3, startY+140, width/4, 20)
	if hoveringOverSave and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not AIO_Umbrella.TinkerPushMode then
		AIO_Umbrella.TinkerPushSave = not AIO_Umbrella.TinkerPushSave
	end

	if AIO_Umbrella.TinkerPushSave then
		if not AIO_Umbrella.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 141, "on", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 141, "off", 0)
	end


	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+160, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(AIO_Umbrella.arcWardenfont, startX + 5, startY + 161, "Auto defend", 1)

	local hoveringOverDefend = Input.IsCursorInRect(startX + width/4*3, startY+160, width/4, 20)
	if hoveringOverDefend and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		AIO_Umbrella.TinkerPushDefend = not AIO_Umbrella.TinkerPushDefend
	end

	if AIO_Umbrella.TinkerPushDefend then
		Renderer.SetDrawColor(0, 255, 0, 255)	
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 161, "on", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 161, "off", 0)
	end

	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+180, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(AIO_Umbrella.arcWardenfont, startX + 5, startY + 181, "Allow jungle", 1)

	local hoveringOverJungle = Input.IsCursorInRect(startX + width/4*3, startY+180, width/4, 20)
	if hoveringOverJungle and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not AIO_Umbrella.TinkerPushMode then
		AIO_Umbrella.TinkerPushJungle = not AIO_Umbrella.TinkerPushJungle
	end

	if AIO_Umbrella.TinkerPushJungle then
		if not AIO_Umbrella.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 181, "on", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/4*3 + 18, startY + 181, "off", 0)
	end

	local startXinfo = startX
	local startYinfo = startY + 210

	Renderer.SetDrawColor(255, 0, 0, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 10, "INFORMATION", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startXinfo+1, startYinfo+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Renderer.DrawTextCentered(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 30, "Tinker action", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startYinfo+21, width-2, 20-2)


		if AIO_Umbrella.TinkerStatus == 0 then
			Renderer.SetDrawColor(255, 100, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startX + width/2, startYinfo + 40, "manual", 0)

		elseif AIO_Umbrella.TinkerStatus == 1 and AIO_Umbrella.LockedTarget ~= nil then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "comboing", 0)
			local heroName = NPC.GetUnitName(AIO_Umbrella.LockedTarget)
			local heroNameShort = string.gsub(heroName, "npc_dota_hero_", "")
			local imageHandle
				if AIO_Umbrella.heroIconHandler[heroNameShort] ~= nil then
					imageHandle = AIO_Umbrella.heroIconHandler[heroNameShort]
				else
					imageHandle = Renderer.LoadImage(AIO_Umbrella.heroIconPath .. heroNameShort .. ".png")
					AIO_Umbrella.heroIconHandler[heroNameShort] = imageHandle
				end
			Renderer.SetDrawColor(255, 255, 255, 255)
			Renderer.DrawImage(imageHandle, startX + width/2 - 35, startYinfo + 58, 67, 48)

		elseif AIO_Umbrella.TinkerStatus == 2 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "TP pushing", 0)

		elseif AIO_Umbrella.TinkerStatus == 3 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Renderer.DrawTextCenteredX(AIO_Umbrella.arcWardenfont, startXinfo + width/2, startYinfo + 40, "Rocket spam", 0)
		end


end
	
function AIO_Umbrella.KunkkaShipCombo(myHero, enemy)

	if not Menu.IsEnabled(AIO_Umbrella.optionHeroKunkkaShip) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local X = NPC.GetAbility(myHero, "kunkka_x_marks_the_spot")
	local Xreturn = NPC.GetAbility(myHero, "kunkka_return")
	local Ship = NPC.GetAbility(myHero, "kunkka_ghostship")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	AIO_Umbrella.itemUsage(myHero, enemy)

	if os.clock() < AIO_Umbrella.lastTick then return end

	if AIO_Umbrella.kunkkaGhostshipTimer < os.clock() then
		if enemy and Entity.IsAlive(enemy) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(enemy) and AIO_Umbrella.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.HasModifier(enemy, "modifier_kunkka_x_marks_the_spot") then
				if Menu.IsKeyDownOnce(AIO_Umbrella.optionHeroKunkkaShipKey) then
					if Ship and Ability.IsCastable(Ship, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Ship)) then
						if X and Ability.IsCastable(X, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(X)) then
							Ability.CastTarget(X, enemy)
							AIO_Umbrella.kunkkaXMarkPosition = Entity.GetAbsOrigin(enemy)
							AIO_Umbrella.kunkkaXMarkCastTime = os.clock() + 1
							AIO_Umbrella.lastTick = os.clock() + 0.1
							return
						end
					end
				end
			else
				if Ship and Ability.IsCastable(Ship, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Ship)) then
					Ability.CastPosition(Ship, AIO_Umbrella.kunkkaXMarkPosition)
					AIO_Umbrella.kunkkaGhostshipTimer = os.clock() + 3.08
					AIO_Umbrella.lastTick = os.clock() + 0.1
					return
				end
			end
		end
	else
		if AIO_Umbrella.kunkkaGhostshipTimer - os.clock() <= 2.05 then
			if Q and Ability.IsCastable(Q, myMana) then
				Ability.CastPosition(Q, AIO_Umbrella.kunkkaXMarkPosition)
				AIO_Umbrella.lastTick = os.clock() + 0.1
				return
			end
		end

		if AIO_Umbrella.kunkkaGhostshipTimer - os.clock() <= 0.55 then
			if Xreturn and Ability.IsCastable(Xreturn, myMana) then
				Ability.CastNoTarget(Xreturn)
				AIO_Umbrella.lastTick = os.clock() + 0.1
				return
			end
		end
	end

	return

end

return AIO_Umbrella
			